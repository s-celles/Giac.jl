<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core API · Giac.jl</title><meta name="title" content="Core API · Giac.jl"/><meta property="og:title" content="Core API · Giac.jl"/><meta property="twitter:title" content="Core API · Giac.jl"/><meta name="description" content="Documentation for Giac.jl."/><meta property="og:description" content="Documentation for Giac.jl."/><meta property="twitter:description" content="Documentation for Giac.jl."/><meta property="og:url" content="https://s-celles.github.io/Giac.jl/api/core/"/><meta property="twitter:url" content="https://s-celles.github.io/Giac.jl/api/core/"/><link rel="canonical" href="https://s-celles.github.io/Giac.jl/api/core/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Giac.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quick Start</a></li><li><a class="tocitem" href="../../variables/">Variable Declaration</a></li><li><a class="tocitem" href="../../command_discovery_help/">Command discovery and help</a></li><li><a class="tocitem" href="../../substitute/">Variable Substitution</a></li><li><a class="tocitem" href="../../pluto/">Using with Pluto reactive notebooks</a></li><li><span class="tocitem">Mathematics</span><ul><li><a class="tocitem" href="../../mathematics/algebra/">Algebra</a></li><li><a class="tocitem" href="../../mathematics/calculus/">Calculus</a></li><li><a class="tocitem" href="../../mathematics/linear_algebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../mathematics/differential_equations/">Differential Equations</a></li><li><a class="tocitem" href="../../mathematics/trigonometry/">Trigonometry</a></li></ul></li><li><span class="tocitem">Physics</span><ul><li><a class="tocitem" href="../../physics/mechanics/">Mechanics</a></li><li><a class="tocitem" href="../../physics/electromagnetism/">Electromagnetism</a></li></ul></li><li><span class="tocitem">Signal Processing</span><ul><li><a class="tocitem" href="../../domains/signal/discrete_transforms/">Discrete-Time Transforms</a></li><li><a class="tocitem" href="../../domains/signal/continuous_transforms/">Continuous-Time Transforms</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Core API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Expression-Evaluation"><span>Expression Evaluation</span></a></li><li><a class="tocitem" href="#Symbolic-Variables"><span>Symbolic Variables</span></a></li><li><a class="tocitem" href="#Calculus-Operations"><span>Calculus Operations</span></a></li><li><a class="tocitem" href="#Algebraic-Operations"><span>Algebraic Operations</span></a></li><li><a class="tocitem" href="#Vector-Input-Support"><span>Vector Input Support</span></a></li><li><a class="tocitem" href="#Command-Discovery"><span>Command Discovery</span></a></li><li><a class="tocitem" href="#Command-Suggestions"><span>Command Suggestions</span></a></li><li><a class="tocitem" href="#Namespace-Management"><span>Namespace Management</span></a></li><li><a class="tocitem" href="#Substitution"><span>Substitution</span></a></li><li><a class="tocitem" href="#Type-Introspection"><span>Type Introspection</span></a></li><li><a class="tocitem" href="#Component-Access"><span>Component Access</span></a></li><li><a class="tocitem" href="#Conversion-Functions"><span>Conversion Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li><li><a class="tocitem" href="../giac_commands/">GIAC Commands</a></li><li><a class="tocitem" href="../commands_submodule/">Commands submodule</a></li><li><a class="tocitem" href="../tempapi/">TempApi</a></li></ul></li><li><a class="tocitem" href="../../tables/">Tables.jl Compatibility</a></li><li><span class="tocitem">Extensions</span><ul><li><a class="tocitem" href="../../extensions/symbolics/">Symbolics.jl</a></li></ul></li><li><span class="tocitem">Developer Guide</span><ul><li><a class="tocitem" href="../../developer/">Overview</a></li><li><a class="tocitem" href="../../developer/architecture/">Package Architecture</a></li><li><a class="tocitem" href="../../developer/tier-system/">Performance Tiers</a></li><li><a class="tocitem" href="../../developer/contributing/">Adding Functions</a></li><li><a class="tocitem" href="../../developer/memory/">Memory Management</a></li><li><a class="tocitem" href="../../developer/troubleshooting/">Troubleshooting</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Core API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/s-celles/Giac.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/s-celles/Giac.jl/blob/main/docs/src/api/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-API"><a class="docs-heading-anchor" href="#Core-API">Core API</a><a id="Core-API-1"></a><a class="docs-heading-anchor-permalink" href="#Core-API" title="Permalink"></a></h1><p>The main Giac module provides core types and functions for symbolic computation.</p><article><details class="docstring" open="true"><summary id="Giac"><a class="docstring-binding" href="#Giac"><code>Giac</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">Giac</code></pre><p>A Julia wrapper for the GIAC computer algebra system.</p><p>Provides symbolic expression evaluation, calculus operations, polynomial manipulation, and linear algebra with a Julia-native API.</p><p><strong>Core Exports</strong></p><ul><li><code>GiacExpr</code>: Symbolic expression type</li><li><code>GiacContext</code>: Evaluation context</li><li><code>GiacMatrix</code>: Symbolic matrix type</li><li><code>GiacError</code>: Exception type for GIAC errors</li><li><code>giac_eval</code>: Evaluate expression strings</li><li><code>@giac_var</code>: Create symbolic variables from Julia symbols</li><li><code>to_julia</code>: Convert GiacExpr to Julia types</li><li><code>invoke_cmd</code>: Universal command invocation (works for ALL commands)</li></ul><p><strong>Command Access</strong></p><p>GIAC commands are available through the <code>Giac.Commands</code> submodule:</p><pre><code class="language-julia hljs">using Giac

# Use invoke_cmd for any command (always available)
invoke_cmd(:factor, giac_eval(&quot;x^2-1&quot;))
invoke_cmd(:sin, giac_eval(&quot;pi/6&quot;))  # Works for conflicting commands too

# Import commands selectively (recommended)
using Giac.Commands: factor, expand, diff
factor(giac_eval(&quot;x^2-1&quot;))

# Or import all ~2000+ commands
using Giac.Commands
factor(giac_eval(&quot;x^2-1&quot;))
ifactor(giac_eval(&quot;120&quot;))</code></pre><p><strong>Quick Start</strong></p><pre><code class="language-julia hljs">using Giac

# Declare symbolic variables with @giac_var macro
@giac_var x y

# Build and manipulate expressions using Giac.Commands
using Giac.Commands: factor, expand, diff
expr = giac_eval(&quot;x^2 + 2*x*y + y^2&quot;)
result = factor(expr)   # (x+y)^2

# Or use string-based evaluation directly
result = giac_eval(&quot;factor(x^2 - 1)&quot;)
println(result)  # (x-1)*(x+1)</code></pre><p><strong>See also</strong></p><ul><li><a href="../commands_submodule/#Giac.Commands"><code>Giac.Commands</code></a>: Submodule with all exportable commands</li><li><a href="../commands_submodule/#Giac.Commands.invoke_cmd"><code>invoke_cmd</code></a>: Universal command invocation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/Giac.jl#L1-L60">source</a></section></details></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.GiacExpr"><a class="docstring-binding" href="#Giac.GiacExpr"><code>Giac.GiacExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacExpr</code></pre><p>Represents a symbolic mathematical expression from GIAC.</p><p>Wraps a pointer to a C++ giac::gen object. Memory is managed automatically via Julia&#39;s garbage collector and finalizers.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">expr = giac_eval(&quot;x^2 + 1&quot;)
println(expr)  # x^2+1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L35-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GiacContext"><a class="docstring-binding" href="#Giac.GiacContext"><code>Giac.GiacContext</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacContext</code></pre><p>Represents a GIAC evaluation context.</p><p>Manages configuration settings, variable bindings, and computation state. Thread-safe via internal locking.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ctx = GiacContext()
result = giac_eval(&quot;x + 1&quot;, ctx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L603-L616">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GiacMatrix"><a class="docstring-binding" href="#Giac.GiacMatrix"><code>Giac.GiacMatrix</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacMatrix</code></pre><p>Represents a symbolic matrix with GiacExpr elements.</p><p><strong>Fields</strong></p><ul><li><code>ptr::Ptr{Cvoid}</code>: Pointer to GIAC matrix object</li><li><code>rows::Int</code>: Number of rows</li><li><code>cols::Int</code>: Number of columns</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">A = GiacMatrix([[a, b], [c, d]])
det(A)  # a*d - b*c</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L655-L670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GiacError"><a class="docstring-binding" href="#Giac.GiacError"><code>Giac.GiacError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacError &lt;: Exception</code></pre><p>Exception type for errors from the GIAC library.</p><p><strong>Fields</strong></p><ul><li><code>msg::String</code>: Error message</li><li><code>category::Symbol</code>: Error category (<code>:parse</code>, <code>:eval</code>, <code>:type</code>, <code>:memory</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">throw(GiacError(&quot;Failed to parse expression&quot;, :parse))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L4-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.HelpResult"><a class="docstring-binding" href="#Giac.HelpResult"><code>Giac.HelpResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HelpResult</code></pre><p>A structured representation of parsed GIAC command help information.</p><p><strong>Fields</strong></p><ul><li><code>command::String</code>: The command name being documented</li><li><code>description::String</code>: Description text from GIAC help</li><li><code>related::Vector{String}</code>: List of related command names</li><li><code>examples::Vector{String}</code>: List of individual example expressions</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Use Julia&#39;s help system for interactive help:
# ?factor (after using Giac.Commands: factor)

# For programmatic access, use Giac.help (internal) or giac_help:
result = Giac.help(:factor)
result.command      # &quot;factor&quot;
result.description  # &quot;Factorizes a polynomial.&quot;
result.related      # [&quot;ifactor&quot;, &quot;partfrac&quot;, &quot;normal&quot;]
result.examples     # [&quot;factor(x^4-1)&quot;, &quot;factor(x^4-4,sqrt(2))&quot;, ...]</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.giac_help"><code>giac_help</code></a>: Get raw help string</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L32-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GiacCommand"><a class="docstring-binding" href="#Giac.GiacCommand"><code>Giac.GiacCommand</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacCommand</code></pre><p>A callable wrapper for GIAC commands.</p><p>This type stores a command name and can be called with arguments to execute the underlying GIAC command. It provides a structured way to represent commands that can be passed around and invoked.</p><p><strong>Fields</strong></p><ul><li><code>name::Symbol</code>: The GIAC command name (e.g., <code>:factor</code>, <code>:diff</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a command and call it
factor_cmd = GiacCommand(:factor)
expr = giac_eval(&quot;x^2 - 1&quot;)
result = factor_cmd(expr)  # Returns (x-1)*(x+1)

# Equivalent to:
result = giac_cmd(:factor, expr)</code></pre><p><strong>See also</strong></p><ul><li><a href="../commands_submodule/#Giac.Commands.invoke_cmd"><code>invoke_cmd</code></a>: Direct command invocation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/namespace_commands.jl#L10-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GiacInput"><a class="docstring-binding" href="#Giac.GiacInput"><code>Giac.GiacInput</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GiacInput</code></pre><p>Union type representing all valid input types for GIAC command functions.</p><p>This type alias enables generated GIAC command functions to accept native Julia types in addition to <code>GiacExpr</code>, providing a more ergonomic API.</p><p><strong>Supported Types</strong></p><ul><li><code>GiacExpr</code>: Native GIAC expressions</li><li><code>Number</code>: All Julia numeric types (Integer, AbstractFloat, Rational, Complex, etc.)</li><li><code>String</code>: String representations of GIAC expressions</li><li><code>Symbol</code>: Variable names (e.g., <code>:x</code>, <code>:y</code>)</li><li><code>AbstractVector</code>: Julia vectors/arrays (converted to GIAC list syntax)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Giac
using Giac.Commands

# All of these work:
ifactor(1000)           # Integer
ifactor(giac_eval(&quot;1000&quot;))  # GiacExpr
simplify(&quot;x^2 - 1&quot;)     # String

# Vectors work directly (032-vector-input-solve):
@giac x y
solve([x+y~0, x-y~2], [x,y])  # System of equations
det([[1,2],[3,4]])            # Nested vectors for matrices</code></pre><p><strong>See also</strong></p><ul><li><a href="../../developer/architecture/#GiacExpr"><code>GiacExpr</code></a>: The primary GIAC expression type</li><li><a href="../commands_submodule/#Giac.Commands.invoke_cmd"><code>invoke_cmd</code></a>: Universal command invocation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L94-L128">source</a></section></details></article><h2 id="Expression-Evaluation"><a class="docs-heading-anchor" href="#Expression-Evaluation">Expression Evaluation</a><a id="Expression-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Evaluation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.giac_eval"><a class="docstring-binding" href="#Giac.giac_eval"><code>Giac.giac_eval</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">giac_eval(expr::String, ctx::GiacContext=DEFAULT_CONTEXT[])</code></pre><p>Evaluate a GIAC expression string and return a GiacExpr.</p><p><strong>Arguments</strong></p><ul><li><code>expr::String</code>: A string containing a valid GIAC expression</li><li><code>ctx::GiacContext</code>: Optional evaluation context (uses DEFAULT_CONTEXT if not provided)</li></ul><p><strong>Returns</strong></p><ul><li><code>GiacExpr</code>: The evaluated expression</li></ul><p><strong>Throws</strong></p><ul><li><code>GiacError(:parse)</code>: If the expression cannot be parsed</li><li><code>GiacError(:eval)</code>: If evaluation fails</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = giac_eval(&quot;2 + 3&quot;)
println(result)  # 5

# Symbolic computation
expr = giac_eval(&quot;diff(x^2, x)&quot;)
println(expr)  # 2*x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/api.jl#L4-L29">source</a></section><section><div><pre><code class="language-julia hljs">giac_eval(expr::GiacExpr, ctx::GiacContext=DEFAULT_CONTEXT[])</code></pre><p>Re-evaluate an existing GiacExpr in a context (useful after variable assignments).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/api.jl#L44-L48">source</a></section></details></article><h2 id="Symbolic-Variables"><a class="docs-heading-anchor" href="#Symbolic-Variables">Symbolic Variables</a><a id="Symbolic-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Variables" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.@giac_var"><a class="docstring-binding" href="#Giac.@giac_var"><code>Giac.@giac_var</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@giac_var sym...
@giac_var func(args...)</code></pre><p>Create symbolic variables or function expressions from Julia symbols.</p><p>Creates <code>GiacExpr</code> variables in the calling scope by internally calling <code>giac_eval</code> with the stringified expression. This provides a cleaner syntax for variable declaration similar to <code>@variables</code> in Symbolics.jl.</p><p><strong>Arguments</strong></p><ul><li><code>sym...</code>: Symbol names to create as simple variables</li><li><code>func(args...)</code>: Function syntax to create function expressions</li></ul><p><strong>Examples</strong></p><p>Single variable:</p><pre><code class="language-julia hljs">@giac_var x           # Creates x as a GiacExpr
string(x)             # &quot;x&quot;
x isa GiacExpr        # true</code></pre><p>Multiple variables:</p><pre><code class="language-julia hljs">@giac_var x y z       # Creates x, y, z as GiacExpr variables</code></pre><p>Single-variable function (NEW):</p><pre><code class="language-julia hljs">@giac_var u(t)        # Creates u as GiacExpr representing &quot;u(t)&quot;
string(u)             # &quot;u(t)&quot;

# Use with differentiation
@giac_var t
diff(u, t)            # Returns diff(u(t),t)</code></pre><p>Multi-variable function (NEW):</p><pre><code class="language-julia hljs">@giac_var f(x, y)     # Creates f as GiacExpr representing &quot;f(x,y)&quot;
string(f)             # &quot;f(x,y)&quot;</code></pre><p>Mixed declarations (NEW):</p><pre><code class="language-julia hljs">@giac_var t x y u(t) f(x, y)
# Creates: t, x, y as simple variables
#          u as &quot;u(t)&quot;, f as &quot;f(x,y)&quot;</code></pre><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using Giac

@giac_var x y
expr = giac_eval(&quot;x^2 + y^2&quot;)
result = giac_diff(expr, x)  # 2*x

# For ODEs
@giac_var t u(t)
# u&#39;&#39;(t) + u(t) = 0

# Callable syntax for initial conditions (034-callable-giacexpr)
@giac_var t u(t) tau U0
u(0)                    # Returns GiacExpr: &quot;u(0)&quot;
u(0) ~ 1                # Initial condition: u(0) = 1
diff(u, t)(0) ~ 0       # Derivative condition: u&#39;(0) = 0
desolve([tau * diff(u, t) + u ~ U0, u(0) ~ 1], u)</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.giac_eval"><code>giac_eval</code></a>: For evaluating string expressions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/macros.jl#L155-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.@giac_several_vars"><a class="docstring-binding" href="#Giac.@giac_several_vars"><code>Giac.@giac_several_vars</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@giac_several_vars base dims...</code></pre><p>Create multiple indexed symbolic variables for N-dimensional tensors.</p><p>This macro generates multiple <code>GiacExpr</code> variables in the calling scope with names formed from a base name and indices. It supports any number of dimensions and returns a tuple of all created variables.</p><p><strong>Arguments</strong></p><ul><li><code>base</code>: Symbol - The base name for variables (e.g., <code>a</code>, <code>coeff</code>, <code>α</code>)</li><li><code>dims...</code>: Integer literals or range expressions - Dimensions of the tensor (1 or more)<ul><li>Integer <code>n</code>: Creates indices 1:n (backward compatible)</li><li>UnitRange <code>a:b</code>: Creates indices from a to b</li><li>StepRange <code>a:s:b</code>: Creates indices from a to b with step s</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{GiacExpr...}</code>: A tuple containing all created variables in lexicographic order</li></ul><p><strong>Naming Convention</strong></p><ul><li>If all indices are in 0-9: indices are concatenated directly (e.g., <code>a123</code>)</li><li>If any index &gt; 9: underscore separators are used (e.g., <code>a_1_10</code>)</li><li>Negative indices: <code>m</code> prefix for minus (e.g., -1 → <code>m1</code>, so <code>c_m1</code>)</li></ul><p><strong>Examples</strong></p><p>1D vector:</p><pre><code class="language-julia hljs">@giac_several_vars a 3
# Creates: a1, a2, a3 and returns (a1, a2, a3)
a1 + a2 + a3  # Symbolic sum

# Capture return value
vars = @giac_several_vars c 4
length(vars)  # 4</code></pre><p>2D matrix:</p><pre><code class="language-julia hljs">result = @giac_several_vars m 2 3
# Creates: m11, m12, m13, m21, m22, m23
# Returns: (m11, m12, m13, m21, m22, m23)
length(result)  # 6</code></pre><p>3D tensor:</p><pre><code class="language-julia hljs">@giac_several_vars t 2 2 2
# Creates: t111, t112, t121, t122, t211, t212, t221, t222
# Returns tuple of 8 variables</code></pre><p>Large dimensions (separator used):</p><pre><code class="language-julia hljs">@giac_several_vars b 2 10 3
# Creates: b_1_1_1, b_1_1_2, ..., b_2_10_3</code></pre><p>Unicode base names:</p><pre><code class="language-julia hljs">@giac_several_vars α 2
# Creates: α1, α2</code></pre><p>0-based indexing with UnitRange:</p><pre><code class="language-julia hljs">@giac_several_vars psi 0:2
# Creates: psi0, psi1, psi2 and returns (psi0, psi1, psi2)</code></pre><p>2D with custom ranges:</p><pre><code class="language-julia hljs">@giac_several_vars T 0:1 0:2
# Creates: T00, T01, T02, T10, T11, T12</code></pre><p>Negative indices:</p><pre><code class="language-julia hljs">@giac_several_vars c -1:1
# Creates: c_m1, c_0, c_1 (m = minus, to avoid GIAC parsing issues)</code></pre><p>StepRange:</p><pre><code class="language-julia hljs">@giac_several_vars q 0:2:4
# Creates: q0, q2, q4</code></pre><p>Mixed arguments (integer and range):</p><pre><code class="language-julia hljs">@giac_several_vars mixed 2 0:1
# First dim: 1:2, second dim: 0:1
# Creates: mixed10, mixed11, mixed20, mixed21</code></pre><p>Edge cases:</p><pre><code class="language-julia hljs">@giac_several_vars x 0     # Returns empty tuple ()
@giac_several_vars y 1     # Creates y1, returns (y1,)
@giac_several_vars z 2 0   # Returns empty tuple (0 in any dim)
@giac_several_vars e 5:4   # Returns empty tuple (empty range)</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.@giac_var"><code>@giac_var</code></a>: For creating single symbolic variables</li><li><a href="#Giac.giac_eval"><code>giac_eval</code></a>: For evaluating string expressions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/macros.jl#L249-L355">source</a></section></details></article><h3 id="Function-Syntax-for-@giac_var"><a class="docs-heading-anchor" href="#Function-Syntax-for-@giac_var">Function Syntax for @giac_var</a><a id="Function-Syntax-for-@giac_var-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Syntax-for-@giac_var" title="Permalink"></a></h3><p>The <code>@giac_var</code> macro supports function notation for defining symbolic functions that depend on other variables. This is useful for differential equations and calculus with unknown functions.</p><p><strong>Single-variable functions:</strong></p><pre><code class="language-julia hljs">@giac_var u(t)        # u is a GiacExpr representing &quot;u(t)&quot;
@giac_var t           # t is the independent variable
diff(u, t)            # Symbolic derivative of u with respect to t</code></pre><p><strong>Multi-variable functions:</strong></p><pre><code class="language-julia hljs">@giac_var f(x, y)     # f represents &quot;f(x,y)&quot;
@giac_var x y
diff(f, x)            # Partial derivative ∂f/∂x
diff(f, y)            # Partial derivative ∂f/∂y</code></pre><p><strong>Mixed declarations:</strong></p><pre><code class="language-julia hljs">@giac_var t x y u(t) f(x, y)
# Creates: t, x, y as simple variables
#          u as &quot;u(t)&quot;, f as &quot;f(x,y)&quot;</code></pre><p><strong>Common use case - ODEs:</strong></p><pre><code class="language-julia hljs">@giac_var t u(t)
# Express ODE: u&#39;&#39;(t) + u(t) = 0</code></pre><p><strong>Common use case - PDEs:</strong></p><pre><code class="language-julia hljs">@giac_var x y u(x, y)
# Laplacian: ∂²u/∂x² + ∂²u/∂y²
laplacian = diff(diff(u, x), x) + diff(diff(u, y), y)</code></pre><h3 id="Callable-GiacExpr-(Function-Evaluation)"><a class="docs-heading-anchor" href="#Callable-GiacExpr-(Function-Evaluation)">Callable GiacExpr (Function Evaluation)</a><a id="Callable-GiacExpr-(Function-Evaluation)-1"></a><a class="docs-heading-anchor-permalink" href="#Callable-GiacExpr-(Function-Evaluation)" title="Permalink"></a></h3><p>GiacExpr objects are callable, allowing natural function evaluation syntax like <code>u(0)</code>. This is essential for specifying ODE initial conditions.</p><p><strong>Basic function evaluation:</strong></p><pre><code class="language-julia hljs">@giac_var u(t)
u(0)           # Returns GiacExpr: &quot;u(0)&quot;
u(1)           # Returns GiacExpr: &quot;u(1)&quot;</code></pre><p><strong>ODE initial conditions:</strong></p><pre><code class="language-julia hljs">using Giac.Commands: diff, desolve
@giac_var t u(t) tau U0

# ODE: τu&#39; + u = U₀ with u(0) = 1
ode = tau * diff(u, t) + u ~ U0
initial = u(0) ~ 1
desolve([ode, initial], u)</code></pre><p><strong>Derivative initial conditions (using D operator):</strong></p><pre><code class="language-julia hljs">using Giac.Commands: desolve
@giac_var t u(t)

# First derivative at t=0: u&#39;(0) = 1
D(u)(0) ~ 1

# Second derivative at t=0: u&#39;&#39;(0) = 0
D(u, 2)(0) ~ 0

# Full example: solve u&#39;&#39; + u = 0 with u(0)=1, u&#39;(0)=0
ode = D(D(u)) + u ~ 0
u0 = u(0) ~ 1
du0 = D(u)(0) ~ 0
desolve([ode, u0, du0], t, :u)  # Returns: cos(t)</code></pre><h3 id="D-Operator-(Derivative-Operator)"><a class="docs-heading-anchor" href="#D-Operator-(Derivative-Operator)">D Operator (Derivative Operator)</a><a id="D-Operator-(Derivative-Operator)-1"></a><a class="docs-heading-anchor-permalink" href="#D-Operator-(Derivative-Operator)" title="Permalink"></a></h3><p>The <code>D</code> operator follows SciML/ModelingToolkit conventions for expressing derivatives:</p><pre><code class="language-julia hljs">@giac_var t u(t)

# Create derivative expressions
D(u)        # First derivative u&#39;
D(D(u))     # Second derivative u&#39;&#39; (chained)
D(u, 2)     # Second derivative u&#39;&#39; (direct)
D(u, 3)     # Third derivative u&#39;&#39;&#39;

# Use in ODE equations
ode = D(D(u)) + u ~ 0    # u&#39;&#39; + u = 0

# Use in initial conditions (produces prime notation for GIAC)
D(u)(0) ~ 1              # u&#39;(0) = 1
D(u, 2)(0) ~ 0           # u&#39;&#39;(0) = 0</code></pre><p><strong>Complete ODE examples:</strong></p><pre><code class="language-julia hljs">using Giac
using Giac.Commands: desolve

# 2nd order: u&#39;&#39; + u = 0, u(0)=1, u&#39;(0)=0
@giac_var t u(t)
result = desolve([D(D(u)) + u ~ 0, u(0) ~ 1, D(u)(0) ~ 0], t, :u)
# Returns: cos(t)

# 3rd order: y&#39;&#39;&#39; - y = 0, y(0)=1, y&#39;(0)=1, y&#39;&#39;(0)=1
@giac_var t y(t)
result = desolve([D(y,3) - y ~ 0, y(0) ~ 1, D(y)(0) ~ 1, D(y,2)(0) ~ 1], t, :y)
# Returns: exp(t)</code></pre><div class="admonition is-info" id="desolve-function-argument-70a1e630ef1e66af"><header class="admonition-header">desolve function argument<a class="admonition-anchor" href="#desolve-function-argument-70a1e630ef1e66af" title="Permalink"></a></header><div class="admonition-body"><p>When calling <code>desolve</code>, pass the function name as a Symbol (<code>:u</code>, <code>:y</code>) rather than the function expression (<code>u</code>, <code>y</code>), since GIAC expects just the name, not <code>u(t)</code>.</p></div></div><p><strong>Multi-variable function evaluation:</strong></p><pre><code class="language-julia hljs">@giac_var f(x, y) a b
f(0, 0)        # Returns &quot;f(0,0)&quot;
f(a, b)        # Returns &quot;f(a,b)&quot;
f(1, 2)        # Returns &quot;f(1,2)&quot;</code></pre><h2 id="Calculus-Operations"><a class="docs-heading-anchor" href="#Calculus-Operations">Calculus Operations</a><a id="Calculus-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Calculus-Operations" title="Permalink"></a></h2><p>Calculus functions are available via <code>Giac.Commands</code> or <code>invoke_cmd</code>:</p><pre><code class="language-julia hljs">using Giac
using Giac.Commands: diff, integrate, limit, series

# Or use invoke_cmd
invoke_cmd(:diff, expr, x)
invoke_cmd(:integrate, expr, x)
invoke_cmd(:limit, expr, x, point)
invoke_cmd(:series, expr, x, point, order)</code></pre><h2 id="Algebraic-Operations"><a class="docs-heading-anchor" href="#Algebraic-Operations">Algebraic Operations</a><a id="Algebraic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-Operations" title="Permalink"></a></h2><p>Algebra functions are available via <code>Giac.Commands</code> or <code>invoke_cmd</code>:</p><pre><code class="language-julia hljs">using Giac
using Giac.Commands: factor, expand, simplify, solve, gcd

# Or use invoke_cmd
invoke_cmd(:factor, expr)
invoke_cmd(:expand, expr)
invoke_cmd(:simplify, expr)
invoke_cmd(:solve, expr, x)
invoke_cmd(:gcd, a, b)</code></pre><h2 id="Vector-Input-Support"><a class="docs-heading-anchor" href="#Vector-Input-Support">Vector Input Support</a><a id="Vector-Input-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Input-Support" title="Permalink"></a></h2><p>GIAC commands accept Julia vectors directly, enabling natural syntax for systems of equations and matrix operations:</p><pre><code class="language-julia hljs">using Giac
using Giac.Commands: solve, det_minor, inverse
@giac_var x y z

# Solve systems of equations with vector syntax
solve([x + y ~ 1, x - y ~ 0], [x, y])  # Returns [[1/2, 1/2]]

# Three-variable system
solve([x + y + z ~ 6, x - y ~ 0, y + z ~ 4], [x, y, z])

# Matrix operations with nested vectors
det_minor([[1, 2], [3, 4]])  # Returns -2
inverse([[1, 2], [3, 4]])    # Returns inverse matrix</code></pre><p>See <a href="#Giac.GiacInput"><code>GiacInput</code></a> for the full list of supported input types.</p><h2 id="Command-Discovery"><a class="docs-heading-anchor" href="#Command-Discovery">Command Discovery</a><a id="Command-Discovery-1"></a><a class="docs-heading-anchor-permalink" href="#Command-Discovery" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.list_commands"><a class="docstring-binding" href="#Giac.list_commands"><code>Giac.list_commands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_commands()</code></pre><p>Return a vector of all available GIAC command names.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">cmds = list_commands()
println(&quot;Number of commands: &quot;, length(cmds))
println(&quot;First 10: &quot;, cmds[1:10])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/Giac.jl#L200-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.help_count"><a class="docstring-binding" href="#Giac.help_count"><code>Giac.help_count</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">help_count()</code></pre><p>Return the number of commands in the GIAC help database.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/Giac.jl#L220-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.search_commands"><a class="docstring-binding" href="#Giac.search_commands"><code>Giac.search_commands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">search_commands(pattern::String) -&gt; Vector{Symbol}</code></pre><p>Search for commands matching a string prefix.</p><p><strong>Arguments</strong></p><ul><li><code>pattern::String</code>: Prefix to match</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: List of matching command names (as Symbols), sorted alphabetically</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">search_commands(&quot;sin&quot;)  # Returns [:sin, :sinc, :sincos, :sinh, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L596-L611">source</a></section><section><div><pre><code class="language-julia hljs">search_commands(pattern::Regex) -&gt; Vector{Symbol}</code></pre><p>Search for commands matching a regular expression.</p><p><strong>Arguments</strong></p><ul><li><code>pattern::Regex</code>: Regular expression to match</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: List of matching command names (as Symbols), sorted alphabetically</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">search_commands(r&quot;^a.*n$&quot;)  # Returns commands starting with &#39;a&#39; and ending with &#39;n&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L622-L637">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.commands_in_category"><a class="docstring-binding" href="#Giac.commands_in_category"><code>Giac.commands_in_category</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">commands_in_category(category::Symbol) -&gt; Vector{Symbol}</code></pre><p>Get all commands in a specific category.</p><p><strong>Arguments</strong></p><ul><li><code>category::Symbol</code>: Category name (e.g., <code>:trigonometry</code>, <code>:algebra</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: List of command names (as Symbols) in the category, sorted alphabetically</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the category does not exist</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">trig = commands_in_category(:trigonometry)
# [:acos, :asin, :atan, :cos, :sin, :tan, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L666-L685">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.command_info"><a class="docstring-binding" href="#Giac.command_info"><code>Giac.command_info</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">command_info(cmd::Symbol) -&gt; Union{CommandInfo, Nothing}</code></pre><p>Get metadata about a specific command.</p><p><strong>Arguments</strong></p><ul><li><code>cmd::Symbol</code>: Command name</li></ul><p><strong>Returns</strong></p><ul><li><code>CommandInfo</code>: Metadata about the command</li><li><code>nothing</code>: If the command is not found</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">info = command_info(:factor)
if info !== nothing
    println(info.name)      # &quot;factor&quot;
    println(info.category)  # :algebra
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L694-L714">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.list_categories"><a class="docstring-binding" href="#Giac.list_categories"><code>Giac.list_categories</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_categories() -&gt; Vector{Symbol}</code></pre><p>List all available command categories.</p><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: Category names, sorted alphabetically</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">cats = list_categories()
# [:algebra, :calculus, :combinatorics, :geometry, ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L648-L661">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.giac_help"><a class="docstring-binding" href="#Giac.giac_help"><code>Giac.giac_help</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">giac_help(cmd::Union{Symbol, String}) -&gt; String</code></pre><p>Get GIAC help text for a command.</p><p><strong>Arguments</strong></p><ul><li><code>cmd</code>: Command name as Symbol or String</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Help text from GIAC, or empty string if not found</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">help = giac_help(:factor)
println(help)  # &quot;factor(Expr) - Factor a polynomial...&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L729-L745">source</a></section></details></article><div class="admonition is-info" id="Getting-Help-for-Commands-f9d16c24130b8934"><header class="admonition-header">Getting Help for Commands<a class="admonition-anchor" href="#Getting-Help-for-Commands-f9d16c24130b8934" title="Permalink"></a></header><div class="admonition-body"><p>Use Julia&#39;s native help system after importing commands:</p><pre><code class="language-julia hljs">using Giac.Commands: factor
?factor  # Shows GIAC documentation</code></pre></div></div><h2 id="Command-Suggestions"><a class="docs-heading-anchor" href="#Command-Suggestions">Command Suggestions</a><a id="Command-Suggestions-1"></a><a class="docs-heading-anchor-permalink" href="#Command-Suggestions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.suggest_commands"><a class="docstring-binding" href="#Giac.suggest_commands"><code>Giac.suggest_commands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">suggest_commands(input::Union{Symbol, String}; n::Int=get_suggestion_count()) -&gt; Vector{Symbol}</code></pre><p>Find commands similar to the given input using edit distance.</p><p>This function helps users recover from typos by suggesting valid GIAC commands that are similar to the input.</p><p><strong>Arguments</strong></p><ul><li><code>input</code>: The mistyped command name (Symbol or String)</li><li><code>n</code>: Maximum number of suggestions to return (default: <code>get_suggestion_count()</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: Similar command names, sorted by edit distance (ascending), then alphabetically. Returns empty vector if no similar commands found.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">suggest_commands(:factr)
# [:factor, :cfactor, :ifactor, ...]

suggest_commands(&quot;integrat&quot;, n=2)
# [:integrate, ...]

suggest_commands(:factor)  # Exact match
# []  (empty, no suggestions needed)</code></pre><p><strong>See also</strong></p><ul><li><code>suggest_commands_with_distances</code>: Also returns edit distances (internal function)</li><li><a href="#Giac.set_suggestion_count"><code>set_suggestion_count</code></a>: Configure default suggestion count</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L1034-L1065">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.set_suggestion_count"><a class="docstring-binding" href="#Giac.set_suggestion_count"><code>Giac.set_suggestion_count</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_suggestion_count(n::Int) -&gt; Nothing</code></pre><p>Set the default number of command suggestions.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: Number of suggestions (must be &gt; 0, otherwise resets to default 4)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">set_suggestion_count(6)
get_suggestion_count()  # 6

set_suggestion_count(-1)  # Invalid, resets to default
get_suggestion_count()  # 4</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.get_suggestion_count"><code>get_suggestion_count</code></a>: Get the current count</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L953-L972">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.get_suggestion_count"><a class="docstring-binding" href="#Giac.get_suggestion_count"><code>Giac.get_suggestion_count</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_suggestion_count() -&gt; Int</code></pre><p>Get the current default number of command suggestions.</p><p><strong>Returns</strong></p><ul><li><code>Int</code>: Current suggestion count (default: 4)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">get_suggestion_count()  # 4 (default)</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.set_suggestion_count"><code>set_suggestion_count</code></a>: Set the suggestion count</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L933-L948">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.search_commands_by_description"><a class="docstring-binding" href="#Giac.search_commands_by_description"><code>Giac.search_commands_by_description</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">search_commands_by_description(query; n=20) -&gt; Vector{Symbol}</code></pre><p>Search for GIAC commands whose help text contains the given keyword.</p><p>Unlike <code>search_commands</code> which matches command names, this function searches the description and example text of each command&#39;s help documentation.</p><p><strong>Arguments</strong></p><ul><li><code>query::Union{String, Symbol}</code>: Search term to find in help text</li><li><code>n::Int=20</code>: Maximum number of results to return</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: Matching command names (as Symbols), sorted by relevance</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find commands related to factorization
search_commands_by_description(&quot;factor&quot;)
# Returns: [:factor, :ifactor, :cfactor, ...]

# Search for matrix operations
search_commands_by_description(&quot;matrix&quot;, n=10)</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.search_commands"><code>search_commands</code></a>: Search by command name pattern</li><li><a href="#Giac.giac_help"><code>giac_help</code></a>: Get raw help for a specific command</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L1124-L1152">source</a></section></details></article><h2 id="Namespace-Management"><a class="docs-heading-anchor" href="#Namespace-Management">Namespace Management</a><a id="Namespace-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Namespace-Management" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.JULIA_CONFLICTS"><a class="docstring-binding" href="#Giac.JULIA_CONFLICTS"><code>Giac.JULIA_CONFLICTS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">JULIA_CONFLICTS</code></pre><p>Set of GIAC command names (as Symbols) that conflict with Julia keywords, builtins, or standard library functions. These commands cannot be safely exported as top-level functions but remain accessible via <code>invoke_cmd(:name, args...)</code>.</p><p><strong>Conflict Categories</strong></p><ul><li><strong>Julia keywords</strong>: <code>if</code>, <code>for</code>, <code>while</code>, <code>end</code>, <code>in</code>, <code>or</code>, <code>and</code>, etc.</li><li><strong>Base builtins</strong>: <code>eval</code>, <code>float</code>, <code>sum</code>, <code>prod</code>, <code>div</code>, <code>mod</code>, <code>abs</code>, etc.</li><li><strong>Base math functions</strong>: <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>exp</code>, <code>log</code>, <code>sqrt</code>, etc.</li><li><strong>LinearAlgebra</strong>: <code>det</code>, <code>inv</code>, <code>trace</code>, <code>rank</code>, <code>transpose</code>, etc.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">:eval in JULIA_CONFLICTS  # true
:factor in JULIA_CONFLICTS  # false

# Conflicting commands still work via invoke_cmd
invoke_cmd(:eval, giac_eval(&quot;2+3&quot;))  # Returns 5</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.exportable_commands"><code>exportable_commands</code></a>: Commands safe to export</li><li><a href="#Giac.conflict_reason"><code>conflict_reason</code></a>: Get the conflict category for a command</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L296-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.exportable_commands"><a class="docstring-binding" href="#Giac.exportable_commands"><code>Giac.exportable_commands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">exportable_commands() -&gt; Vector{Symbol}</code></pre><p>Get a list of GIAC commands that can be safely exported without conflicting with Julia keywords, builtins, or standard library functions.</p><p>This function filters the complete command list to include only commands that:</p><ol><li>Start with an ASCII letter (a-z, A-Z)</li><li>Do not conflict with Julia (not in <code>JULIA_CONFLICTS</code>)</li></ol><p><strong>Returns</strong></p><ul><li><code>Vector{Symbol}</code>: Sorted list of exportable command names (as Symbols)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">cmds = exportable_commands()
length(cmds)        # ~2000+
:factor in cmds     # true
:eval in cmds       # false (conflicts with Julia)
:sin in cmds        # false (conflicts with Base.sin)
issorted(cmds, by=string)  # true</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.available_commands"><code>available_commands</code></a>: All commands starting with ASCII letters</li><li><a href="#Giac.JULIA_CONFLICTS"><code>JULIA_CONFLICTS</code></a>: Commands that conflict with Julia</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L1283-L1309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_valid_command"><a class="docstring-binding" href="#Giac.is_valid_command"><code>Giac.is_valid_command</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_valid_command(name::Union{Symbol, String}) -&gt; Bool</code></pre><p>Check if a command name is a valid GIAC command.</p><p><strong>Arguments</strong></p><ul><li><code>name</code>: Command name as Symbol or String</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the command exists in GIAC&#39;s command list</li><li><code>false</code> otherwise</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_valid_command(:factor)      # true
is_valid_command(&quot;integrate&quot;)  # true
is_valid_command(:notacommand) # false</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.list_commands"><code>list_commands</code></a>: Get all command names</li><li><a href="#Giac.suggest_commands"><code>suggest_commands</code></a>: Get suggestions for misspelled commands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L1255-L1277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.conflict_reason"><a class="docstring-binding" href="#Giac.conflict_reason"><code>Giac.conflict_reason</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">conflict_reason(cmd::Union{Symbol, String}) -&gt; Union{Symbol, Nothing}</code></pre><p>Get the reason why a GIAC command conflicts with Julia.</p><p><strong>Arguments</strong></p><ul><li><code>cmd</code>: Command name as Symbol or String</li></ul><p><strong>Returns</strong></p><ul><li><code>:keyword</code> - Conflicts with Julia keyword (if, for, while, etc.)</li><li><code>:builtin</code> - Conflicts with Julia builtin function (eval, float, etc.)</li><li><code>:base_math</code> - Conflicts with Base math function (sin, cos, exp, etc.)</li><li><code>:linear_algebra</code> - Conflicts with LinearAlgebra (det, inv, trace, etc.)</li><li><code>:statistics</code> - Conflicts with Statistics (mean, median, var, etc.)</li><li><code>nothing</code> - No conflict</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">conflict_reason(:eval)    # :builtin
conflict_reason(:sin)     # :base_math
conflict_reason(:det)     # :linear_algebra
conflict_reason(:for)     # :keyword
conflict_reason(:factor)  # nothing</code></pre><p><strong>See also</strong></p><ul><li><a href="#Giac.JULIA_CONFLICTS"><code>JULIA_CONFLICTS</code></a>: Set of all conflicting commands</li><li><a href="#Giac.exportable_commands"><code>exportable_commands</code></a>: Commands safe to export</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L1336-L1364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.available_commands"><a class="docstring-binding" href="#Giac.available_commands"><code>Giac.available_commands</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">available_commands()</code></pre><p>Return a sorted vector of all available GIAC command names that start with an ASCII letter (a-z, A-Z).</p><p>This function provides programmatic discovery of available commands. It filters out operators, keywords, and commands starting with non-ASCII characters.</p><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: Sorted list of command names starting with ASCII letters</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># List all available commands
cmds = available_commands()
println(&quot;Found $(length(cmds)) commands&quot;)  # ~2100+

# Check if a command exists
&quot;factor&quot; in cmds  # true
&quot;+&quot; in cmds       # false (operator)

# Compare with exportable commands
exportable = exportable_commands()
length(exportable)  # ~2000+ (excludes Julia conflicts)</code></pre><p><strong>Accessing Commands</strong></p><ol><li><p><strong>invoke_cmd</strong> (all commands): Universal access, always available</p><pre><code class="language-julia hljs">invoke_cmd(:eval, expr)  # Works for conflicting commands too
invoke_cmd(:factor, expr)</code></pre></li><li><p><strong>Selective import</strong>: Import specific commands from Giac.Commands</p><pre><code class="language-julia hljs">using Giac.Commands: factor, expand
factor(expr)  # Works directly</code></pre></li><li><p><strong>Full import</strong>: Import all ~2000+ commands</p><pre><code class="language-julia hljs">using Giac.Commands
factor(expr)   # Works directly
ifactor(expr)  # All commands available</code></pre></li></ol><p><strong>See also</strong></p><ul><li><a href="#Giac.exportable_commands"><code>exportable_commands</code></a>: Commands safe to export (no Julia conflicts)</li><li><a href="../commands_submodule/#Giac.Commands.invoke_cmd"><code>invoke_cmd</code></a>: Universal command invocation</li><li><a href="../commands_submodule/#Giac.Commands"><code>Giac.Commands</code></a>: Submodule with all exportable commands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/namespace_commands.jl#L98-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.reset_conflict_warnings!"><a class="docstring-binding" href="#Giac.reset_conflict_warnings!"><code>Giac.reset_conflict_warnings!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reset_conflict_warnings!()</code></pre><p>Reset the conflict warning tracker, allowing warnings to be shown again.</p><p>This is primarily useful for testing.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">giac_cmd(:eval, expr)  # Shows warning
giac_cmd(:eval, expr)  # No warning (already shown)
reset_conflict_warnings!()
giac_cmd(:eval, expr)  # Shows warning again</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/command_registry.jl#L546-L560">source</a></section></details></article><h2 id="Substitution"><a class="docs-heading-anchor" href="#Substitution">Substitution</a><a id="Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution" title="Permalink"></a></h2><p>See <a href="../../substitute/">Variable Substitution</a> for the <code>substitute</code> function documentation.</p><h2 id="Type-Introspection"><a class="docs-heading-anchor" href="#Type-Introspection">Type Introspection</a><a id="Type-Introspection-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Introspection" title="Permalink"></a></h2><p>Functions for querying the type of GIAC expressions:</p><article><details class="docstring" open="true"><summary id="Giac.giac_type"><a class="docstring-binding" href="#Giac.giac_type"><code>Giac.giac_type</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">giac_type(g::GiacExpr) -&gt; T</code></pre><p>Return the GIAC type enum value for the expression.</p><p>Returns one of the <code>T</code> enum values from <code>Giac.GenTypes</code>: <code>INT</code>, <code>DOUBLE</code>, <code>ZINT</code>, <code>REAL</code>, <code>CPLX</code>, <code>VECT</code>, <code>SYMB</code>, <code>IDNT</code>, <code>STRNG</code>, <code>FRAC</code>, <code>FUNC</code>, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Giac.GenTypes: T, INT, VECT

g = giac_eval(&quot;42&quot;)
giac_type(g) == INT  # true

g = giac_eval(&quot;[1, 2, 3]&quot;)
giac_type(g) == VECT  # true</code></pre><p>See also: <code>Giac.GenTypes</code> module for type enum values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L27-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.subtype"><a class="docstring-binding" href="#Giac.subtype"><code>Giac.subtype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">subtype(g::GiacExpr) -&gt; Int32</code></pre><p>Return the subtype for vector expressions.</p><p>For vectors, returns <code>1</code> (sequence), <code>2</code> (set), <code>3</code> (list), or <code>0</code> for standard vectors.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = giac_eval(&quot;{1, 2, 3}&quot;)  # set
subtype(g) == 2  # true (set subtype)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L70-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_integer"><a class="docstring-binding" href="#Giac.is_integer"><code>Giac.is_integer</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_integer(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is an integer (<code>INT</code> or <code>ZINT</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_integer(giac_eval(&quot;42&quot;))      # true
is_integer(giac_eval(&quot;3.14&quot;))    # false
is_integer(giac_eval(&quot;x&quot;))       # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L138-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_numeric"><a class="docstring-binding" href="#Giac.is_numeric"><code>Giac.is_numeric</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_numeric(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is a numeric value (<code>INT</code>, <code>DOUBLE</code>, <code>ZINT</code>, or <code>REAL</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_numeric(giac_eval(&quot;42&quot;))      # true
is_numeric(giac_eval(&quot;3.14&quot;))    # true
is_numeric(giac_eval(&quot;x&quot;))       # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L155-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_vector"><a class="docstring-binding" href="#Giac.is_vector"><code>Giac.is_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_vector(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is a vector/list/sequence (<code>VECT</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_vector(giac_eval(&quot;[1, 2, 3]&quot;))  # true
is_vector(giac_eval(&quot;42&quot;))         # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L173-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_symbolic"><a class="docstring-binding" href="#Giac.is_symbolic"><code>Giac.is_symbolic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_symbolic(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is symbolic (<code>SYMB</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_symbolic(giac_eval(&quot;sin(x)&quot;))  # true
is_symbolic(giac_eval(&quot;x + 1&quot;))   # true
is_symbolic(giac_eval(&quot;42&quot;))      # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L188-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_identifier"><a class="docstring-binding" href="#Giac.is_identifier"><code>Giac.is_identifier</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_identifier(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is an identifier/variable (<code>IDNT</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_identifier(giac_eval(&quot;x&quot;))       # true
is_identifier(giac_eval(&quot;x + 1&quot;))   # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L204-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_fraction"><a class="docstring-binding" href="#Giac.is_fraction"><code>Giac.is_fraction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_fraction(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is a rational fraction (<code>FRAC</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_fraction(giac_eval(&quot;3/4&quot;))    # true
is_fraction(giac_eval(&quot;42&quot;))     # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L219-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_complex"><a class="docstring-binding" href="#Giac.is_complex"><code>Giac.is_complex</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_complex(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is a complex number (<code>CPLX</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_complex(giac_eval(&quot;3+4*i&quot;))   # true
is_complex(giac_eval(&quot;42&quot;))      # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L234-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_string"><a class="docstring-binding" href="#Giac.is_string"><code>Giac.is_string</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_string(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression is a string (<code>STRNG</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_string(giac_eval(&quot;&quot;hello&quot;&quot;))  # true
is_string(giac_eval(&quot;42&quot;))         # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L249-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.is_boolean"><a class="docstring-binding" href="#Giac.is_boolean"><code>Giac.is_boolean</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_boolean(g::GiacExpr) -&gt; Bool</code></pre><p>Return <code>true</code> if the expression represents a boolean value (<code>true</code> or <code>false</code>).</p><p>Note: GIAC represents booleans as integers internally (type <code>INT</code>), but displays them as &quot;true&quot; or &quot;false&quot;. This function detects boolean values by checking the string representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">is_boolean(giac_eval(&quot;true&quot;))      # true
is_boolean(giac_eval(&quot;false&quot;))     # true
is_boolean(giac_eval(&quot;1==1&quot;))      # true (comparison returns boolean)
is_boolean(giac_eval(&quot;1&quot;))         # false (integer, not boolean)
is_boolean(giac_eval(&quot;0&quot;))         # false (integer, not boolean)</code></pre><p><strong>See also</strong></p><p><a href="#Giac.to_julia"><code>to_julia</code></a>, <a href="#Giac.is_integer"><code>is_integer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L264-L284">source</a></section></details></article><h3 id="Type-Enum-(GenTypes)"><a class="docs-heading-anchor" href="#Type-Enum-(GenTypes)">Type Enum (GenTypes)</a><a id="Type-Enum-(GenTypes)-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Enum-(GenTypes)" title="Permalink"></a></h3><p>GIAC expression types are available via the <code>Giac.GenTypes</code> module with the <code>T</code> enum:</p><pre><code class="language-julia hljs">using Giac.GenTypes: T, INT, DOUBLE, VECT, SYMB

giac_type(expr) == INT   # Check if expression is an integer
giac_type(expr) == VECT  # Check if expression is a vector</code></pre><table><tr><th style="text-align: right">Enum Value</th><th style="text-align: right">Int</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>INT</code></td><td style="text-align: right">0</td><td style="text-align: right">Machine integer (Int64)</td></tr><tr><td style="text-align: right"><code>DOUBLE</code></td><td style="text-align: right">1</td><td style="text-align: right">Double-precision float (Float64)</td></tr><tr><td style="text-align: right"><code>ZINT</code></td><td style="text-align: right">2</td><td style="text-align: right">Arbitrary-precision integer (BigInt)</td></tr><tr><td style="text-align: right"><code>REAL</code></td><td style="text-align: right">3</td><td style="text-align: right">Extended precision real</td></tr><tr><td style="text-align: right"><code>CPLX</code></td><td style="text-align: right">4</td><td style="text-align: right">Complex number</td></tr><tr><td style="text-align: right"><code>POLY</code></td><td style="text-align: right">5</td><td style="text-align: right">Polynomial</td></tr><tr><td style="text-align: right"><code>IDNT</code></td><td style="text-align: right">6</td><td style="text-align: right">Identifier/variable</td></tr><tr><td style="text-align: right"><code>VECT</code></td><td style="text-align: right">7</td><td style="text-align: right">Vector/list/sequence</td></tr><tr><td style="text-align: right"><code>SYMB</code></td><td style="text-align: right">8</td><td style="text-align: right">Symbolic expression</td></tr><tr><td style="text-align: right"><code>SPOL1</code></td><td style="text-align: right">9</td><td style="text-align: right">Sparse polynomial</td></tr><tr><td style="text-align: right"><code>FRAC</code></td><td style="text-align: right">10</td><td style="text-align: right">Rational fraction</td></tr><tr><td style="text-align: right"><code>EXT</code></td><td style="text-align: right">11</td><td style="text-align: right">Algebraic extension</td></tr><tr><td style="text-align: right"><code>STRNG</code></td><td style="text-align: right">12</td><td style="text-align: right">String value</td></tr><tr><td style="text-align: right"><code>FUNC</code></td><td style="text-align: right">13</td><td style="text-align: right">Function reference</td></tr><tr><td style="text-align: right"><code>ROOT</code></td><td style="text-align: right">14</td><td style="text-align: right">Polynomial root</td></tr><tr><td style="text-align: right"><code>MOD</code></td><td style="text-align: right">15</td><td style="text-align: right">Modular arithmetic</td></tr><tr><td style="text-align: right"><code>USER</code></td><td style="text-align: right">16</td><td style="text-align: right">User-defined type</td></tr><tr><td style="text-align: right"><code>MAP</code></td><td style="text-align: right">17</td><td style="text-align: right">Map/dictionary</td></tr><tr><td style="text-align: right"><code>EQW</code></td><td style="text-align: right">18</td><td style="text-align: right">Equation writer data</td></tr><tr><td style="text-align: right"><code>GROB</code></td><td style="text-align: right">19</td><td style="text-align: right">Graphic object</td></tr><tr><td style="text-align: right"><code>POINTER</code></td><td style="text-align: right">20</td><td style="text-align: right">Raw pointer</td></tr><tr><td style="text-align: right"><code>FLOAT</code></td><td style="text-align: right">21</td><td style="text-align: right">Float value</td></tr></table><article><details class="docstring" open="true"><summary id="Giac.GenTypes"><a class="docstring-binding" href="#Giac.GenTypes"><code>Giac.GenTypes</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">GenTypes</code></pre><p>A submodule containing the <code>T</code> enum for GIAC expression type constants.</p><p>This module provides type-safe, scoped access to GIAC&#39;s internal type system, matching the C++ <code>gen_unary_types</code> enum exactly.</p><p><strong>Usage</strong></p><pre><code class="language-julia hljs">using Giac.GenTypes: T, INT, VECT, SYMB

# Access type constants as module values
INT     # Machine integer (0)
DOUBLE  # Double-precision float (1)
VECT    # Vector/list/sequence (7)
SYMB    # Symbolic expression (8)

# Or use the T type for construction from integers
T(0)    # INT
T(7)    # VECT

# Use with giac_type()
expr = giac_eval(&quot;42&quot;)
giac_type(expr) == INT  # true

# Convert to integer
Int(VECT)  # 7</code></pre><p><strong>Type Values</strong></p><p>The enum values match the C++ <code>gen_unary_types</code> enum:</p><ul><li>Types 0-1 and 20-21 are &quot;immediate&quot; (no memory allocation)</li><li>Types 2-19 are &quot;pointer&quot; types (require memory allocation)</li></ul><p>See also: <a href="#Giac.giac_type"><code>Giac.giac_type</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/gen_types.jl#L5-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.GenTypes.T"><a class="docstring-binding" href="#Giac.GenTypes.T"><code>Giac.GenTypes.T</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">T</code></pre><p>Enum representing GIAC expression types, matching C++ <code>gen_unary_types</code>.</p><p><strong>Values</strong></p><table><tr><th style="text-align: right">Value</th><th style="text-align: right">Int</th><th style="text-align: right">C++ Name</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>T.INT</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>_INT_</code></td><td style="text-align: right">Machine integer</td></tr><tr><td style="text-align: right"><code>T.DOUBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>_DOUBLE_</code></td><td style="text-align: right">Double-precision float</td></tr><tr><td style="text-align: right"><code>T.ZINT</code></td><td style="text-align: right">2</td><td style="text-align: right"><code>_ZINT</code></td><td style="text-align: right">Arbitrary precision integer</td></tr><tr><td style="text-align: right"><code>T.REAL</code></td><td style="text-align: right">3</td><td style="text-align: right"><code>_REAL</code></td><td style="text-align: right">Extended precision real</td></tr><tr><td style="text-align: right"><code>T.CPLX</code></td><td style="text-align: right">4</td><td style="text-align: right"><code>_CPLX</code></td><td style="text-align: right">Complex number</td></tr><tr><td style="text-align: right"><code>T.POLY</code></td><td style="text-align: right">5</td><td style="text-align: right"><code>_POLY</code></td><td style="text-align: right">Polynomial</td></tr><tr><td style="text-align: right"><code>T.IDNT</code></td><td style="text-align: right">6</td><td style="text-align: right"><code>_IDNT</code></td><td style="text-align: right">Identifier/variable</td></tr><tr><td style="text-align: right"><code>T.VECT</code></td><td style="text-align: right">7</td><td style="text-align: right"><code>_VECT</code></td><td style="text-align: right">Vector/list/sequence</td></tr><tr><td style="text-align: right"><code>T.SYMB</code></td><td style="text-align: right">8</td><td style="text-align: right"><code>_SYMB</code></td><td style="text-align: right">Symbolic expression</td></tr><tr><td style="text-align: right"><code>T.SPOL1</code></td><td style="text-align: right">9</td><td style="text-align: right"><code>_SPOL1</code></td><td style="text-align: right">Sparse polynomial</td></tr><tr><td style="text-align: right"><code>T.FRAC</code></td><td style="text-align: right">10</td><td style="text-align: right"><code>_FRAC</code></td><td style="text-align: right">Rational fraction</td></tr><tr><td style="text-align: right"><code>T.EXT</code></td><td style="text-align: right">11</td><td style="text-align: right"><code>_EXT</code></td><td style="text-align: right">Algebraic extension</td></tr><tr><td style="text-align: right"><code>T.STRNG</code></td><td style="text-align: right">12</td><td style="text-align: right"><code>_STRNG</code></td><td style="text-align: right">String</td></tr><tr><td style="text-align: right"><code>T.FUNC</code></td><td style="text-align: right">13</td><td style="text-align: right"><code>_FUNC</code></td><td style="text-align: right">Function reference</td></tr><tr><td style="text-align: right"><code>T.ROOT</code></td><td style="text-align: right">14</td><td style="text-align: right"><code>_ROOT</code></td><td style="text-align: right">Root of polynomial</td></tr><tr><td style="text-align: right"><code>T.MOD</code></td><td style="text-align: right">15</td><td style="text-align: right"><code>_MOD</code></td><td style="text-align: right">Modular arithmetic</td></tr><tr><td style="text-align: right"><code>T.USER</code></td><td style="text-align: right">16</td><td style="text-align: right"><code>_USER</code></td><td style="text-align: right">User-defined type</td></tr><tr><td style="text-align: right"><code>T.MAP</code></td><td style="text-align: right">17</td><td style="text-align: right"><code>_MAP</code></td><td style="text-align: right">Map/dictionary</td></tr><tr><td style="text-align: right"><code>T.EQW</code></td><td style="text-align: right">18</td><td style="text-align: right"><code>_EQW</code></td><td style="text-align: right">Equation writer data</td></tr><tr><td style="text-align: right"><code>T.GROB</code></td><td style="text-align: right">19</td><td style="text-align: right"><code>_GROB</code></td><td style="text-align: right">Graphic object</td></tr><tr><td style="text-align: right"><code>T.POINTER</code></td><td style="text-align: right">20</td><td style="text-align: right"><code>_POINTER_</code></td><td style="text-align: right">Raw pointer</td></tr><tr><td style="text-align: right"><code>T.FLOAT</code></td><td style="text-align: right">21</td><td style="text-align: right"><code>_FLOAT_</code></td><td style="text-align: right">Float (immediate)</td></tr></table><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Giac.GenTypes: T, INT, VECT, FLOAT

# Check integer value
Int(INT) == 0     # true
Int(VECT) == 7    # true
Int(FLOAT) == 21  # true

# Create from integer
T(0) == INT       # true
T(7) == VECT      # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/gen_types.jl#L46-L92">source</a></section></details></article><h2 id="Component-Access"><a class="docs-heading-anchor" href="#Component-Access">Component Access</a><a id="Component-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Component-Access" title="Permalink"></a></h2><p>Functions for accessing components of compound types:</p><article><details class="docstring" open="true"><summary id="Giac.numer"><a class="docstring-binding" href="#Giac.numer"><code>Giac.numer</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">numer(g::GiacExpr) -&gt; GiacExpr</code></pre><p>Return the numerator of a fraction, or the value itself for integers.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">numer(giac_eval(&quot;3/4&quot;))   # GiacExpr representing 3
numer(giac_eval(&quot;5&quot;))     # GiacExpr representing 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L294-L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.denom"><a class="docstring-binding" href="#Giac.denom"><code>Giac.denom</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">denom(g::GiacExpr) -&gt; GiacExpr</code></pre><p>Return the denominator of a fraction, or <code>1</code> for integers.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">denom(giac_eval(&quot;3/4&quot;))   # GiacExpr representing 4
denom(giac_eval(&quot;5&quot;))     # GiacExpr representing 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L332-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.real_part"><a class="docstring-binding" href="#Giac.real_part"><code>Giac.real_part</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">real_part(g::GiacExpr) -&gt; GiacExpr</code></pre><p>Return the real part of a complex number, or the value itself for non-complex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">real_part(giac_eval(&quot;3+4*i&quot;))  # GiacExpr representing 3
real_part(giac_eval(&quot;5&quot;))      # GiacExpr representing 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L370-L380">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.imag_part"><a class="docstring-binding" href="#Giac.imag_part"><code>Giac.imag_part</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">imag_part(g::GiacExpr) -&gt; GiacExpr</code></pre><p>Return the imaginary part of a complex number, or <code>0</code> for non-complex.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">imag_part(giac_eval(&quot;3+4*i&quot;))  # GiacExpr representing 4
imag_part(giac_eval(&quot;5&quot;))      # GiacExpr representing 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L405-L415">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.symb_funcname"><a class="docstring-binding" href="#Giac.symb_funcname"><code>Giac.symb_funcname</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symb_funcname(g::GiacExpr) -&gt; String</code></pre><p>Return the function name of a symbolic expression.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">symb_funcname(giac_eval(&quot;sin(x)&quot;))  # &quot;sin&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L440-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.symb_argument"><a class="docstring-binding" href="#Giac.symb_argument"><code>Giac.symb_argument</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">symb_argument(g::GiacExpr) -&gt; GiacExpr</code></pre><p>Return the argument (operand) of a symbolic expression.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">arg = symb_argument(giac_eval(&quot;sin(x)&quot;))  # GiacExpr representing x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/introspection.jl#L474-L483">source</a></section></details></article><h2 id="Conversion-Functions"><a class="docs-heading-anchor" href="#Conversion-Functions">Conversion Functions</a><a id="Conversion-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.to_julia"><a class="docstring-binding" href="#Giac.to_julia"><code>Giac.to_julia</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_julia(m::GiacMatrix) -&gt; Matrix</code></pre><p>Convert a GiacMatrix to a Julia Matrix with appropriate element type narrowing.</p><p>Boolean elements are converted to <code>Bool</code>, integers to <code>Int64</code>, etc. The resulting matrix type is narrowed to the most specific common type.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Integer matrix
g = giac_eval(&quot;[[1, 2], [3, 4]]&quot;)
m = GiacMatrix(g)
to_julia(m)  # 2×2 Matrix{Int64}

# Boolean matrix
g = giac_eval(&quot;[[true, false], [false, true]]&quot;)
m = GiacMatrix(g)
to_julia(m)  # 2×2 Matrix{Bool}</code></pre><p><strong>See also</strong></p><p><a href="#Giac.to_julia"><code>to_julia</code></a>, <a href="../../developer/architecture/#GiacMatrix"><code>GiacMatrix</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/types.jl#L879-L902">source</a></section><section><div><pre><code class="language-julia hljs">to_julia(g::GiacExpr) -&gt; Union{Bool, Int64, BigInt, Float64, Rational, Complex, Vector, String, GiacExpr}</code></pre><p>Recursively convert a GIAC expression to native Julia types.</p><p><strong>Conversion Rules</strong></p><table><tr><th style="text-align: right">GIAC Type</th><th style="text-align: right">Julia Return Type</th></tr><tr><td style="text-align: right">Boolean (<code>true</code>/<code>false</code>)</td><td style="text-align: right"><code>Bool</code></td></tr><tr><td style="text-align: right"><code>INT</code></td><td style="text-align: right"><code>Int64</code></td></tr><tr><td style="text-align: right"><code>ZINT</code></td><td style="text-align: right"><code>BigInt</code></td></tr><tr><td style="text-align: right"><code>DOUBLE</code>, <code>REAL</code></td><td style="text-align: right"><code>Float64</code></td></tr><tr><td style="text-align: right"><code>FRAC</code></td><td style="text-align: right"><code>Rational{Int64}</code> or <code>Rational{BigInt}</code></td></tr><tr><td style="text-align: right"><code>CPLX</code></td><td style="text-align: right"><code>Complex{T}</code> (T promoted from parts)</td></tr><tr><td style="text-align: right"><code>VECT</code></td><td style="text-align: right"><code>Vector{T}</code> (T narrowed from elements)</td></tr><tr><td style="text-align: right"><code>STRNG</code></td><td style="text-align: right"><code>String</code></td></tr><tr><td style="text-align: right"><code>SYMB</code>, <code>IDNT</code>, <code>FUNC</code></td><td style="text-align: right"><code>GiacExpr</code> (unchanged)</td></tr></table><p>Note: GIAC represents booleans as integers internally, but <code>to_julia</code> detects them via their string representation (&quot;true&quot;/&quot;false&quot;) and returns Julia <code>Bool</code> values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Boolean conversion
to_julia(giac_eval(&quot;true&quot;))      # true::Bool
to_julia(giac_eval(&quot;false&quot;))     # false::Bool
to_julia(giac_eval(&quot;1==1&quot;))      # true::Bool (comparison result)

# Integer conversion (distinct from booleans)
to_julia(giac_eval(&quot;1&quot;))         # Int64(1)
to_julia(giac_eval(&quot;0&quot;))         # Int64(0)
to_julia(giac_eval(&quot;42&quot;))        # Int64(42)

# Float conversion
to_julia(giac_eval(&quot;3.14&quot;))      # Float64(3.14)

# Rational conversion
to_julia(giac_eval(&quot;3/4&quot;))       # 3//4

# Complex conversion
to_julia(giac_eval(&quot;3+4*i&quot;))     # 3.0 + 4.0im

# Vector conversion with type narrowing
to_julia(giac_eval(&quot;[1, 2, 3]&quot;)) # [1, 2, 3]::Vector{Int64}

# Symbolic expressions are unchanged
to_julia(giac_eval(&quot;x + 1&quot;))     # GiacExpr (unchanged)</code></pre><p><strong>See also</strong></p><p><a href="#Giac.giac_type"><code>giac_type</code></a>, <a href="#Giac.is_boolean"><code>is_boolean</code></a>, <a href="#Giac.is_numeric"><code>is_numeric</code></a>, <a href="#Giac.is_vector"><code>is_vector</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/conversion.jl#L13-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.to_giac"><a class="docstring-binding" href="#Giac.to_giac"><code>Giac.to_giac</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_giac(expr)</code></pre><p>Convert an expression to GiacExpr. Extended by GiacSymbolicsExt for Symbolics.Num types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/Giac.jl#L144-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Giac.to_symbolics"><a class="docstring-binding" href="#Giac.to_symbolics"><code>Giac.to_symbolics</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_symbolics(expr::GiacExpr)</code></pre><p>Convert a GiacExpr to a Symbolics.jl expression. Extended by GiacSymbolicsExt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/Giac.jl#L151-L155">source</a></section></details></article><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Giac.is_stub_mode"><a class="docstring-binding" href="#Giac.is_stub_mode"><code>Giac.is_stub_mode</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_stub_mode()</code></pre><p>Check if the wrapper is running in stub mode (without the actual library).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/Giac.jl/blob/245d2a3376340df44505fe4afeee6734b91b0084/src/wrapper.jl#L252-L256">source</a></section></details></article><h3 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>giac_eval(expr)</code></td><td style="text-align: right">Evaluate a GIAC expression string</td></tr><tr><td style="text-align: right"><code>invoke_cmd(cmd, args...)</code></td><td style="text-align: right">Invoke any GIAC command dynamically</td></tr><tr><td style="text-align: right"><code>is_stub_mode()</code></td><td style="text-align: right">Check if running without GIAC library</td></tr><tr><td style="text-align: right"><code>to_julia(expr)</code></td><td style="text-align: right">Convert GiacExpr to Julia type</td></tr></table><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../domains/signal/continuous_transforms/">« Continuous-Time Transforms</a><a class="docs-footer-nextpage" href="../giac_commands/">GIAC Commands »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 11:25">Friday 20 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
