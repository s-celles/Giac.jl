var documenterSearchIndex = {"docs":
[{"location":"developer/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"This guide covers common issues encountered when developing with Giac.jl and strategies for debugging them.","category":"section"},{"location":"developer/troubleshooting/#Library-Loading-Errors","page":"Troubleshooting","title":"Library Loading Errors","text":"","category":"section"},{"location":"developer/troubleshooting/#libgiac_jll-Issues","page":"Troubleshooting","title":"libgiac_jll Issues","text":"Symptom: Error on using Giac mentioning missing library or symbols.\n\nERROR: LoadError: could not load library \"libgiac\"\n\nCauses and Solutions:\n\nMissing JLL package:\nusing Pkg\nPkg.add(\"libgiac_jll\")\nVersion mismatch: Ensure compatible versions:\nPkg.status(\"libgiac_jll\")\nPkg.status(\"CxxWrap\")\nCorrupted installation:\nPkg.rm(\"Giac\")\nPkg.gc()  # Clean up\nPkg.add(\"Giac\")","category":"section"},{"location":"developer/troubleshooting/#CxxWrap-Compatibility","page":"Troubleshooting","title":"CxxWrap Compatibility","text":"Symptom: Errors about missing methods or incorrect types.\n\nERROR: MethodError: no method matching ...\n\nCauses:\n\nCxxWrap version mismatch: Check versions match what Giac.jl expects\nPkg.status(\"CxxWrap\")\nRecompilation needed:\nusing Pkg\nPkg.build(\"Giac\")","category":"section"},{"location":"developer/troubleshooting/#RTLD_GLOBAL-Requirement","page":"Troubleshooting","title":"RTLD_GLOBAL Requirement","text":"Symptom: Symbols not found at runtime despite library loading.\n\nERROR: symbol \"giac_...\" not found\n\nCause: The C++ library wasn't loaded with RTLD_GLOBAL flag.\n\nFix: This should be handled automatically by Giac.jl's init_giac_library(). If you see this error:\n\nCheck that __init__() is being called\nVerify the library loading code in wrapper.jl:\n# Should use RTLD_GLOBAL\nLibdl.dlopen(lib_path, RTLD_GLOBAL | RTLD_LAZY)","category":"section"},{"location":"developer/troubleshooting/#Runtime-Errors","page":"Troubleshooting","title":"Runtime Errors","text":"","category":"section"},{"location":"developer/troubleshooting/#GiacError-Types","page":"Troubleshooting","title":"GiacError Types","text":"Giac.jl categorizes errors with a category field:\n\nCategory Description Common Causes\n:parse GIAC couldn't parse the expression Syntax error in expression string\n:eval Evaluation failed Unknown command, domain error\n:type Type conversion error Incompatible types\n:memory Memory-related error Null pointer, freed object\n\nDebugging:\n\ntry\n    result = giac_eval(\"invalid(\")\ncatch e\n    if e isa GiacError\n        println(\"Category: \", e.category)\n        println(\"Message: \", e.message)\n    end\n    rethrow()\nend","category":"section"},{"location":"developer/troubleshooting/#Unknown-Command-Errors","page":"Troubleshooting","title":"Unknown Command Errors","text":"Symptom:\n\nGiacError: Unknown command: myfunction\n\nCauses:\n\nTypo in command name:\ngiac_cmd(:factr, x)  # Wrong: should be :factor\nCommand not in GIAC: Not all mathematical functions are in GIAC\n# Check if command exists\nusing Giac: VALID_COMMANDS\n:my_function in VALID_COMMANDS\nCommand suggestions: Giac.jl suggests similar commands:\nUnknown command: factr. Did you mean: factor?","category":"section"},{"location":"developer/troubleshooting/#Type-Conversion-Failures","page":"Troubleshooting","title":"Type Conversion Failures","text":"Symptom:\n\nERROR: Cannot convert GiacExpr to Float64\n\nCauses and Solutions:\n\nExpression is symbolic:\nx = giac_eval(\"x\")\nto_julia(x)  # Error: x is symbolic\n\n# Fix: Evaluate numerically first\nto_julia(giac_cmd(:evalf, x))  # Still symbolic\n\n# Or: Use numeric values\nx = giac_eval(\"3.14\")\nto_julia(x)  # Works: 3.14\nComplex result:\nresult = sqrt(giac_eval(\"-1\"))\nto_julia(Float64, result)  # Error: result is complex\n\n# Fix: Use Complex type\nto_julia(ComplexF64, result)  # Works","category":"section"},{"location":"developer/troubleshooting/#Performance-Issues","page":"Troubleshooting","title":"Performance Issues","text":"","category":"section"},{"location":"developer/troubleshooting/#Identifying-Tier-Fallbacks","page":"Troubleshooting","title":"Identifying Tier Fallbacks","text":"If operations seem slower than expected, a function may be falling back from Tier 1 to Tier 3.\n\nDebug strategy:\n\n# Enable debug logging\nENV[\"JULIA_DEBUG\"] = \"Giac\"\n\n# Run your operation\nresult = sin(giac_eval(\"x\"))\n\n# Check logs for fallback messages:\n# \"Tier 1 function failed: ...\"\n\nCommon causes of fallback:\n\nLibrary in stub mode: Check Giac._stub_mode[]\nC++ exception: Error in the C++ wrapper\nInvalid input: Pointer is null or invalid","category":"section"},{"location":"developer/troubleshooting/#Profiling-Tips","page":"Troubleshooting","title":"Profiling Tips","text":"Using Julia's profiler:\n\nusing Profile\n\n# Profile the operation\n@profile for i in 1:10000\n    sin(giac_eval(\"x\"))\nend\n\n# View results\nProfile.print()\n\nBenchmarking tiers:\n\nusing BenchmarkTools\n\nx = giac_eval(\"x\")\n\n# Benchmark Tier 1 path\n@btime sin($x)\n\n# Force Tier 3 path for comparison\n@btime giac_cmd(:sin, $x)","category":"section"},{"location":"developer/troubleshooting/#Memory-Allocation-Tracking","page":"Troubleshooting","title":"Memory Allocation Tracking","text":"Check for excessive allocations:\n\n@time begin\n    for i in 1:1000\n        x = giac_eval(\"x^$i\")\n    end\nend\n\nForce GC to check for leaks:\n\nGC.gc()\ninitial = Sys.maxrss()\n\nfor i in 1:10000\n    x = giac_eval(\"x^2\")\nend\n\nGC.gc()\nfinal = Sys.maxrss()\nprintln(\"Memory growth: $(final - initial) bytes\")","category":"section"},{"location":"developer/troubleshooting/#Test-Failures","page":"Troubleshooting","title":"Test Failures","text":"","category":"section"},{"location":"developer/troubleshooting/#Common-Test-Failure-Causes","page":"Troubleshooting","title":"Common Test Failure Causes","text":"String representation changes:\n# May fail if GIAC changes output format\n@test string(factor(x^2 - 1)) == \"(x-1)*(x+1)\"\n\n# More robust:\n@test expand(factor(x^2 - 1)) == x^2 - 1\nFloating point precision:\n# May fail due to precision\n@test to_julia(sin(giac_eval(\"pi/6\"))) == 0.5\n\n# Better:\n@test to_julia(sin(giac_eval(\"pi/6\"))) ≈ 0.5\nOrder-dependent results:\n# Polynomial terms may appear in different orders\n@test string(expand(x+y)) == \"x+y\"  # May be \"y+x\"\n\n# Better: Compare evaluated equality\nresult = expand((x+1)*(x-1))\n@test giac_cmd(:expand, result - (x^2 - 1)) == giac_eval(\"0\")","category":"section"},{"location":"developer/troubleshooting/#Debugging-Test-Failures","page":"Troubleshooting","title":"Debugging Test Failures","text":"Run single test:\n\nusing Pkg\nPkg.test(\"Giac\", test_args=[\"--testset\", \"sin function\"])\n\nInteractive debugging:\n\nusing Giac\n\n# Reproduce the test manually\nx = giac_eval(\"x\")\nresult = sin(x)\n@show result\n@show string(result)\n@show typeof(result)\n\nCheck test environment:\n\n# Ensure clean state\nGC.gc()\n\n# Check context\n@show Giac.DEFAULT_CONTEXT","category":"section"},{"location":"developer/troubleshooting/#Debugging-Strategies","page":"Troubleshooting","title":"Debugging Strategies","text":"","category":"section"},{"location":"developer/troubleshooting/#Isolating-Julia-vs-C-Issues","page":"Troubleshooting","title":"Isolating Julia vs C++ Issues","text":"Step 1: Check if the issue is in argument conversion:\n\n# Test argument conversion\nexpr = giac_eval(\"x\")\n@show Giac._arg_to_giac_string(expr)\n\nStep 2: Check if GIAC understands the command:\n\n# Direct string evaluation\nresult = giac_eval(\"sin(x)\")  # Bypasses Julia wrappers\n\nStep 3: Check the tier being used:\n\n# Enable debug mode\nENV[\"JULIA_DEBUG\"] = \"Giac\"\n\n# Run operation\nsin(giac_eval(\"x\"))\n# Look for tier fallback messages","category":"section"},{"location":"developer/troubleshooting/#Using-GIAC-Directly","page":"Troubleshooting","title":"Using GIAC Directly","text":"For advanced debugging, test in GIAC directly:\n\n# Install GIAC CLI (if available)\ngiac\n\n# Test commands directly\n>> sin(x)\n>> factor(x^2-1)","category":"section"},{"location":"developer/troubleshooting/#Wrapper-Layer-Debugging","page":"Troubleshooting","title":"Wrapper Layer Debugging","text":"Check wrapper availability:\n\nusing Giac: GiacCxxBindings\n\n# Check if wrapper is loaded\n@show GiacCxxBindings._have_library\n\n# List available functions\nnames(GiacCxxBindings)","category":"section"},{"location":"developer/troubleshooting/#Getting-Help","page":"Troubleshooting","title":"Getting Help","text":"","category":"section"},{"location":"developer/troubleshooting/#GitHub-Issues","page":"Troubleshooting","title":"GitHub Issues","text":"For bugs or feature requests:\n\nSearch existing issues at github.com/s-celles/Giac.jl/issues\nCreate a new issue with:\nGiac.jl version (Pkg.status(\"Giac\"))\nJulia version (VERSION)\nMinimal reproducible example\nFull error message with stack trace","category":"section"},{"location":"developer/troubleshooting/#Providing-Debug-Information","page":"Troubleshooting","title":"Providing Debug Information","text":"Include this information in bug reports:\n\nusing Pkg\nusing Giac\n\nprintln(\"Julia: \", VERSION)\nprintln(\"Giac.jl: \", Pkg.dependencies()[Base.PkgId(Giac).uuid].version)\nprintln(\"CxxWrap: \", Pkg.dependencies()[Base.PkgId(CxxWrap).uuid].version)\nprintln(\"Platform: \", Sys.MACHINE)\nprintln(\"OS: \", Sys.KERNEL)","category":"section"},{"location":"developer/troubleshooting/#Community-Resources","page":"Troubleshooting","title":"Community Resources","text":"Julia Discourse: discourse.julialang.org - Tag with giac or computer-algebra\nJulia Slack/Zulip: #mathematics channel\nGIAC Documentation: www-fourier.univ-grenoble-alpes.fr/~parMDisse/giac.html","category":"section"},{"location":"developer/troubleshooting/#See-Also","page":"Troubleshooting","title":"See Also","text":"Memory Management - For memory-related issues\nPerformance Tiers - Understanding tier fallbacks\nPackage Architecture - Where to find source code\n\n","category":"section"},{"location":"mathematics/trigonometry/#Trigonometry","page":"Trigonometry","title":"Trigonometry","text":"Giac.jl provides comprehensive tools for trigonometric simplification, expansion, and identity verification.","category":"section"},{"location":"mathematics/trigonometry/#Setup","page":"Trigonometry","title":"Setup","text":"using Giac\nusing Giac.Commands: simplify, solve, trigexpand, tlin, tcollect, asin, acos, atan, sinh, cosh\n\n@giac_var x y","category":"section"},{"location":"mathematics/trigonometry/#Fundamental-Identities","page":"Trigonometry","title":"Fundamental Identities","text":"","category":"section"},{"location":"mathematics/trigonometry/#Pythagorean-Identity","page":"Trigonometry","title":"Pythagorean Identity","text":"Verify the fundamental Pythagorean identity:\n\n@giac_var x\n\nsimplify(sin(x)^2 + cos(x)^2)\n# Output: 1","category":"section"},{"location":"mathematics/trigonometry/#Other-Pythagorean-Identities","page":"Trigonometry","title":"Other Pythagorean Identities","text":"@giac_var x\n\n# 1 + tan²(x) = sec²(x)\nsimplify(1 + tan(x)^2 - 1/cos(x)^2)\n# Should simplify to 0\n\n# 1 + cot²(x) = csc²(x)\nsimplify(1 + cot(x)^2 - 1/sin(x)^2)","category":"section"},{"location":"mathematics/trigonometry/#Trigonometric-Expansion-(trigexpand)","page":"Trigonometry","title":"Trigonometric Expansion (trigexpand)","text":"","category":"section"},{"location":"mathematics/trigonometry/#Double-Angle-Formulas","page":"Trigonometry","title":"Double Angle Formulas","text":"Use trigexpand to expand trigonometric functions:\n\n@giac_var x\n\n# sin(2x) = 2*sin(x)*cos(x)\ntrigexpand(sin(2*x))\n# Output: 2*cos(x)*sin(x)\n\n# cos(2x) = cos²(x) - sin²(x)\ntrigexpand(cos(2*x))\n# Output: cos(x)^2-sin(x)^2","category":"section"},{"location":"mathematics/trigonometry/#Triple-Angle-Formulas","page":"Trigonometry","title":"Triple Angle Formulas","text":"@giac_var x\n\n# sin(3x) expansion\ntrigexpand(sin(3*x))\n# Output: (4*cos(x)^2-1)*sin(x)\n\n# cos(3x) expansion\ntrigexpand(cos(3*x))","category":"section"},{"location":"mathematics/trigonometry/#Sum-Formulas","page":"Trigonometry","title":"Sum Formulas","text":"@giac_var x y\n\n# sin(x+y) = sin(x)cos(y) + cos(x)sin(y)\ntrigexpand(sin(x+y))\n# Output: sin(x)*cos(y)+cos(x)*sin(y)\n\n# cos(x+y) = cos(x)cos(y) - sin(x)sin(y)\ntrigexpand(cos(x+y))","category":"section"},{"location":"mathematics/trigonometry/#Product-to-Sum-Conversion-(tlin)","page":"Trigonometry","title":"Product to Sum Conversion (tlin)","text":"Convert products of trigonometric functions to sums:\n\n@giac_var x y\n\n# sin(x)*cos(x) = (1/2)*sin(2x)\ntlin(sin(x)*cos(x))\n# Output: (1/2)*sin(2*x)\n\n# cos(x)*cos(x) = (1/2)*(1 + cos(2x))\ntlin(cos(x)^2)\n# Output: (1/2)*cos(2*x)+1/2\n\n# sin(x)*sin(y)\ntlin(sin(x)*sin(y))\n# Output in terms of cos(x-y) and cos(x+y)","category":"section"},{"location":"mathematics/trigonometry/#Sum-to-Product-Conversion-(tcollect)","page":"Trigonometry","title":"Sum to Product Conversion (tcollect)","text":"Convert sums of trigonometric functions to products:\n\n@giac_var x\n\n# sin(x) + cos(x) = sqrt(2)*cos(x - π/4)\ntcollect(sin(x)+cos(x))\n# Output: sqrt(2)*cos(x-1/4*pi)\n\n# More complex expressions\ntcollect(2*sin(x)*cos(x))","category":"section"},{"location":"mathematics/trigonometry/#Simplification","page":"Trigonometry","title":"Simplification","text":"","category":"section"},{"location":"mathematics/trigonometry/#Basic-Simplification","page":"Trigonometry","title":"Basic Simplification","text":"Simplify trigonometric expressions:\n\n@giac_var x\n\n# tan(x)*cos(x) = sin(x)\nsimplify(tan(x)*cos(x))\n# Output: sin(x)\n\n# sin(x)/cos(x) = tan(x)\nsimplify(sin(x)/cos(x))\n# Output: tan(x)","category":"section"},{"location":"mathematics/trigonometry/#Complex-Expressions","page":"Trigonometry","title":"Complex Expressions","text":"@giac_var x\n\n# (1 - cos(2x))/(2*sin(x)) simplifies\nsimplify((1-cos(2*x))/(2*sin(x)))\n\n# tan(x) + cot(x)\nsimplify(tan(x)+cot(x))","category":"section"},{"location":"mathematics/trigonometry/#Solving-Trigonometric-Equations","page":"Trigonometry","title":"Solving Trigonometric Equations","text":"","category":"section"},{"location":"mathematics/trigonometry/#Basic-Equations","page":"Trigonometry","title":"Basic Equations","text":"@giac_var x\n\n# sin(x) = 0\njulia> solve(sin(x) ~ 0, x)\n# Output: list[0,pi]\n\n# cos(x) = 0\nsolve(cos(x) ~ 0 , x)\n# Output: list[-1/2*pi,1/2*pi]","category":"section"},{"location":"mathematics/trigonometry/#More-Complex-Equations","page":"Trigonometry","title":"More Complex Equations","text":"@giac_var x\n\n# sin(x) = 1/2 - create 1/2 as GiacExpr\nhalf = giac_eval(\"1/2\")\nsolve(sin(x) - half, x)\n# Output: π/6 and 5π/6\n\n# cos(2x) = 0\nsolve(cos(2*x), x)\n# Output: π/4, 3π/4, etc.","category":"section"},{"location":"mathematics/trigonometry/#Equations-in-Intervals","page":"Trigonometry","title":"Equations in Intervals","text":"# Find all solutions of sin(x) = 1/2 in [0, 2π]\n# Use solve with constraints or numerical methods","category":"section"},{"location":"mathematics/trigonometry/#Inverse-Trigonometric-Functions","page":"Trigonometry","title":"Inverse Trigonometric Functions","text":"","category":"section"},{"location":"mathematics/trigonometry/#Basic-Evaluations","page":"Trigonometry","title":"Basic Evaluations","text":"@giac_var x\n\n# asin(1/2) = π/6 - create 1/2 as GiacExpr\nhalf = giac_eval(\"1/2\")\nasin(half)\n# Output: pi/6\n\n# acos(0) - create 0 as GiacExpr\nzero_expr = 0 * x + 0\nacos(zero_expr)\n# Output: pi/2\n\n# atan(1) - create 1 as GiacExpr\none_expr = 0 * x + 1\natan(one_expr)\n# Output: pi/4","category":"section"},{"location":"mathematics/trigonometry/#Compositions","page":"Trigonometry","title":"Compositions","text":"@giac_var x\n\n# sin(asin(x)) = x\nsimplify(sin(asin(x)))\n# Should return x (with domain restrictions)","category":"section"},{"location":"mathematics/trigonometry/#Hyperbolic-Functions","page":"Trigonometry","title":"Hyperbolic Functions","text":"GIAC also supports hyperbolic trigonometric functions:\n\n@giac_var x\n\n# sinh(x) expression\nsinh(x)\n\n# cosh(x) + sinh(x) = exp(x)\nsimplify(cosh(x)+sinh(x)-exp(x))\n# Output: 0","category":"section"},{"location":"mathematics/trigonometry/#Table-of-Commands","page":"Trigonometry","title":"Table of Commands","text":"Command Description\ntrigexpand(expr) Expand trig functions (double/triple angle)\ntlin(expr) Product to sum conversion\ntcollect(expr) Sum to product conversion\nsimplify(expr) General simplification\ntexpand(expr) Alternative expansion","category":"section"},{"location":"mathematics/trigonometry/#Notes","page":"Trigonometry","title":"Notes","text":"Trigonometric functions work with symbolic arguments from @giac_var\nTo create fractional GiacExpr values, use arithmetic: (1 + 0*x) / 2 for 1/2\nSolutions to trig equations may include principal values or general solutions with n*π terms\nFor numerical evaluation of inverse trig functions, convert results to Julia floats\n\n","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#User-mode-installation-(not-yet-available)","page":"Installation","title":"User mode installation (not yet available)","text":"This command will install Giac.jl (when both GIAC_jll and libgiac-julia-wrapper will be published)\n\nusing Pkg\nPkg.add(\"Giac\")  # when registered in Julia General Registry\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")  # until unregistered","category":"section"},{"location":"install/#Developer-mode-installation","page":"Installation","title":"Developer mode installation","text":"","category":"section"},{"location":"install/#Option-1:-Stub-Mode-(No-C-Dependencies)","page":"Installation","title":"Option 1: Stub Mode (No C++ Dependencies)","text":"For development or testing without the full GIAC library:\n\nusing Pkg\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")\n\nIn stub mode, basic operations work but return placeholder values.","category":"section"},{"location":"install/#Option-2:-Full-Integration-(With-GIAC-2.0.0)","page":"Installation","title":"Option 2: Full Integration (With GIAC 2.0.0)","text":"","category":"section"},{"location":"install/#Prerequisites","page":"Installation","title":"Prerequisites","text":"Julia 1.10+ (LTS recommended)\nC++ compiler with C++17 support\nCMake 3.15+\nGIAC 2.0.0 source","category":"section"},{"location":"install/#Step-1:-Build-GIAC-2.0.0","page":"Installation","title":"Step 1: Build GIAC 2.0.0","text":"# Download GIAC\nwget https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/giac_stable.tgz\ntar xzf giac_stable.tgz\ncd giac-2.0.0\n\n# Configure and build\n./configure --enable-shared --disable-gui --disable-pari\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-2:-Build-libgiac-julia-wrapper","page":"Installation","title":"Step 2: Build libgiac-julia-wrapper","text":"git clone https://github.com/s-celles/libgiac-julia-wrapper\ncd libgiac-julia-wrapper\nmkdir build && cd build\ncmake .. -DGIAC_ROOT=/path/to/giac-2.0.0\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-3:-Set-Environment","page":"Installation","title":"Step 3: Set Environment","text":"export GIAC_WRAPPER_LIB=/path/to/libgiac-julia-wrapper/build/src/libgiac_wrapper.so\nexport LD_LIBRARY_PATH=/path/to/giac-2.0.0/src/.libs:$LD_LIBRARY_PATH\n# or\nexport LD_LIBRARY_PATH=$(julia -e 'using GIAC_jll; print(GIAC_jll.artifact_dir)')/lib:$LD_LIBRARY_PATH","category":"section"},{"location":"install/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"using Giac\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())\n\n# If stub mode is false, full GIAC integration is working\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\n","category":"section"},{"location":"extensions/symbolics/#Symbolics.jl-Integration","page":"Symbolics.jl","title":"Symbolics.jl Integration","text":"Giac.jl provides seamless integration with Symbolics.jl through bidirectional conversion functions.","category":"section"},{"location":"extensions/symbolics/#Basic-Usage","page":"Symbolics.jl","title":"Basic Usage","text":"using Giac, Symbolics\n\n@variables x y\ngiac_expr = to_giac(x^2 + 2*x + 1)\nfactored = invoke_cmd(:factor, giac_expr)  # (x+1)^2\nsym_result = to_symbolics(factored)  # Num: (1+x)^2","category":"section"},{"location":"extensions/symbolics/#Symbolic-Preservation","page":"Symbolics.jl","title":"Symbolic Preservation","text":"As of version 0.8.1, to_symbolics preserves symbolic mathematical functions instead of evaluating them to floating-point approximations.","category":"section"},{"location":"extensions/symbolics/#Factorization-Preservation-(Feature-044)","page":"Symbolics.jl","title":"Factorization Preservation (Feature 044)","text":"As of version 0.8.2, to_symbolics also preserves factorized expression structure from GIAC:\n\nusing Giac, Symbolics\nusing Giac.Commands: ifactor, factor\n\n# Integer factorization is preserved\nresult = ifactor(1000000)\nsym = to_symbolics(result)\n# Result: (2^6)*(5^6), NOT 1000000\n\n# Polynomial factorization is preserved\nx = giac_eval(\"x\")\nresult = factor(x^2 - 1)\nsym = to_symbolics(result)\n# Result: (-1 + x)*(1 + x), NOT x^2 - 1","category":"section"},{"location":"extensions/symbolics/#Square-Roots-and-Other-Roots","page":"Symbolics.jl","title":"Square Roots and Other Roots","text":"using Giac, Symbolics\n\n# sqrt(2) is preserved symbolically\nresult = giac_eval(\"sqrt(2)\")\nsym = to_symbolics(result)\n# Result: sqrt(2), NOT 1.4142135623730951\n\n# Works with factorization too\nresult = giac_eval(\"factor(x^8-1)\")\nsym = to_symbolics(result)\n# Result contains sqrt(2) symbolically in factors","category":"section"},{"location":"extensions/symbolics/#Nested-Expressions","page":"Symbolics.jl","title":"Nested Expressions","text":"# Nested sqrt preserved\nresult = giac_eval(\"sqrt(sqrt(2))\")\nsym = to_symbolics(result)\n# Result: sqrt(sqrt(2)), NOT 1.189...\n\n# Mixed expressions\nresult = giac_eval(\"x^2 + sqrt(2)*x + 1\")\nsym = to_symbolics(result)\n# Result: 1 + sqrt(2)*x + x^2","category":"section"},{"location":"extensions/symbolics/#Exponentials-and-Logarithms","page":"Symbolics.jl","title":"Exponentials and Logarithms","text":"# exp(1) = e preserved\nresult = giac_eval(\"exp(1)\")\nsym = to_symbolics(result)\n# Result: exp(1), NOT 2.718...\n\n# log(2) preserved\nresult = giac_eval(\"log(2)\")\nsym = to_symbolics(result)\n# Result: log(2), NOT 0.693...","category":"section"},{"location":"extensions/symbolics/#Trigonometric-Functions","page":"Symbolics.jl","title":"Trigonometric Functions","text":"# sin, cos, tan preserved\nresult = giac_eval(\"sin(1)\")\nsym = to_symbolics(result)\n# Result: sin(1), NOT 0.841...\n\nresult = giac_eval(\"cos(pi/4)\")\nsym = to_symbolics(result)\n# Result: cos(π/4), NOT 0.707...","category":"section"},{"location":"extensions/symbolics/#Mathematical-Constants","page":"Symbolics.jl","title":"Mathematical Constants","text":"# pi preserved as symbolic constant\nresult = giac_eval(\"pi\")\nsym = to_symbolics(result)\n# Result: π (Symbolics.pi)\n\n# Works in expressions\nresult = giac_eval(\"2*pi\")\nsym = to_symbolics(result)\n# Result: 2π","category":"section"},{"location":"extensions/symbolics/#Preserved-Functions","page":"Symbolics.jl","title":"Preserved Functions","text":"The following GIAC functions are preserved symbolically when converting to Symbolics.jl:\n\nFunction Description\nsqrt Square root\nexp Exponential\nlog, ln Natural logarithm\nsin, cos, tan Trigonometric\nasin, acos, atan Inverse trigonometric\nsinh, cosh, tanh Hyperbolic\nabs Absolute value\n\nMathematical constants:\n\npi → Symbolics.pi (π)\ni → im (Julia imaginary unit)","category":"section"},{"location":"extensions/symbolics/#API-Reference","page":"Symbolics.jl","title":"API Reference","text":"See the Conversion Functions section in the Core API documentation for the full API reference of to_giac and to_symbolics.\n\n","category":"section"},{"location":"api/giac_commands/#GIAC-commands","page":"GIAC Commands","title":"GIAC commands","text":"","category":"section"},{"location":"api/giac_commands/#Dynamic-Command-Invocation","page":"GIAC Commands","title":"Dynamic Command Invocation","text":"Call any of GIAC's 2200+ commands dynamically:\n\nusing Giac\n\n@giac_var x\nexpr = x^2 - 1\n\n# Function syntax with invoke_cmd (works for ALL commands)\nresult = invoke_cmd(:factor, expr)           # (x-1)*(x+1)\nderiv = invoke_cmd(:diff, expr, x)           # 2*x\nintegral = invoke_cmd(:integrate, expr, x)   # x^3/3-x\n\n# Method syntax on GiacExpr (equivalent to invoke_cmd)\nresult = expr.factor()                     # (x-1)*(x+1)\nderiv = expr.diff(x)                       # 2*x\n\n# Chaining methods\n@giac_var a b\nresult = ((a+b)^2).expand()\nresult = ((a+b)^2).expand().factor()\n# or using |> operator\n(a+b)^2 |> expand\n(a+b)^2 |> expand |> factor\n\n# Natural Julia syntax with Base extensions\n@giac_var y\nsin(y)         # sin(y)\ncos(y)         # cos(y)\nexp(y)         # exp(y)\nlog(y)         # ln(y)\nsqrt(y)        # sqrt(y)\nsin(y) + cos(y)  # sin(y)+cos(y)","category":"section"},{"location":"api/giac_commands/#Commands-Submodule","page":"GIAC Commands","title":"Commands Submodule","text":"Giac.jl provides three ways to access GIAC's 2200+ commands via the Giac.Commands submodule:","category":"section"},{"location":"api/giac_commands/#1.-Qualified-Access","page":"GIAC Commands","title":"1. Qualified Access","text":"Access commands via Giac.Commands.commandname:\n\nusing Giac\n\n@giac_var x\nexpr = x^2 - 1\n\n# Access commands via Giac.Commands\nGiac.Commands.factor(expr)          # (x-1)*(x+1)\nGiac.Commands.expand((x+1)^2)  # x^2+2*x+1\nGiac.Commands.diff(expr, x)         # 2*x\nGiac.Commands.integrate(expr, x)    # x^3/3-x\nGiac.Commands.ifactor(120)  # 2^3*3*5","category":"section"},{"location":"api/giac_commands/#2.-Selective-Import","page":"GIAC Commands","title":"2. Selective Import","text":"Import specific commands you need:\n\nusing Giac\nusing Giac.Commands: factor, expand, diff, integrate\n\n@giac_var x\nexpr = x^2 - 1\n\n# Direct function syntax (no prefix needed)\nfactor(expr)              # (x-1)*(x+1)\nexpand((x+1)^2)  # x^2+2*x+1\ndiff(expr, x)             # 2*x\nintegrate(expr, x)        # x^3/3-x","category":"section"},{"location":"api/giac_commands/#3.-Full-Import-(Interactive-Use)","page":"GIAC Commands","title":"3. Full Import (Interactive Use)","text":"Import all ~2000+ commands for interactive exploration:\n\nusing Giac\nusing Giac.Commands  # Imports ALL exportable commands\n\n@giac_var x\nfactor(x^2 - 1)    # (x-1)*(x+1)\nifactor(120)       # 2^3*3*5\nnextprime(100)     # 101\nairy_ai(0)         # Airy function\n\n# Discover available commands\nexportable_commands()            # ~2000+ command names","category":"section"},{"location":"api/giac_commands/#invoke_cmd-for-ALL-Commands","page":"GIAC Commands","title":"invoke_cmd for ALL Commands","text":"For commands that conflict with Julia (like sin, cos, eval, det), use invoke_cmd:\n\nusing Giac\n\n@giac_var k n\n\n# Conflicting commands must use invoke_cmd\ninvoke_cmd(:eval, giac_eval(\"2+3\"))      # 5\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))      # 1/2\ninvoke_cmd(:det, giac_eval(\"[[1,2],[3,4]]\"))  # -2\ninvoke_cmd(:det, giac_eval(\"[[a,b],[c,d]]\"))  # a*d-b*c\ninvoke_cmd(:sum, k, k, giac_eval(\"1\"), n)  # 1/2*n^2+1/2*n\ninvoke_cmd(:product, k, k, giac_eval(\"1\"), n)  # n!\n\n# invoke_cmd works for ANY command\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))  # (x-1)*(x+1)","category":"section"},{"location":"api/giac_commands/#TempApi-Submodule","page":"GIAC Commands","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for some common symbolic computation operations. These are wrappers around the giac_* functions.\n\nusing Giac.TempApi: diff, expand, factor, integrate, limit, simplify, solve\n#Overlapping with Julia: eval, include, \n@giac_var x a b\ndiff(x^2, x)  # 2*x\nexpand((a+b)^2)  # a^2+b^2+2*a*b\nfactor(x^2-1)  # (x-1)*(x+1)\nintegrate(x^2, x)  # x^3/3\nintegrate(x^2, x, 0, 1)  # returns\n    // ∫ ~= 0.333333333333\n    GiacExpr: 1/3\nlimit(sin(x)/x, x, 0)  # 1\nsimplify(a + b - a)  # b\nsolve(x^2 - 1)\nsolve(x^2 - 1, x)  # list[-1,1]","category":"section"},{"location":"api/giac_commands/#Available-Functions","page":"GIAC Commands","title":"Available Functions","text":"TempApi Function Uses Description\ndiff(expr, var, n=1) invoke_cmd(:diff, ...) Differentiate expression\nintegrate(expr, var) invoke_cmd(:integrate, ...) Indefinite integral\nintegrate(expr, var, a, b) invoke_cmd(:integrate, ...) Definite integral\nlimit(expr, var, point) invoke_cmd(:limit, ...) Compute limit\nfactor(expr) invoke_cmd(:factor, ...) Factor polynomial\nexpand(expr) invoke_cmd(:expand, ...) Expand expression\nsimplify(expr) invoke_cmd(:simplify, ...) Simplify expression\nsolve(expr, var) invoke_cmd(:solve, ...) Solve equation","category":"section"},{"location":"api/giac_commands/#Usage-Patterns","page":"GIAC Commands","title":"Usage Patterns","text":"using Giac\n\n# 1. Selective import (recommended)\nusing Giac.TempApi: diff, factor, integrate, limit\n\n@giac_var x\nexpr = x^2 - 1\n\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nintegrate(expr, x)      # x^3/3-x\nlimit(sin(x)/x, x, 0)  # 1\nlimit(1/x, x, 0, 1)  # limit of 1/x at 0+ should be +infinity\nlimit(1/x, x, 0, -1)  # limit of 1/x at 0- should be -infinity\n\n# 2. Qualified access\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)","category":"section"},{"location":"api/giac_commands/#Comparison:-TempApi-vs-Commands-vs-invoke_cmd","page":"GIAC Commands","title":"Comparison: TempApi vs Commands vs invoke_cmd","text":"Pattern Import Usage Best For\nTempApi using Giac.TempApi diff(expr, x) Clean, simple names for common operations\nCommands using Giac.Commands diff(expr, x) Access to ALL 2200+ GIAC commands\ninvoke_cmd using Giac invoke_cmd(:diff, expr, x) Universal, works for ALL commands\n\nNote: Both TempApi and Commands export diff, factor, etc. Use selective imports to avoid conflicts, or choose one submodule based on your needs.","category":"section"},{"location":"api/giac_commands/#Commands-That-Conflict-with-Julia","page":"GIAC Commands","title":"Commands That Conflict with Julia","text":"Some GIAC commands have the same name as Julia built-ins. These are not exported from Giac.Commands to avoid shadowing Julia's functions:\n\nCategory Conflicting Commands\nKeywords if, for, while, end, in, or, and, not\nBuiltins eval, float, sum, prod, collect, abs, sign\nMath sin, cos, tan, exp, log, sqrt, gcd, lcm\nLinearAlgebra det, inv, trace, rank, transpose, norm\nStatistics mean, median, var, std\n\nUse invoke_cmd(:name, args...) for these commands. A warning is shown on first use to remind you:\n\ninvoke_cmd(:eval, giac_eval(\"2+3\"))\n# ┌ Warning: GIAC command 'eval' conflicts with Julia (builtin).\n# │ Use invoke_cmd(:eval, args...) to call it.\n\n","category":"section"},{"location":"developer/#Developer-Guide","page":"Overview","title":"Developer Guide","text":"Welcome to the Giac.jl Developer Guide. This documentation is intended for developers who want to contribute to Giac.jl or understand its internal architecture.","category":"section"},{"location":"developer/#Audience","page":"Overview","title":"Audience","text":"This guide is for:\n\nContributors wanting to add new mathematical functions\nMaintainers needing to understand the codebase\nAdvanced users curious about performance optimization","category":"section"},{"location":"developer/#Prerequisites","page":"Overview","title":"Prerequisites","text":"Before diving in, you should be familiar with:\n\nJulia programming fundamentals\nBasic understanding of C/C++ interop concepts\nGit version control","category":"section"},{"location":"developer/#Guide-Contents","page":"Overview","title":"Guide Contents","text":"","category":"section"},{"location":"developer/#[Package-Architecture](architecture.md)","page":"Overview","title":"Package Architecture","text":"Understand how Giac.jl is structured, including the purpose of each source file and how they interact.","category":"section"},{"location":"developer/#[Performance-Tiers](tier-system.md)","page":"Overview","title":"Performance Tiers","text":"Learn about the three-tier performance system that powers Giac.jl's function calls, from high-performance C++ wrappers to flexible string evaluation.","category":"section"},{"location":"developer/#[Adding-Functions](contributing.md)","page":"Overview","title":"Adding Functions","text":"Step-by-step guides for adding new mathematical functions at each tier level.","category":"section"},{"location":"developer/#[Memory-Management](memory.md)","page":"Overview","title":"Memory Management","text":"Understand how Giac.jl manages memory for C++ objects, including finalizers and thread safety.","category":"section"},{"location":"developer/#[Troubleshooting](troubleshooting.md)","page":"Overview","title":"Troubleshooting","text":"Common issues and debugging strategies for development work.","category":"section"},{"location":"developer/#Quick-Reference","page":"Overview","title":"Quick Reference","text":"Task Where to Start\nAdd a new high-performance function Performance Tiers then Adding Functions\nUnderstand the codebase Package Architecture\nDebug a crash or memory issue Memory Management then Troubleshooting\nFix a failing test Troubleshooting","category":"section"},{"location":"developer/#Getting-Started","page":"Overview","title":"Getting Started","text":"Clone the repository and set up your development environment\nRead the Package Architecture to understand the codebase structure\nFamiliarize yourself with the Performance Tiers system\nFollow the Adding Functions guide for your contribution","category":"section"},{"location":"developer/#Version-Compatibility","page":"Overview","title":"Version Compatibility","text":"This documentation applies to Giac.jl v0.x (current development version). API and internal structure may change before v1.0.\n\n","category":"section"},{"location":"api/core/#Core-API","page":"Core API","title":"Core API","text":"The main Giac module provides core types and functions for symbolic computation.","category":"section"},{"location":"api/core/#Types","page":"Core API","title":"Types","text":"","category":"section"},{"location":"api/core/#Expression-Evaluation","page":"Core API","title":"Expression Evaluation","text":"","category":"section"},{"location":"api/core/#Symbolic-Variables","page":"Core API","title":"Symbolic Variables","text":"","category":"section"},{"location":"api/core/#Function-Syntax-for-@giac_var","page":"Core API","title":"Function Syntax for @giac_var","text":"The @giac_var macro supports function notation for defining symbolic functions that depend on other variables. This is useful for differential equations and calculus with unknown functions.\n\nSingle-variable functions:\n\n@giac_var u(t)        # u is a GiacExpr representing \"u(t)\"\n@giac_var t           # t is the independent variable\ndiff(u, t)            # Symbolic derivative of u with respect to t\n\nMulti-variable functions:\n\n@giac_var f(x, y)     # f represents \"f(x,y)\"\n@giac_var x y\ndiff(f, x)            # Partial derivative ∂f/∂x\ndiff(f, y)            # Partial derivative ∂f/∂y\n\nMixed declarations:\n\n@giac_var t x y u(t) f(x, y)\n# Creates: t, x, y as simple variables\n#          u as \"u(t)\", f as \"f(x,y)\"\n\nCommon use case - ODEs:\n\n@giac_var t u(t)\n# Express ODE: u''(t) + u(t) = 0\n\nCommon use case - PDEs:\n\n@giac_var x y u(x, y)\n# Laplacian: ∂²u/∂x² + ∂²u/∂y²\nlaplacian = diff(diff(u, x), x) + diff(diff(u, y), y)","category":"section"},{"location":"api/core/#Callable-GiacExpr-(Function-Evaluation)","page":"Core API","title":"Callable GiacExpr (Function Evaluation)","text":"GiacExpr objects are callable, allowing natural function evaluation syntax like u(0). This is essential for specifying ODE initial conditions.\n\nBasic function evaluation:\n\n@giac_var u(t)\nu(0)           # Returns GiacExpr: \"u(0)\"\nu(1)           # Returns GiacExpr: \"u(1)\"\n\nODE initial conditions:\n\nusing Giac.Commands: diff, desolve\n@giac_var t u(t) tau U0\n\n# ODE: τu' + u = U₀ with u(0) = 1\node = tau * diff(u, t) + u ~ U0\ninitial = u(0) ~ 1\ndesolve([ode, initial], u)\n\nDerivative initial conditions (using D operator):\n\nusing Giac.Commands: desolve\n@giac_var t u(t)\n\n# First derivative at t=0: u'(0) = 1\nD(u)(0) ~ 1\n\n# Second derivative at t=0: u''(0) = 0\nD(u, 2)(0) ~ 0\n\n# Full example: solve u'' + u = 0 with u(0)=1, u'(0)=0\node = D(D(u)) + u ~ 0\nu0 = u(0) ~ 1\ndu0 = D(u)(0) ~ 0\ndesolve([ode, u0, du0], t, :u)  # Returns: cos(t)","category":"section"},{"location":"api/core/#D-Operator-(Derivative-Operator)","page":"Core API","title":"D Operator (Derivative Operator)","text":"The D operator follows SciML/ModelingToolkit conventions for expressing derivatives:\n\n@giac_var t u(t)\n\n# Create derivative expressions\nD(u)        # First derivative u'\nD(D(u))     # Second derivative u'' (chained)\nD(u, 2)     # Second derivative u'' (direct)\nD(u, 3)     # Third derivative u'''\n\n# Use in ODE equations\node = D(D(u)) + u ~ 0    # u'' + u = 0\n\n# Use in initial conditions (produces prime notation for GIAC)\nD(u)(0) ~ 1              # u'(0) = 1\nD(u, 2)(0) ~ 0           # u''(0) = 0\n\nComplete ODE examples:\n\nusing Giac\nusing Giac.Commands: desolve\n\n# 2nd order: u'' + u = 0, u(0)=1, u'(0)=0\n@giac_var t u(t)\nresult = desolve([D(D(u)) + u ~ 0, u(0) ~ 1, D(u)(0) ~ 0], t, :u)\n# Returns: cos(t)\n\n# 3rd order: y''' - y = 0, y(0)=1, y'(0)=1, y''(0)=1\n@giac_var t y(t)\nresult = desolve([D(y,3) - y ~ 0, y(0) ~ 1, D(y)(0) ~ 1, D(y,2)(0) ~ 1], t, :y)\n# Returns: exp(t)\n\nnote: desolve function argument\nWhen calling desolve, pass the function name as a Symbol (:u, :y) rather than the function expression (u, y), since GIAC expects just the name, not u(t).\n\nMulti-variable function evaluation:\n\n@giac_var f(x, y) a b\nf(0, 0)        # Returns \"f(0,0)\"\nf(a, b)        # Returns \"f(a,b)\"\nf(1, 2)        # Returns \"f(1,2)\"","category":"section"},{"location":"api/core/#Calculus-Operations","page":"Core API","title":"Calculus Operations","text":"Calculus functions are available via Giac.Commands or invoke_cmd:\n\nusing Giac\nusing Giac.Commands: diff, integrate, limit, series\n\n# Or use invoke_cmd\ninvoke_cmd(:diff, expr, x)\ninvoke_cmd(:integrate, expr, x)\ninvoke_cmd(:limit, expr, x, point)\ninvoke_cmd(:series, expr, x, point, order)","category":"section"},{"location":"api/core/#Algebraic-Operations","page":"Core API","title":"Algebraic Operations","text":"Algebra functions are available via Giac.Commands or invoke_cmd:\n\nusing Giac\nusing Giac.Commands: factor, expand, simplify, solve, gcd\n\n# Or use invoke_cmd\ninvoke_cmd(:factor, expr)\ninvoke_cmd(:expand, expr)\ninvoke_cmd(:simplify, expr)\ninvoke_cmd(:solve, expr, x)\ninvoke_cmd(:gcd, a, b)","category":"section"},{"location":"api/core/#Vector-Input-Support","page":"Core API","title":"Vector Input Support","text":"GIAC commands accept Julia vectors directly, enabling natural syntax for systems of equations and matrix operations:\n\nusing Giac\nusing Giac.Commands: solve, det_minor, inverse\n@giac_var x y z\n\n# Solve systems of equations with vector syntax\nsolve([x + y ~ 1, x - y ~ 0], [x, y])  # Returns [[1/2, 1/2]]\n\n# Three-variable system\nsolve([x + y + z ~ 6, x - y ~ 0, y + z ~ 4], [x, y, z])\n\n# Matrix operations with nested vectors\ndet_minor([[1, 2], [3, 4]])  # Returns -2\ninverse([[1, 2], [3, 4]])    # Returns inverse matrix\n\nSee GiacInput for the full list of supported input types.","category":"section"},{"location":"api/core/#Command-Discovery","page":"Core API","title":"Command Discovery","text":"note: Getting Help for Commands\nUse Julia's native help system after importing commands:using Giac.Commands: factor\n?factor  # Shows GIAC documentation","category":"section"},{"location":"api/core/#Command-Suggestions","page":"Core API","title":"Command Suggestions","text":"","category":"section"},{"location":"api/core/#Namespace-Management","page":"Core API","title":"Namespace Management","text":"","category":"section"},{"location":"api/core/#Substitution","page":"Core API","title":"Substitution","text":"See Variable Substitution for the substitute function documentation.","category":"section"},{"location":"api/core/#Type-Introspection","page":"Core API","title":"Type Introspection","text":"Functions for querying the type of GIAC expressions:","category":"section"},{"location":"api/core/#Type-Enum-(GenTypes)","page":"Core API","title":"Type Enum (GenTypes)","text":"GIAC expression types are available via the Giac.GenTypes module with the T enum:\n\nusing Giac.GenTypes: T, INT, DOUBLE, VECT, SYMB\n\ngiac_type(expr) == INT   # Check if expression is an integer\ngiac_type(expr) == VECT  # Check if expression is a vector\n\nEnum Value Int Description\nINT 0 Machine integer (Int64)\nDOUBLE 1 Double-precision float (Float64)\nZINT 2 Arbitrary-precision integer (BigInt)\nREAL 3 Extended precision real\nCPLX 4 Complex number\nPOLY 5 Polynomial\nIDNT 6 Identifier/variable\nVECT 7 Vector/list/sequence\nSYMB 8 Symbolic expression\nSPOL1 9 Sparse polynomial\nFRAC 10 Rational fraction\nEXT 11 Algebraic extension\nSTRNG 12 String value\nFUNC 13 Function reference\nROOT 14 Polynomial root\nMOD 15 Modular arithmetic\nUSER 16 User-defined type\nMAP 17 Map/dictionary\nEQW 18 Equation writer data\nGROB 19 Graphic object\nPOINTER 20 Raw pointer\nFLOAT 21 Float value","category":"section"},{"location":"api/core/#Component-Access","page":"Core API","title":"Component Access","text":"Functions for accessing components of compound types:","category":"section"},{"location":"api/core/#Conversion-Functions","page":"Core API","title":"Conversion Functions","text":"","category":"section"},{"location":"api/core/#Utility-Functions","page":"Core API","title":"Utility Functions","text":"","category":"section"},{"location":"api/core/#Core-Functions","page":"Core API","title":"Core Functions","text":"Function Description\ngiac_eval(expr) Evaluate a GIAC expression string\ninvoke_cmd(cmd, args...) Invoke any GIAC command dynamically\nis_stub_mode() Check if running without GIAC library\nto_julia(expr) Convert GiacExpr to Julia type\n\n","category":"section"},{"location":"api/core/#Giac","page":"Core API","title":"Giac","text":"Giac\n\nA Julia wrapper for the GIAC computer algebra system.\n\nProvides symbolic expression evaluation, calculus operations, polynomial manipulation, and linear algebra with a Julia-native API.\n\nCore Exports\n\nGiacExpr: Symbolic expression type\nGiacContext: Evaluation context\nGiacMatrix: Symbolic matrix type\nGiacError: Exception type for GIAC errors\ngiac_eval: Evaluate expression strings\n@giac_var: Create symbolic variables from Julia symbols\nto_julia: Convert GiacExpr to Julia types\ninvoke_cmd: Universal command invocation (works for ALL commands)\n\nCommand Access\n\nGIAC commands are available through the Giac.Commands submodule:\n\nusing Giac\n\n# Use invoke_cmd for any command (always available)\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))  # Works for conflicting commands too\n\n# Import commands selectively (recommended)\nusing Giac.Commands: factor, expand, diff\nfactor(giac_eval(\"x^2-1\"))\n\n# Or import all ~2000+ commands\nusing Giac.Commands\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))\n\nQuick Start\n\nusing Giac\n\n# Declare symbolic variables with @giac_var macro\n@giac_var x y\n\n# Build and manipulate expressions using Giac.Commands\nusing Giac.Commands: factor, expand, diff\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\nresult = factor(expr)   # (x+y)^2\n\n# Or use string-based evaluation directly\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\nSee also\n\nGiac.Commands: Submodule with all exportable commands\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"module"},{"location":"api/core/#Giac.GiacExpr","page":"Core API","title":"Giac.GiacExpr","text":"GiacExpr\n\nRepresents a symbolic mathematical expression from GIAC.\n\nWraps a pointer to a C++ giac::gen object. Memory is managed automatically via Julia's garbage collector and finalizers.\n\nExample\n\nexpr = giac_eval(\"x^2 + 1\")\nprintln(expr)  # x^2+1\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacContext","page":"Core API","title":"Giac.GiacContext","text":"GiacContext\n\nRepresents a GIAC evaluation context.\n\nManages configuration settings, variable bindings, and computation state. Thread-safe via internal locking.\n\nExample\n\nctx = GiacContext()\nresult = giac_eval(\"x + 1\", ctx)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacMatrix","page":"Core API","title":"Giac.GiacMatrix","text":"GiacMatrix\n\nRepresents a symbolic matrix with GiacExpr elements.\n\nFields\n\nptr::Ptr{Cvoid}: Pointer to GIAC matrix object\nrows::Int: Number of rows\ncols::Int: Number of columns\n\nExample\n\nA = GiacMatrix([[a, b], [c, d]])\ndet(A)  # a*d - b*c\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacError","page":"Core API","title":"Giac.GiacError","text":"GiacError <: Exception\n\nException type for errors from the GIAC library.\n\nFields\n\nmsg::String: Error message\ncategory::Symbol: Error category (:parse, :eval, :type, :memory)\n\nExample\n\nthrow(GiacError(\"Failed to parse expression\", :parse))\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.HelpResult","page":"Core API","title":"Giac.HelpResult","text":"HelpResult\n\nA structured representation of parsed GIAC command help information.\n\nFields\n\ncommand::String: The command name being documented\ndescription::String: Description text from GIAC help\nrelated::Vector{String}: List of related command names\nexamples::Vector{String}: List of individual example expressions\n\nExample\n\n# Use Julia's help system for interactive help:\n# ?factor (after using Giac.Commands: factor)\n\n# For programmatic access, use Giac.help (internal) or giac_help:\nresult = Giac.help(:factor)\nresult.command      # \"factor\"\nresult.description  # \"Factorizes a polynomial.\"\nresult.related      # [\"ifactor\", \"partfrac\", \"normal\"]\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\ngiac_help: Get raw help string\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacCommand","page":"Core API","title":"Giac.GiacCommand","text":"GiacCommand\n\nA callable wrapper for GIAC commands.\n\nThis type stores a command name and can be called with arguments to execute the underlying GIAC command. It provides a structured way to represent commands that can be passed around and invoked.\n\nFields\n\nname::Symbol: The GIAC command name (e.g., :factor, :diff)\n\nExample\n\n# Create a command and call it\nfactor_cmd = GiacCommand(:factor)\nexpr = giac_eval(\"x^2 - 1\")\nresult = factor_cmd(expr)  # Returns (x-1)*(x+1)\n\n# Equivalent to:\nresult = giac_cmd(:factor, expr)\n\nSee also\n\ninvoke_cmd: Direct command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacInput","page":"Core API","title":"Giac.GiacInput","text":"GiacInput\n\nUnion type representing all valid input types for GIAC command functions.\n\nThis type alias enables generated GIAC command functions to accept native Julia types in addition to GiacExpr, providing a more ergonomic API.\n\nSupported Types\n\nGiacExpr: Native GIAC expressions\nNumber: All Julia numeric types (Integer, AbstractFloat, Rational, Complex, etc.)\nString: String representations of GIAC expressions\nSymbol: Variable names (e.g., :x, :y)\nAbstractVector: Julia vectors/arrays (converted to GIAC list syntax)\n\nExamples\n\nusing Giac\nusing Giac.Commands\n\n# All of these work:\nifactor(1000)           # Integer\nifactor(giac_eval(\"1000\"))  # GiacExpr\nsimplify(\"x^2 - 1\")     # String\n\n# Vectors work directly (032-vector-input-solve):\n@giac x y\nsolve([x+y~0, x-y~2], [x,y])  # System of equations\ndet([[1,2],[3,4]])            # Nested vectors for matrices\n\nSee also\n\nGiacExpr: The primary GIAC expression type\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.giac_eval","page":"Core API","title":"Giac.giac_eval","text":"giac_eval(expr::String, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nEvaluate a GIAC expression string and return a GiacExpr.\n\nArguments\n\nexpr::String: A string containing a valid GIAC expression\nctx::GiacContext: Optional evaluation context (uses DEFAULT_CONTEXT if not provided)\n\nReturns\n\nGiacExpr: The evaluated expression\n\nThrows\n\nGiacError(:parse): If the expression cannot be parsed\nGiacError(:eval): If evaluation fails\n\nExample\n\nresult = giac_eval(\"2 + 3\")\nprintln(result)  # 5\n\n# Symbolic computation\nexpr = giac_eval(\"diff(x^2, x)\")\nprintln(expr)  # 2*x\n\n\n\n\n\ngiac_eval(expr::GiacExpr, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nRe-evaluate an existing GiacExpr in a context (useful after variable assignments).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.@giac_var","page":"Core API","title":"Giac.@giac_var","text":"@giac_var sym...\n@giac_var func(args...)\n\nCreate symbolic variables or function expressions from Julia symbols.\n\nCreates GiacExpr variables in the calling scope by internally calling giac_eval with the stringified expression. This provides a cleaner syntax for variable declaration similar to @variables in Symbolics.jl.\n\nArguments\n\nsym...: Symbol names to create as simple variables\nfunc(args...): Function syntax to create function expressions\n\nExamples\n\nSingle variable:\n\n@giac_var x           # Creates x as a GiacExpr\nstring(x)             # \"x\"\nx isa GiacExpr        # true\n\nMultiple variables:\n\n@giac_var x y z       # Creates x, y, z as GiacExpr variables\n\nSingle-variable function (NEW):\n\n@giac_var u(t)        # Creates u as GiacExpr representing \"u(t)\"\nstring(u)             # \"u(t)\"\n\n# Use with differentiation\n@giac_var t\ndiff(u, t)            # Returns diff(u(t),t)\n\nMulti-variable function (NEW):\n\n@giac_var f(x, y)     # Creates f as GiacExpr representing \"f(x,y)\"\nstring(f)             # \"f(x,y)\"\n\nMixed declarations (NEW):\n\n@giac_var t x y u(t) f(x, y)\n# Creates: t, x, y as simple variables\n#          u as \"u(t)\", f as \"f(x,y)\"\n\nUsage\n\nusing Giac\n\n@giac_var x y\nexpr = giac_eval(\"x^2 + y^2\")\nresult = giac_diff(expr, x)  # 2*x\n\n# For ODEs\n@giac_var t u(t)\n# u''(t) + u(t) = 0\n\n# Callable syntax for initial conditions (034-callable-giacexpr)\n@giac_var t u(t) tau U0\nu(0)                    # Returns GiacExpr: \"u(0)\"\nu(0) ~ 1                # Initial condition: u(0) = 1\ndiff(u, t)(0) ~ 0       # Derivative condition: u'(0) = 0\ndesolve([tau * diff(u, t) + u ~ U0, u(0) ~ 1], u)\n\nSee also\n\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.@giac_several_vars","page":"Core API","title":"Giac.@giac_several_vars","text":"@giac_several_vars base dims...\n\nCreate multiple indexed symbolic variables for N-dimensional tensors.\n\nThis macro generates multiple GiacExpr variables in the calling scope with names formed from a base name and indices. It supports any number of dimensions and returns a tuple of all created variables.\n\nArguments\n\nbase: Symbol - The base name for variables (e.g., a, coeff, α)\ndims...: Integer literals or range expressions - Dimensions of the tensor (1 or more)\nInteger n: Creates indices 1:n (backward compatible)\nUnitRange a:b: Creates indices from a to b\nStepRange a:s:b: Creates indices from a to b with step s\n\nReturns\n\nTuple{GiacExpr...}: A tuple containing all created variables in lexicographic order\n\nNaming Convention\n\nIf all indices are in 0-9: indices are concatenated directly (e.g., a123)\nIf any index > 9: underscore separators are used (e.g., a_1_10)\nNegative indices: m prefix for minus (e.g., -1 → m1, so c_m1)\n\nExamples\n\n1D vector:\n\n@giac_several_vars a 3\n# Creates: a1, a2, a3 and returns (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# Capture return value\nvars = @giac_several_vars c 4\nlength(vars)  # 4\n\n2D matrix:\n\nresult = @giac_several_vars m 2 3\n# Creates: m11, m12, m13, m21, m22, m23\n# Returns: (m11, m12, m13, m21, m22, m23)\nlength(result)  # 6\n\n3D tensor:\n\n@giac_several_vars t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n# Returns tuple of 8 variables\n\nLarge dimensions (separator used):\n\n@giac_several_vars b 2 10 3\n# Creates: b_1_1_1, b_1_1_2, ..., b_2_10_3\n\nUnicode base names:\n\n@giac_several_vars α 2\n# Creates: α1, α2\n\n0-based indexing with UnitRange:\n\n@giac_several_vars psi 0:2\n# Creates: psi0, psi1, psi2 and returns (psi0, psi1, psi2)\n\n2D with custom ranges:\n\n@giac_several_vars T 0:1 0:2\n# Creates: T00, T01, T02, T10, T11, T12\n\nNegative indices:\n\n@giac_several_vars c -1:1\n# Creates: c_m1, c_0, c_1 (m = minus, to avoid GIAC parsing issues)\n\nStepRange:\n\n@giac_several_vars q 0:2:4\n# Creates: q0, q2, q4\n\nMixed arguments (integer and range):\n\n@giac_several_vars mixed 2 0:1\n# First dim: 1:2, second dim: 0:1\n# Creates: mixed10, mixed11, mixed20, mixed21\n\nEdge cases:\n\n@giac_several_vars x 0     # Returns empty tuple ()\n@giac_several_vars y 1     # Creates y1, returns (y1,)\n@giac_several_vars z 2 0   # Returns empty tuple (0 in any dim)\n@giac_several_vars e 5:4   # Returns empty tuple (empty range)\n\nSee also\n\n@giac_var: For creating single symbolic variables\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.list_commands","page":"Core API","title":"Giac.list_commands","text":"list_commands()\n\nReturn a vector of all available GIAC command names.\n\nExample\n\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))\nprintln(\"First 10: \", cmds[1:10])\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help_count","page":"Core API","title":"Giac.help_count","text":"help_count()\n\nReturn the number of commands in the GIAC help database.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands","page":"Core API","title":"Giac.search_commands","text":"search_commands(pattern::String) -> Vector{Symbol}\n\nSearch for commands matching a string prefix.\n\nArguments\n\npattern::String: Prefix to match\n\nReturns\n\nVector{Symbol}: List of matching command names (as Symbols), sorted alphabetically\n\nExample\n\nsearch_commands(\"sin\")  # Returns [:sin, :sinc, :sincos, :sinh, ...]\n\n\n\n\n\nsearch_commands(pattern::Regex) -> Vector{Symbol}\n\nSearch for commands matching a regular expression.\n\nArguments\n\npattern::Regex: Regular expression to match\n\nReturns\n\nVector{Symbol}: List of matching command names (as Symbols), sorted alphabetically\n\nExample\n\nsearch_commands(r\"^a.*n$\")  # Returns commands starting with 'a' and ending with 'n'\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.commands_in_category","page":"Core API","title":"Giac.commands_in_category","text":"commands_in_category(category::Symbol) -> Vector{Symbol}\n\nGet all commands in a specific category.\n\nArguments\n\ncategory::Symbol: Category name (e.g., :trigonometry, :algebra)\n\nReturns\n\nVector{Symbol}: List of command names (as Symbols) in the category, sorted alphabetically\n\nThrows\n\nArgumentError: If the category does not exist\n\nExample\n\ntrig = commands_in_category(:trigonometry)\n# [:acos, :asin, :atan, :cos, :sin, :tan, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.command_info","page":"Core API","title":"Giac.command_info","text":"command_info(cmd::Symbol) -> Union{CommandInfo, Nothing}\n\nGet metadata about a specific command.\n\nArguments\n\ncmd::Symbol: Command name\n\nReturns\n\nCommandInfo: Metadata about the command\nnothing: If the command is not found\n\nExample\n\ninfo = command_info(:factor)\nif info !== nothing\n    println(info.name)      # \"factor\"\n    println(info.category)  # :algebra\nend\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_categories","page":"Core API","title":"Giac.list_categories","text":"list_categories() -> Vector{Symbol}\n\nList all available command categories.\n\nReturns\n\nVector{Symbol}: Category names, sorted alphabetically\n\nExample\n\ncats = list_categories()\n# [:algebra, :calculus, :combinatorics, :geometry, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_help","page":"Core API","title":"Giac.giac_help","text":"giac_help(cmd::Union{Symbol, String}) -> String\n\nGet GIAC help text for a command.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nString: Help text from GIAC, or empty string if not found\n\nExample\n\nhelp = giac_help(:factor)\nprintln(help)  # \"factor(Expr) - Factor a polynomial...\"\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.suggest_commands","page":"Core API","title":"Giac.suggest_commands","text":"suggest_commands(input::Union{Symbol, String}; n::Int=get_suggestion_count()) -> Vector{Symbol}\n\nFind commands similar to the given input using edit distance.\n\nThis function helps users recover from typos by suggesting valid GIAC commands that are similar to the input.\n\nArguments\n\ninput: The mistyped command name (Symbol or String)\nn: Maximum number of suggestions to return (default: get_suggestion_count())\n\nReturns\n\nVector{Symbol}: Similar command names, sorted by edit distance (ascending), then alphabetically. Returns empty vector if no similar commands found.\n\nExample\n\nsuggest_commands(:factr)\n# [:factor, :cfactor, :ifactor, ...]\n\nsuggest_commands(\"integrat\", n=2)\n# [:integrate, ...]\n\nsuggest_commands(:factor)  # Exact match\n# []  (empty, no suggestions needed)\n\nSee also\n\nsuggest_commands_with_distances: Also returns edit distances (internal function)\nset_suggestion_count: Configure default suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.set_suggestion_count","page":"Core API","title":"Giac.set_suggestion_count","text":"set_suggestion_count(n::Int) -> Nothing\n\nSet the default number of command suggestions.\n\nArguments\n\nn: Number of suggestions (must be > 0, otherwise resets to default 4)\n\nExample\n\nset_suggestion_count(6)\nget_suggestion_count()  # 6\n\nset_suggestion_count(-1)  # Invalid, resets to default\nget_suggestion_count()  # 4\n\nSee also\n\nget_suggestion_count: Get the current count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.get_suggestion_count","page":"Core API","title":"Giac.get_suggestion_count","text":"get_suggestion_count() -> Int\n\nGet the current default number of command suggestions.\n\nReturns\n\nInt: Current suggestion count (default: 4)\n\nExample\n\nget_suggestion_count()  # 4 (default)\n\nSee also\n\nset_suggestion_count: Set the suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands_by_description","page":"Core API","title":"Giac.search_commands_by_description","text":"search_commands_by_description(query; n=20) -> Vector{Symbol}\n\nSearch for GIAC commands whose help text contains the given keyword.\n\nUnlike search_commands which matches command names, this function searches the description and example text of each command's help documentation.\n\nArguments\n\nquery::Union{String, Symbol}: Search term to find in help text\nn::Int=20: Maximum number of results to return\n\nReturns\n\nVector{Symbol}: Matching command names (as Symbols), sorted by relevance\n\nExample\n\n# Find commands related to factorization\nsearch_commands_by_description(\"factor\")\n# Returns: [:factor, :ifactor, :cfactor, ...]\n\n# Search for matrix operations\nsearch_commands_by_description(\"matrix\", n=10)\n\nSee also\n\nsearch_commands: Search by command name pattern\ngiac_help: Get raw help for a specific command\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.JULIA_CONFLICTS","page":"Core API","title":"Giac.JULIA_CONFLICTS","text":"JULIA_CONFLICTS\n\nSet of GIAC command names (as Symbols) that conflict with Julia keywords, builtins, or standard library functions. These commands cannot be safely exported as top-level functions but remain accessible via invoke_cmd(:name, args...).\n\nConflict Categories\n\nJulia keywords: if, for, while, end, in, or, and, etc.\nBase builtins: eval, float, sum, prod, div, mod, abs, etc.\nBase math functions: sin, cos, tan, exp, log, sqrt, etc.\nLinearAlgebra: det, inv, trace, rank, transpose, etc.\n\nExample\n\n:eval in JULIA_CONFLICTS  # true\n:factor in JULIA_CONFLICTS  # false\n\n# Conflicting commands still work via invoke_cmd\ninvoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\nexportable_commands: Commands safe to export\nconflict_reason: Get the conflict category for a command\n\n\n\n\n\n","category":"constant"},{"location":"api/core/#Giac.exportable_commands","page":"Core API","title":"Giac.exportable_commands","text":"exportable_commands() -> Vector{Symbol}\n\nGet a list of GIAC commands that can be safely exported without conflicting with Julia keywords, builtins, or standard library functions.\n\nThis function filters the complete command list to include only commands that:\n\nStart with an ASCII letter (a-z, A-Z)\nDo not conflict with Julia (not in JULIA_CONFLICTS)\n\nReturns\n\nVector{Symbol}: Sorted list of exportable command names (as Symbols)\n\nExample\n\ncmds = exportable_commands()\nlength(cmds)        # ~2000+\n:factor in cmds     # true\n:eval in cmds       # false (conflicts with Julia)\n:sin in cmds        # false (conflicts with Base.sin)\nissorted(cmds, by=string)  # true\n\nSee also\n\navailable_commands: All commands starting with ASCII letters\nJULIA_CONFLICTS: Commands that conflict with Julia\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_valid_command","page":"Core API","title":"Giac.is_valid_command","text":"is_valid_command(name::Union{Symbol, String}) -> Bool\n\nCheck if a command name is a valid GIAC command.\n\nArguments\n\nname: Command name as Symbol or String\n\nReturns\n\ntrue if the command exists in GIAC's command list\nfalse otherwise\n\nExample\n\nis_valid_command(:factor)      # true\nis_valid_command(\"integrate\")  # true\nis_valid_command(:notacommand) # false\n\nSee also\n\nlist_commands: Get all command names\nsuggest_commands: Get suggestions for misspelled commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.conflict_reason","page":"Core API","title":"Giac.conflict_reason","text":"conflict_reason(cmd::Union{Symbol, String}) -> Union{Symbol, Nothing}\n\nGet the reason why a GIAC command conflicts with Julia.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\n:keyword - Conflicts with Julia keyword (if, for, while, etc.)\n:builtin - Conflicts with Julia builtin function (eval, float, etc.)\n:base_math - Conflicts with Base math function (sin, cos, exp, etc.)\n:linear_algebra - Conflicts with LinearAlgebra (det, inv, trace, etc.)\n:statistics - Conflicts with Statistics (mean, median, var, etc.)\nnothing - No conflict\n\nExample\n\nconflict_reason(:eval)    # :builtin\nconflict_reason(:sin)     # :base_math\nconflict_reason(:det)     # :linear_algebra\nconflict_reason(:for)     # :keyword\nconflict_reason(:factor)  # nothing\n\nSee also\n\nJULIA_CONFLICTS: Set of all conflicting commands\nexportable_commands: Commands safe to export\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.available_commands","page":"Core API","title":"Giac.available_commands","text":"available_commands()\n\nReturn a sorted vector of all available GIAC command names that start with an ASCII letter (a-z, A-Z).\n\nThis function provides programmatic discovery of available commands. It filters out operators, keywords, and commands starting with non-ASCII characters.\n\nReturns\n\nVector{String}: Sorted list of command names starting with ASCII letters\n\nExample\n\n# List all available commands\ncmds = available_commands()\nprintln(\"Found $(length(cmds)) commands\")  # ~2100+\n\n# Check if a command exists\n\"factor\" in cmds  # true\n\"+\" in cmds       # false (operator)\n\n# Compare with exportable commands\nexportable = exportable_commands()\nlength(exportable)  # ~2000+ (excludes Julia conflicts)\n\nAccessing Commands\n\ninvoke_cmd (all commands): Universal access, always available\ninvoke_cmd(:eval, expr)  # Works for conflicting commands too\ninvoke_cmd(:factor, expr)\nSelective import: Import specific commands from Giac.Commands\nusing Giac.Commands: factor, expand\nfactor(expr)  # Works directly\nFull import: Import all ~2000+ commands\nusing Giac.Commands\nfactor(expr)   # Works directly\nifactor(expr)  # All commands available\n\nSee also\n\nexportable_commands: Commands safe to export (no Julia conflicts)\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all exportable commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.reset_conflict_warnings!","page":"Core API","title":"Giac.reset_conflict_warnings!","text":"reset_conflict_warnings!()\n\nReset the conflict warning tracker, allowing warnings to be shown again.\n\nThis is primarily useful for testing.\n\nExample\n\ngiac_cmd(:eval, expr)  # Shows warning\ngiac_cmd(:eval, expr)  # No warning (already shown)\nreset_conflict_warnings!()\ngiac_cmd(:eval, expr)  # Shows warning again\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_type","page":"Core API","title":"Giac.giac_type","text":"giac_type(g::GiacExpr) -> T\n\nReturn the GIAC type enum value for the expression.\n\nReturns one of the T enum values from Giac.GenTypes: INT, DOUBLE, ZINT, REAL, CPLX, VECT, SYMB, IDNT, STRNG, FRAC, FUNC, etc.\n\nExample\n\nusing Giac.GenTypes: T, INT, VECT\n\ng = giac_eval(\"42\")\ngiac_type(g) == INT  # true\n\ng = giac_eval(\"[1, 2, 3]\")\ngiac_type(g) == VECT  # true\n\nSee also: Giac.GenTypes module for type enum values\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.subtype","page":"Core API","title":"Giac.subtype","text":"subtype(g::GiacExpr) -> Int32\n\nReturn the subtype for vector expressions.\n\nFor vectors, returns 1 (sequence), 2 (set), 3 (list), or 0 for standard vectors.\n\nExample\n\ng = giac_eval(\"{1, 2, 3}\")  # set\nsubtype(g) == 2  # true (set subtype)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_integer","page":"Core API","title":"Giac.is_integer","text":"is_integer(g::GiacExpr) -> Bool\n\nReturn true if the expression is an integer (INT or ZINT).\n\nExample\n\nis_integer(giac_eval(\"42\"))      # true\nis_integer(giac_eval(\"3.14\"))    # false\nis_integer(giac_eval(\"x\"))       # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_numeric","page":"Core API","title":"Giac.is_numeric","text":"is_numeric(g::GiacExpr) -> Bool\n\nReturn true if the expression is a numeric value (INT, DOUBLE, ZINT, or REAL).\n\nExample\n\nis_numeric(giac_eval(\"42\"))      # true\nis_numeric(giac_eval(\"3.14\"))    # true\nis_numeric(giac_eval(\"x\"))       # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_vector","page":"Core API","title":"Giac.is_vector","text":"is_vector(g::GiacExpr) -> Bool\n\nReturn true if the expression is a vector/list/sequence (VECT).\n\nExample\n\nis_vector(giac_eval(\"[1, 2, 3]\"))  # true\nis_vector(giac_eval(\"42\"))         # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_symbolic","page":"Core API","title":"Giac.is_symbolic","text":"is_symbolic(g::GiacExpr) -> Bool\n\nReturn true if the expression is symbolic (SYMB).\n\nExample\n\nis_symbolic(giac_eval(\"sin(x)\"))  # true\nis_symbolic(giac_eval(\"x + 1\"))   # true\nis_symbolic(giac_eval(\"42\"))      # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_identifier","page":"Core API","title":"Giac.is_identifier","text":"is_identifier(g::GiacExpr) -> Bool\n\nReturn true if the expression is an identifier/variable (IDNT).\n\nExample\n\nis_identifier(giac_eval(\"x\"))       # true\nis_identifier(giac_eval(\"x + 1\"))   # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_fraction","page":"Core API","title":"Giac.is_fraction","text":"is_fraction(g::GiacExpr) -> Bool\n\nReturn true if the expression is a rational fraction (FRAC).\n\nExample\n\nis_fraction(giac_eval(\"3/4\"))    # true\nis_fraction(giac_eval(\"42\"))     # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_complex","page":"Core API","title":"Giac.is_complex","text":"is_complex(g::GiacExpr) -> Bool\n\nReturn true if the expression is a complex number (CPLX).\n\nExample\n\nis_complex(giac_eval(\"3+4*i\"))   # true\nis_complex(giac_eval(\"42\"))      # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_string","page":"Core API","title":"Giac.is_string","text":"is_string(g::GiacExpr) -> Bool\n\nReturn true if the expression is a string (STRNG).\n\nExample\n\nis_string(giac_eval(\"\"hello\"\"))  # true\nis_string(giac_eval(\"42\"))         # false\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_boolean","page":"Core API","title":"Giac.is_boolean","text":"is_boolean(g::GiacExpr) -> Bool\n\nReturn true if the expression represents a boolean value (true or false).\n\nNote: GIAC represents booleans as integers internally (type INT), but displays them as \"true\" or \"false\". This function detects boolean values by checking the string representation.\n\nExample\n\nis_boolean(giac_eval(\"true\"))      # true\nis_boolean(giac_eval(\"false\"))     # true\nis_boolean(giac_eval(\"1==1\"))      # true (comparison returns boolean)\nis_boolean(giac_eval(\"1\"))         # false (integer, not boolean)\nis_boolean(giac_eval(\"0\"))         # false (integer, not boolean)\n\nSee also\n\nto_julia, is_integer\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.GenTypes","page":"Core API","title":"Giac.GenTypes","text":"GenTypes\n\nA submodule containing the T enum for GIAC expression type constants.\n\nThis module provides type-safe, scoped access to GIAC's internal type system, matching the C++ gen_unary_types enum exactly.\n\nUsage\n\nusing Giac.GenTypes: T, INT, VECT, SYMB\n\n# Access type constants as module values\nINT     # Machine integer (0)\nDOUBLE  # Double-precision float (1)\nVECT    # Vector/list/sequence (7)\nSYMB    # Symbolic expression (8)\n\n# Or use the T type for construction from integers\nT(0)    # INT\nT(7)    # VECT\n\n# Use with giac_type()\nexpr = giac_eval(\"42\")\ngiac_type(expr) == INT  # true\n\n# Convert to integer\nInt(VECT)  # 7\n\nType Values\n\nThe enum values match the C++ gen_unary_types enum:\n\nTypes 0-1 and 20-21 are \"immediate\" (no memory allocation)\nTypes 2-19 are \"pointer\" types (require memory allocation)\n\nSee also: Giac.giac_type\n\n\n\n\n\n","category":"module"},{"location":"api/core/#Giac.GenTypes.T","page":"Core API","title":"Giac.GenTypes.T","text":"T\n\nEnum representing GIAC expression types, matching C++ gen_unary_types.\n\nValues\n\nValue Int C++ Name Description\nT.INT 0 _INT_ Machine integer\nT.DOUBLE 1 _DOUBLE_ Double-precision float\nT.ZINT 2 _ZINT Arbitrary precision integer\nT.REAL 3 _REAL Extended precision real\nT.CPLX 4 _CPLX Complex number\nT.POLY 5 _POLY Polynomial\nT.IDNT 6 _IDNT Identifier/variable\nT.VECT 7 _VECT Vector/list/sequence\nT.SYMB 8 _SYMB Symbolic expression\nT.SPOL1 9 _SPOL1 Sparse polynomial\nT.FRAC 10 _FRAC Rational fraction\nT.EXT 11 _EXT Algebraic extension\nT.STRNG 12 _STRNG String\nT.FUNC 13 _FUNC Function reference\nT.ROOT 14 _ROOT Root of polynomial\nT.MOD 15 _MOD Modular arithmetic\nT.USER 16 _USER User-defined type\nT.MAP 17 _MAP Map/dictionary\nT.EQW 18 _EQW Equation writer data\nT.GROB 19 _GROB Graphic object\nT.POINTER 20 _POINTER_ Raw pointer\nT.FLOAT 21 _FLOAT_ Float (immediate)\n\nExamples\n\nusing Giac.GenTypes: T, INT, VECT, FLOAT\n\n# Check integer value\nInt(INT) == 0     # true\nInt(VECT) == 7    # true\nInt(FLOAT) == 21  # true\n\n# Create from integer\nT(0) == INT       # true\nT(7) == VECT      # true\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.numer","page":"Core API","title":"Giac.numer","text":"numer(g::GiacExpr) -> GiacExpr\n\nReturn the numerator of a fraction, or the value itself for integers.\n\nExample\n\nnumer(giac_eval(\"3/4\"))   # GiacExpr representing 3\nnumer(giac_eval(\"5\"))     # GiacExpr representing 5\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.denom","page":"Core API","title":"Giac.denom","text":"denom(g::GiacExpr) -> GiacExpr\n\nReturn the denominator of a fraction, or 1 for integers.\n\nExample\n\ndenom(giac_eval(\"3/4\"))   # GiacExpr representing 4\ndenom(giac_eval(\"5\"))     # GiacExpr representing 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.real_part","page":"Core API","title":"Giac.real_part","text":"real_part(g::GiacExpr) -> GiacExpr\n\nReturn the real part of a complex number, or the value itself for non-complex.\n\nExample\n\nreal_part(giac_eval(\"3+4*i\"))  # GiacExpr representing 3\nreal_part(giac_eval(\"5\"))      # GiacExpr representing 5\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.imag_part","page":"Core API","title":"Giac.imag_part","text":"imag_part(g::GiacExpr) -> GiacExpr\n\nReturn the imaginary part of a complex number, or 0 for non-complex.\n\nExample\n\nimag_part(giac_eval(\"3+4*i\"))  # GiacExpr representing 4\nimag_part(giac_eval(\"5\"))      # GiacExpr representing 0\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.symb_funcname","page":"Core API","title":"Giac.symb_funcname","text":"symb_funcname(g::GiacExpr) -> String\n\nReturn the function name of a symbolic expression.\n\nExample\n\nsymb_funcname(giac_eval(\"sin(x)\"))  # \"sin\"\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.symb_argument","page":"Core API","title":"Giac.symb_argument","text":"symb_argument(g::GiacExpr) -> GiacExpr\n\nReturn the argument (operand) of a symbolic expression.\n\nExample\n\narg = symb_argument(giac_eval(\"sin(x)\"))  # GiacExpr representing x\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_julia","page":"Core API","title":"Giac.to_julia","text":"to_julia(m::GiacMatrix) -> Matrix\n\nConvert a GiacMatrix to a Julia Matrix with appropriate element type narrowing.\n\nBoolean elements are converted to Bool, integers to Int64, etc. The resulting matrix type is narrowed to the most specific common type.\n\nExample\n\n# Integer matrix\ng = giac_eval(\"[[1, 2], [3, 4]]\")\nm = GiacMatrix(g)\nto_julia(m)  # 2×2 Matrix{Int64}\n\n# Boolean matrix\ng = giac_eval(\"[[true, false], [false, true]]\")\nm = GiacMatrix(g)\nto_julia(m)  # 2×2 Matrix{Bool}\n\nSee also\n\nto_julia, GiacMatrix\n\n\n\n\n\nto_julia(g::GiacExpr) -> Union{Bool, Int64, BigInt, Float64, Rational, Complex, Vector, String, GiacExpr}\n\nRecursively convert a GIAC expression to native Julia types.\n\nConversion Rules\n\nGIAC Type Julia Return Type\nBoolean (true/false) Bool\nINT Int64\nZINT BigInt\nDOUBLE, REAL Float64\nFRAC Rational{Int64} or Rational{BigInt}\nCPLX Complex{T} (T promoted from parts)\nVECT Vector{T} (T narrowed from elements)\nSTRNG String\nSYMB, IDNT, FUNC GiacExpr (unchanged)\n\nNote: GIAC represents booleans as integers internally, but to_julia detects them via their string representation (\"true\"/\"false\") and returns Julia Bool values.\n\nExamples\n\n# Boolean conversion\nto_julia(giac_eval(\"true\"))      # true::Bool\nto_julia(giac_eval(\"false\"))     # false::Bool\nto_julia(giac_eval(\"1==1\"))      # true::Bool (comparison result)\n\n# Integer conversion (distinct from booleans)\nto_julia(giac_eval(\"1\"))         # Int64(1)\nto_julia(giac_eval(\"0\"))         # Int64(0)\nto_julia(giac_eval(\"42\"))        # Int64(42)\n\n# Float conversion\nto_julia(giac_eval(\"3.14\"))      # Float64(3.14)\n\n# Rational conversion\nto_julia(giac_eval(\"3/4\"))       # 3//4\n\n# Complex conversion\nto_julia(giac_eval(\"3+4*i\"))     # 3.0 + 4.0im\n\n# Vector conversion with type narrowing\nto_julia(giac_eval(\"[1, 2, 3]\")) # [1, 2, 3]::Vector{Int64}\n\n# Symbolic expressions are unchanged\nto_julia(giac_eval(\"x + 1\"))     # GiacExpr (unchanged)\n\nSee also\n\ngiac_type, is_boolean, is_numeric, is_vector\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_giac","page":"Core API","title":"Giac.to_giac","text":"to_giac(expr)\n\nConvert an expression to GiacExpr. Extended by GiacSymbolicsExt for Symbolics.Num types.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_symbolics","page":"Core API","title":"Giac.to_symbolics","text":"to_symbolics(expr::GiacExpr)\n\nConvert a GiacExpr to a Symbolics.jl expression. Extended by GiacSymbolicsExt.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_stub_mode","page":"Core API","title":"Giac.is_stub_mode","text":"is_stub_mode()\n\nCheck if the wrapper is running in stub mode (without the actual library).\n\n\n\n\n\n","category":"function"},{"location":"physics/mechanics/#Classical-Mechanics","page":"Mechanics","title":"Classical Mechanics","text":"Giac.jl enables symbolic solutions to classical mechanics problems, including kinematics, dynamics, oscillations, and energy conservation.","category":"section"},{"location":"physics/mechanics/#Setup","page":"Mechanics","title":"Setup","text":"using Giac\nusing Giac.Commands: diff, integrate, solve, desolve\n\n@giac_var t x v a m F g","category":"section"},{"location":"physics/mechanics/#Kinematics","page":"Mechanics","title":"Kinematics","text":"","category":"section"},{"location":"physics/mechanics/#Position,-Velocity,-and-Acceleration","page":"Mechanics","title":"Position, Velocity, and Acceleration","text":"The fundamental relationships between position, velocity, and acceleration can be computed symbolically using differentiation and integration.\n\nVelocity from Position:\n\n@giac_var t\n\n# Position function: x(t) = t²\nx_t = t^2\n\n# Velocity is the derivative of position\nv_t = diff(x_t, t)\n# Output: 2*t\n\n# Acceleration is the derivative of velocity\na_t = diff(v_t, t)\n# Output: 2\n\nPosition from Acceleration:\n\n@giac_var t\n\n# Constant acceleration (create as GiacExpr)\na_t = 2 + 0*t\n\n# Integrate to get velocity\nv_t = integrate(a_t, t)\n# Output: 2*t (plus constant of integration)\n\n# Integrate again to get position\nx_t = integrate(2*t, t)\n# Output: t^2","category":"section"},{"location":"physics/mechanics/#Projectile-Motion","page":"Mechanics","title":"Projectile Motion","text":"Model projectile motion with initial velocity and gravitational acceleration:\n\n@giac_var t g v0 theta\n\n# Horizontal motion: x(t) = v0*cos(theta)*t\nx_t = v0 * cos(theta) * t\n\n# Vertical motion: y(t) = v0*sin(theta)*t - g*t²/2\ny_t = v0 * sin(theta) * t - g * t^2 / 2\n\n# Vertical velocity\nvy_t = diff(y_t, t)\n# Output: v0*sin(theta) - g*t\n\n# Time of flight (when y = 0, t > 0)\nsolve(y_t ~ 0, t)\n# Gives t = 0 and t = 2*v0*sin(theta)/g","category":"section"},{"location":"physics/mechanics/#Uniformly-Accelerated-Motion","page":"Mechanics","title":"Uniformly Accelerated Motion","text":"@giac_var v0 a t s\n\n# SUVAT equations can be derived symbolically\n# v = v0 + at\n# s = v0*t + (1/2)*a*t²\n# v² = v0² + 2*a*s\n\n# Example: Find displacement given v0, a, t\ns_expr = v0 * t + a * t^2 / 2\nexpand(s_expr)","category":"section"},{"location":"physics/mechanics/#Dynamics","page":"Mechanics","title":"Dynamics","text":"","category":"section"},{"location":"physics/mechanics/#Newton's-Second-Law","page":"Mechanics","title":"Newton's Second Law","text":"Solve force equations symbolically:\n\n@giac_var F m a\n\n# Newton's second law: F = ma\n# Solve for acceleration\nsolve(F ~ m * a, a)\n# Output: [F/m]\n\n# Solve for mass\nsolve(F ~ m * a, m)\n# Output: [F/a]","category":"section"},{"location":"physics/mechanics/#Inclined-Plane-Problems","page":"Mechanics","title":"Inclined Plane Problems","text":"@giac_var m g theta a mu N\n\n# Forces on an inclined plane\n# Normal force: N = mg*cos(theta)\n# Friction: f = mu*N\n\n# Net force down the plane (no friction)\nF_net = m * g * sin(theta)\n\n# Acceleration down the plane\na_down = diff(F_net / m, theta) * 0 + g * sin(theta)","category":"section"},{"location":"physics/mechanics/#Atwood-Machine","page":"Mechanics","title":"Atwood Machine","text":"@giac_var m1 m2 g a T\n\n# Two masses connected by a rope over a pulley\n# Equations: m1*g - T = m1*a  and  T - m2*g = m2*a\n\nresult = solve([m1*g - T ~ m1*a, T - m2*g ~ m2*a], [a, T])\n# Solves for acceleration and tension","category":"section"},{"location":"physics/mechanics/#Simple-Harmonic-Motion","page":"Mechanics","title":"Simple Harmonic Motion","text":"","category":"section"},{"location":"physics/mechanics/#Differential-Equation-Approach","page":"Mechanics","title":"Differential Equation Approach","text":"Solve the SHM differential equation using the D operator:\n\n@giac_var t x(t) omega\n\n# SHM equation: x'' + ω²x = 0 using D operator\node = D(x, 2) + omega^2 * x ~ 0\ndesolve([ode], t, :x)\n# Output: Contains sin(omega*t) and cos(omega*t) terms","category":"section"},{"location":"physics/mechanics/#Spring-Mass-System","page":"Mechanics","title":"Spring-Mass System","text":"@giac_var k m omega x t\n\n# For a spring-mass system: ω = sqrt(k/m)\n# Period: T = 2π/ω = 2π*sqrt(m/k)\n\n# Solve for angular frequency\nsolve(omega^2 ~ k/m, omega)\n# Output: [sqrt(k/m), -sqrt(k/m)]","category":"section"},{"location":"physics/mechanics/#Pendulum-(Small-Angle-Approximation)","page":"Mechanics","title":"Pendulum (Small Angle Approximation)","text":"@giac_var t L g theta(t)\n\n# For small angles: θ'' + (g/L)θ = 0\n# Angular frequency: ω = sqrt(g/L)\n\node = D(theta, 2) + (g/L) * theta ~ 0\ndesolve([ode], t, :theta)","category":"section"},{"location":"physics/mechanics/#Energy-Conservation","page":"Mechanics","title":"Energy Conservation","text":"","category":"section"},{"location":"physics/mechanics/#Kinetic-and-Potential-Energy","page":"Mechanics","title":"Kinetic and Potential Energy","text":"Solve energy conservation problems:\n\n@giac_var m v h g\n\n# Conservation of energy: KE = PE\n# (1/2)mv² = mgh\n\n# Solve for velocity at height h\nsolve(m * v^2 / 2 ~ m * g * h, v)\n# Output: [sqrt(2*g*h), -sqrt(2*g*h)]","category":"section"},{"location":"physics/mechanics/#Work-Energy-Theorem","page":"Mechanics","title":"Work-Energy Theorem","text":"@giac_var F d v1 v2 m\n\n# Work done = Change in kinetic energy\n# W = F*d = (1/2)mv2² - (1/2)mv1²\n\nsolve(F * d ~ m * v2^2 / 2 - m * v1^2 / 2, F)\n# Solves for force given displacement and velocities","category":"section"},{"location":"physics/mechanics/#Uniform-Circular-Motion","page":"Mechanics","title":"Uniform Circular Motion","text":"","category":"section"},{"location":"physics/mechanics/#Angular-and-Linear-Velocity","page":"Mechanics","title":"Angular and Linear Velocity","text":"@giac_var v r omega T\n\n# Linear velocity: v = ω*r\nsolve(v ~ omega * r, omega)\n# Output: [v/r]\n\n# Period: T = 2π/ω (use invoke_cmd(:pi) for pi)\nsolve(T ~ 2*invoke_cmd(:pi) / omega, omega)","category":"section"},{"location":"physics/mechanics/#Centripetal-Acceleration","page":"Mechanics","title":"Centripetal Acceleration","text":"@giac_var v r a_c\n\n# Centripetal acceleration: a_c = v²/r = ω²r\nsolve(a_c ~ v^2 / r, v)\n# Output: [sqrt(a_c*r), -sqrt(a_c*r)]","category":"section"},{"location":"physics/mechanics/#Table-of-Useful-Commands","page":"Mechanics","title":"Table of Useful Commands","text":"Command Physics Application\ndiff(x, t) Velocity from position, acceleration from velocity\nintegrate(a, t) Position from velocity, velocity from acceleration\nsolve(F ~ m*a, a) Solve algebraic equations\ndesolve(eq, y(t)) Solve differential equations (SHM, oscillations)","category":"section"},{"location":"physics/mechanics/#Notes","page":"Mechanics","title":"Notes","text":"All quantities remain symbolic unless specific values are substituted\nUse subst to substitute numerical values for evaluation\nThe D operator can be used for differential equations (see Differential Equations documentation)\nFor numerical simulation, convert symbolic results to Julia functions using to_julia\n\n","category":"section"},{"location":"developer/memory/#Memory-Management","page":"Memory Management","title":"Memory Management","text":"This guide explains how Giac.jl manages memory for C++ objects, ensuring safe interoperation between Julia's garbage collector and GIAC's memory model.","category":"section"},{"location":"developer/memory/#Overview","page":"Memory Management","title":"Overview","text":"Giac.jl wraps C++ objects from the GIAC library. Since Julia's garbage collector doesn't know about C++ memory, we use Julia's finalizer mechanism to ensure proper cleanup.\n\ngraph LR\n    subgraph \"Julia\"\n        A[GiacExpr]\n        B[Julia GC]\n    end\n\n    subgraph \"C++\"\n        C[giac::gen]\n        D[libgiac memory]\n    end\n\n    A -->|ptr| C\n    B -->|finalizer| A\n    A -.->|cleanup| C\n    C --> D","category":"section"},{"location":"developer/memory/#Key-Principles","page":"Memory Management","title":"Key Principles","text":"Every C++ allocation has a corresponding deallocation\nFinalizers ensure cleanup when Julia objects are garbage collected\nRaw pointers are never exposed in the public API\nThread safety is ensured via locks","category":"section"},{"location":"developer/memory/#GiacExpr-Lifecycle","page":"Memory Management","title":"GiacExpr Lifecycle","text":"Understanding the lifecycle of a GiacExpr is essential for safe development.\n\nsequenceDiagram\n    participant User\n    participant GiacExpr\n    participant Finalizer\n    participant C++\n\n    User->>C++: giac_eval(\"x^2\")\n    C++-->>GiacExpr: Create with ptr\n    Note over GiacExpr: Register finalizer\n\n    User->>GiacExpr: Use expression\n    GiacExpr->>C++: Operations via ptr\n\n    Note over User: GiacExpr goes out of scope\n    User->>GiacExpr: (unreachable)\n\n    Note over GiacExpr: Julia GC runs\n    GiacExpr->>Finalizer: Trigger finalizer\n    Finalizer->>C++: _giac_free_expr(ptr)\n    C++-->>Finalizer: Memory freed","category":"section"},{"location":"developer/memory/#Creation","page":"Memory Management","title":"Creation","text":"When a GiacExpr is created, a finalizer is automatically registered:\n\n# In types.jl\nmutable struct GiacExpr\n    ptr::Ptr{Cvoid}\n\n    function GiacExpr(ptr::Ptr{Cvoid})\n        expr = new(ptr)\n        finalizer(_finalize_giacexpr, expr)  # Register cleanup\n        return expr\n    end\nend","category":"section"},{"location":"developer/memory/#Usage","page":"Memory Management","title":"Usage","text":"During its lifetime, the GiacExpr can be used normally:\n\nx = giac_eval(\"x\")\ny = sin(x) + cos(x)  # Creates new GiacExpr objects\nresult = y.simplify()  # Method-style syntax also works","category":"section"},{"location":"developer/memory/#Finalization","page":"Memory Management","title":"Finalization","text":"When the Julia GC determines the object is unreachable, the finalizer runs:\n\nfunction _finalize_giacexpr(expr::GiacExpr)\n    if expr.ptr != C_NULL\n        _giac_free_expr(expr.ptr)  # Call C++ destructor\n        expr.ptr = C_NULL  # Prevent double-free\n    end\nend","category":"section"},{"location":"developer/memory/#Finalizer-Functions","page":"Memory Management","title":"Finalizer Functions","text":"Giac.jl defines three finalizer functions for its wrapped types.","category":"section"},{"location":"developer/memory/#_finalize_giacexpr","page":"Memory Management","title":"_finalize_giacexpr","text":"Cleans up GIAC expression objects.\n\nfunction _finalize_giacexpr(expr::GiacExpr)\n    if expr.ptr != C_NULL\n        _giac_free_expr(expr.ptr)\n        expr.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacExpr object is garbage collected.","category":"section"},{"location":"developer/memory/#_finalize_giaccontext","page":"Memory Management","title":"_finalize_giaccontext","text":"Cleans up GIAC context objects.\n\nfunction _finalize_giaccontext(ctx::GiacContext)\n    if ctx.ptr != C_NULL\n        _giac_free_context(ctx.ptr)\n        ctx.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacContext object is garbage collected.\n\nNote: The DEFAULT_CONTEXT is never garbage collected during normal operation since it's referenced by the module.","category":"section"},{"location":"developer/memory/#_finalize_giacmatrix","page":"Memory Management","title":"_finalize_giacmatrix","text":"Cleans up GIAC matrix objects.\n\nfunction _finalize_giacmatrix(m::GiacMatrix)\n    if m.ptr != C_NULL\n        _giac_free_matrix(m.ptr)\n        m.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacMatrix object is garbage collected.","category":"section"},{"location":"developer/memory/#Thread-Safety","page":"Memory Management","title":"Thread Safety","text":"GIAC is not inherently thread-safe, so Giac.jl uses locks to prevent concurrent access.","category":"section"},{"location":"developer/memory/#The-with_giac_lock-Pattern","page":"Memory Management","title":"The with_giac_lock Pattern","text":"All evaluation operations use with_giac_lock:\n\nfunction with_giac_lock(f::Function, ctx::GiacContext=DEFAULT_CONTEXT)\n    lock(ctx.lock)\n    try\n        return f()\n    finally\n        unlock(ctx.lock)\n    end\nend","category":"section"},{"location":"developer/memory/#Usage-in-Code","page":"Memory Management","title":"Usage in Code","text":"# In command_utils.jl\nfunction giac_cmd(cmd::Symbol, args...)::GiacExpr\n    # ... argument processing ...\n\n    return with_giac_lock() do\n        giac_eval(cmd_string)\n    end\nend","category":"section"},{"location":"developer/memory/#GiacContext-Lock","page":"Memory Management","title":"GiacContext Lock","text":"Each GiacContext contains a ReentrantLock:\n\nmutable struct GiacContext\n    ptr::Ptr{Cvoid}\n    lock::ReentrantLock  # For thread safety\n\n    function GiacContext(ptr::Ptr{Cvoid})\n        ctx = new(ptr, ReentrantLock())\n        finalizer(_finalize_giaccontext, ctx)\n        return ctx\n    end\nend\n\nWhy ReentrantLock?: Allows the same thread to acquire the lock multiple times (nested calls), which is necessary for complex expression evaluation.","category":"section"},{"location":"developer/memory/#Best-Practices","page":"Memory Management","title":"Best Practices","text":"","category":"section"},{"location":"developer/memory/#Do:-Use-Finalizers-for-New-Types","page":"Memory Management","title":"Do: Use Finalizers for New Types","text":"If you create a new type that wraps C++ memory:\n\nmutable struct MyNewType\n    ptr::Ptr{Cvoid}\n\n    function MyNewType(ptr::Ptr{Cvoid})\n        obj = new(ptr)\n        finalizer(_finalize_mynewtype, obj)  # Always register!\n        return obj\n    end\nend\n\nfunction _finalize_mynewtype(obj::MyNewType)\n    if obj.ptr != C_NULL\n        _my_free_function(obj.ptr)\n        obj.ptr = C_NULL\n    end\nend","category":"section"},{"location":"developer/memory/#Do:-Check-for-Null-Pointers","page":"Memory Management","title":"Do: Check for Null Pointers","text":"Always check before using pointers:\n\nfunction safe_operation(expr::GiacExpr)\n    if expr.ptr == C_NULL\n        throw(GiacError(\"Expression has been freed\", :memory))\n    end\n    # ... proceed with operation\nend","category":"section"},{"location":"developer/memory/#Do:-Use-the-Lock-for-Evaluation","page":"Memory Management","title":"Do: Use the Lock for Evaluation","text":"Always use with_giac_lock when calling GIAC:\n\nfunction my_custom_eval(expr::GiacExpr)\n    return with_giac_lock() do\n        # All GIAC calls inside the lock\n        result = giac_eval(string(expr))\n        return result\n    end\nend","category":"section"},{"location":"developer/memory/#Don't:-Expose-Raw-Pointers","page":"Memory Management","title":"Don't: Expose Raw Pointers","text":"Never expose Ptr{Cvoid} in public API:\n\n# Bad: Exposes internal pointer\nfunction get_ptr(expr::GiacExpr)\n    return expr.ptr  # Don't do this!\nend\n\n# Good: Return wrapped type or Julia value\nfunction get_value(expr::GiacExpr)\n    return to_julia(expr)  # Returns proper Julia type\nend","category":"section"},{"location":"developer/memory/#Don't:-Hold-References-Across-Threads","page":"Memory Management","title":"Don't: Hold References Across Threads","text":"Avoid sharing GiacExpr between threads without proper synchronization:\n\n# Risky: expr shared across threads\n@threads for i in 1:10\n    result = sin(expr)  # Race condition!\nend\n\n# Better: Create local copies or use proper synchronization\nresults = Vector{GiacExpr}(undef, 10)\n@threads for i in 1:10\n    local_expr = giac_eval(string(expr))  # Local copy\n    results[i] = sin(local_expr)\nend","category":"section"},{"location":"developer/memory/#Don't:-Manually-Free-Memory","page":"Memory Management","title":"Don't: Manually Free Memory","text":"Let finalizers handle cleanup:\n\n# Bad: Manual memory management\nexpr = giac_eval(\"x\")\n_giac_free_expr(expr.ptr)  # Don't do this!\nexpr.ptr = C_NULL\n\n# Good: Let Julia GC handle it\nexpr = giac_eval(\"x\")\n# Just let it go out of scope","category":"section"},{"location":"developer/memory/#Common-Pitfalls","page":"Memory Management","title":"Common Pitfalls","text":"","category":"section"},{"location":"developer/memory/#Memory-Leaks","page":"Memory Management","title":"Memory Leaks","text":"Symptom: Memory usage grows over time without bound.\n\nCause: Finalizers not registered, or C++ objects created without wrapping.\n\nFix: Ensure every Ptr{Cvoid} from C++ is wrapped in a Julia type with a finalizer.","category":"section"},{"location":"developer/memory/#Dangling-Pointers","page":"Memory Management","title":"Dangling Pointers","text":"Symptom: Segmentation fault or garbage values.\n\nCause: Using a pointer after its memory has been freed.\n\nFix: Always check for C_NULL before using pointers; don't manually free memory.","category":"section"},{"location":"developer/memory/#Race-Conditions","page":"Memory Management","title":"Race Conditions","text":"Symptom: Intermittent crashes or wrong results with multithreading.\n\nCause: Multiple threads accessing GIAC without synchronization.\n\nFix: Use with_giac_lock for all GIAC operations.","category":"section"},{"location":"developer/memory/#Double-Free","page":"Memory Management","title":"Double Free","text":"Symptom: Crash with \"double free or corruption\" error.\n\nCause: Memory freed twice, often from manual _giac_free_* calls.\n\nFix: Never call free functions manually; let finalizers handle it. Set pointer to C_NULL in finalizer to prevent double-free.","category":"section"},{"location":"developer/memory/#Debugging-Memory-Issues","page":"Memory Management","title":"Debugging Memory Issues","text":"","category":"section"},{"location":"developer/memory/#Using-Julia's-GC","page":"Memory Management","title":"Using Julia's GC","text":"Force garbage collection to trigger finalizers:\n\nGC.gc()  # Run garbage collector","category":"section"},{"location":"developer/memory/#Checking-for-Leaks","page":"Memory Management","title":"Checking for Leaks","text":"Monitor memory usage:\n\nfunction memory_test()\n    initial = Sys.maxrss()\n    for i in 1:10000\n        x = giac_eval(\"x^$i\")\n    end\n    GC.gc()\n    final = Sys.maxrss()\n    println(\"Memory change: $(final - initial) bytes\")\nend","category":"section"},{"location":"developer/memory/#Pointer-Validation","page":"Memory Management","title":"Pointer Validation","text":"Check if a pointer is valid:\n\nfunction is_valid(expr::GiacExpr)\n    return expr.ptr != C_NULL\nend","category":"section"},{"location":"developer/memory/#See-Also","page":"Memory Management","title":"See Also","text":"Package Architecture - Type definitions in types.jl\nTroubleshooting - Debugging memory-related errors\nPerformance Tiers - How tier wrappers handle pointers\n\n","category":"section"},{"location":"api/tempapi/#TempApi-Submodule","page":"TempApi","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for common symbolic computation operations.","category":"section"},{"location":"api/tempapi/#Usage","page":"TempApi","title":"Usage","text":"","category":"section"},{"location":"api/tempapi/#Selective-Import-(Recommended)","page":"TempApi","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.TempApi: diff, factor, integrate\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)     # 2*x\nfactor(expr)      # (x-1)*(x+1)","category":"section"},{"location":"api/tempapi/#Full-Import","page":"TempApi","title":"Full Import","text":"using Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\ndiff(giac_eval(\"x^3\"), x)  # 3*x^2","category":"section"},{"location":"api/tempapi/#Calculus-Functions","page":"TempApi","title":"Calculus Functions","text":"","category":"section"},{"location":"api/tempapi/#Algebra-Functions","page":"TempApi","title":"Algebra Functions","text":"","category":"section"},{"location":"api/tempapi/#Giac.TempApi","page":"TempApi","title":"Giac.TempApi","text":"Giac.TempApi\n\nA submodule providing convenience functions with simplified names for common symbolic computation operations. These functions delegate to invoke_cmd from the main Giac module.\n\nThis is intended as a temporary API for interactive use and quick access to  common commands without needing to import the entire Giac.Commands submodule.\n\nAccess Patterns\n\nFull import (for interactive use):\nusing Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nSelective import (recommended):\nusing Giac\nusing Giac.TempApi: diff, factor\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)    # Works\nfactor(expr)     # Works\nQualified access:\nusing Giac\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)\n\nExports\n\ndiff: Differentiate an expression (uses invoke_cmd(:diff, ...))\nintegrate: Integrate an expression (uses invoke_cmd(:integrate, ...))\nlimit: Compute limit (uses invoke_cmd(:limit, ...))\nfactor: Factor a polynomial (uses invoke_cmd(:factor, ...))\nexpand: Expand an expression (uses invoke_cmd(:expand, ...))\nsimplify: Simplify an expression (uses invoke_cmd(:simplify, ...))\nsolve: Solve an equation (uses invoke_cmd(:solve, ...))\n\nSee also\n\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all GIAC commands\n\n\n\n\n\n","category":"module"},{"location":"api/tempapi/#Giac.TempApi.diff","page":"TempApi","title":"Giac.TempApi.diff","text":"diff(expr, var, n=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nUses invoke_cmd(:diff, ...).\n\nArguments\n\nexpr: Expression to differentiate (GiacExpr or String)\nvar: Variable to differentiate with respect to (GiacExpr or String)\nn: Order of differentiation (default: 1)\n\nReturns\n\nGiacExpr: The derivative\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndiff(f, x)      # 3*x^2\ndiff(f, x, 2)   # 6*x\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.integrate","page":"TempApi","title":"Giac.TempApi.integrate","text":"integrate(expr, var)\nintegrate(expr, var, a, b)\n\nCompute indefinite or definite integral.\n\nUses invoke_cmd(:integrate, ...).\n\nArguments\n\nexpr: Expression to integrate (GiacExpr or String)\nvar: Variable of integration (GiacExpr or String)\na, b: Optional bounds for definite integration\n\nReturns\n\nGiacExpr: The integral\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nintegrate(f, x)           # x^3/3\nintegrate(f, x, 0, 1)     # 1/3\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.limit","page":"TempApi","title":"Giac.TempApi.limit","text":"limit(expr, var, point; direction=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nUses invoke_cmd(:limit, ...).\n\nArguments\n\nexpr: The expression (GiacExpr or String)\nvar: The variable (GiacExpr or String)\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nReturns\n\nGiacExpr: The limit\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlimit(f, x, giac_eval(\"0\"))  # 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.factor","page":"TempApi","title":"Giac.TempApi.factor","text":"factor(expr)\n\nFactor a polynomial expression.\n\nUses invoke_cmd(:factor, ...).\n\nArguments\n\nexpr: Expression to factor (GiacExpr or String)\n\nReturns\n\nGiacExpr: The factored expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"x^2 - 1\")\nfactor(p)  # (x-1)*(x+1)\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.expand","page":"TempApi","title":"Giac.TempApi.expand","text":"expand(expr)\n\nExpand a polynomial expression.\n\nUses invoke_cmd(:expand, ...).\n\nArguments\n\nexpr: Expression to expand (GiacExpr or String)\n\nReturns\n\nGiacExpr: The expanded expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"(x+1)^3\")\nexpand(p)  # x^3 + 3*x^2 + 3*x + 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.simplify","page":"TempApi","title":"Giac.TempApi.simplify","text":"simplify(expr)\n\nSimplify an expression.\n\nUses invoke_cmd(:simplify, ...).\n\nArguments\n\nexpr: Expression to simplify (GiacExpr or String)\n\nReturns\n\nGiacExpr: The simplified expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\nsimplify(e)  # x + 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.solve","page":"TempApi","title":"Giac.TempApi.solve","text":"solve(expr, var)\n\nSolve an equation for a variable.\n\nUses invoke_cmd(:solve, ...).\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsolve(eq, x)  # [-2, 2]\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"domains/signal/discrete_transforms/#Discrete-Time-Signal-Transforms","page":"Discrete-Time Transforms","title":"Discrete-Time Signal Transforms","text":"This page documents discrete-time signal processing functions in Giac.jl.","category":"section"},{"location":"domains/signal/discrete_transforms/#Z-Transform","page":"Discrete-Time Transforms","title":"Z-Transform","text":"The Z-transform is a mathematical tool for analyzing discrete-time signals and systems. GIAC provides two commands for computing Z-transforms, available via Giac.Commands:\n\nztrans(expr, n, z) - Computes the unilateral Z-transform\ninvztrans(expr, z, n) - Computes the inverse Z-transform","category":"section"},{"location":"domains/signal/discrete_transforms/#Mathematical-Definition","page":"Discrete-Time Transforms","title":"Mathematical Definition","text":"The unilateral Z-transform of a discrete sequence x[n] is defined as:\n\nX(z) = sum_n=0^infty xn cdot z^-n","category":"section"},{"location":"domains/signal/discrete_transforms/#Basic-Usage","page":"Discrete-Time Transforms","title":"Basic Usage","text":"using Giac\nusing Giac.Commands: ztrans, invztrans\n\n# Declare symbolic variables\n@giac_var n z a\n\n# Z-transform of a geometric sequence a^n\nX = ztrans(a^n, n, z)\n# Returns -z/(a-z) which is equivalent to z/(z-a)\n\n# Z-transform of unit step (constant 1)\nX_step = ztrans(1, n, z)\n# Returns z/(z-1)\n\n# Z-transform of ramp sequence n\nX_ramp = ztrans(n, n, z)\n# Returns z/(z-1)^2","category":"section"},{"location":"domains/signal/discrete_transforms/#Inverse-Z-Transform","page":"Discrete-Time Transforms","title":"Inverse Z-Transform","text":"using Giac\nusing Giac.Commands: invztrans\n\n@giac_var n z a\n\n# Inverse Z-transform of z/(z-1) → unit step\nx_step = invztrans(z/(z-1), z, n)\n# Returns 1\n\n# Inverse Z-transform of z/(z-a) → exponential\nx_exp = invztrans(z/(z-a), z, n)\n# Returns a^n\n\n# Inverse Z-transform of z/(z-1)^2 → ramp\nx_ramp = invztrans(z/(z-1)^2, z, n)\n# Returns n","category":"section"},{"location":"domains/signal/discrete_transforms/#Round-Trip-Verification","page":"Discrete-Time Transforms","title":"Round-Trip Verification","text":"The Z-transform and inverse Z-transform are mathematical inverses:\n\nusing Giac\nusing Giac.Commands: ztrans, invztrans, simplify\n\n@giac_var n z a\n\n# Verify: invztrans(ztrans(a^n)) = a^n\noriginal = a^n\ntransformed = ztrans(original, n, z)\nrecovered = invztrans(transformed, z, n)\nsimplified = simplify(recovered)\n# Result: a^n","category":"section"},{"location":"domains/signal/discrete_transforms/#Common-Z-Transform-Pairs","page":"Discrete-Time Transforms","title":"Common Z-Transform Pairs","text":"Time Domain x[n] Z-Domain X(z) Region of Convergence\n1 (unit step) z/(z-1) |z| > 1\nn (ramp) z/(z-1)² |z| > 1\na^n z/(z-a) |z| > |a|\nn·a^n az/(z-a)² |z| > |a|","category":"section"},{"location":"domains/signal/discrete_transforms/#Using-invoke_cmd","page":"Discrete-Time Transforms","title":"Using invoke_cmd","text":"You can also use invoke_cmd directly:\n\nusing Giac\n\n@giac_var n z a\n\n# Using invoke_cmd\ninvoke_cmd(:ztrans, a^n, n, z)\ninvoke_cmd(:invztrans, z/(z-a), z, n)","category":"section"},{"location":"domains/signal/discrete_transforms/#Notes","page":"Discrete-Time Transforms","title":"Notes","text":"Equivalent Forms: GIAC may return -z/(a-z) instead of z/(z-a). These are algebraically equivalent.\nVariable Declaration: Always declare n and z as symbolic variables using @giac_var before using them in transforms.\nSimplification: Use simplify from Giac.Commands to reduce results to canonical form.","category":"section"},{"location":"domains/signal/discrete_transforms/#See-Also","page":"Discrete-Time Transforms","title":"See Also","text":"Continuous-Time Transforms - Laplace transforms for continuous-time signals\nCalculus Operations - Integration, differentiation, and limits\nGIAC Z-Transform Documentation - Official GIAC documentation\n\n","category":"section"},{"location":"mathematics/differential_equations/#Differential-Equations","page":"Differential Equations","title":"Differential Equations","text":"Giac.jl provides symbolic solving of ordinary differential equations (ODEs) using GIAC's desolve command. The package includes a D operator following SciML/ModelingToolkit conventions for expressing derivatives naturally.","category":"section"},{"location":"mathematics/differential_equations/#The-D-Operator","page":"Differential Equations","title":"The D Operator","text":"The D operator provides a clean, Julian syntax for expressing derivatives:\n\nusing Giac\nusing Giac.Commands: desolve\n\n@giac_var t u(t)\n\n# Create derivative expressions\nD(u)        # First derivative u'\nD(D(u))     # Second derivative u'' (chained)\nD(u, 2)     # Second derivative u'' (direct)\nD(u, 3)     # Third derivative u'''","category":"section"},{"location":"mathematics/differential_equations/#Comparison-with-Raw-Syntax","page":"Differential Equations","title":"Comparison with Raw Syntax","text":"D Operator Raw GIAC Description\nD(u) diff(u, t) First derivative\nD(D(u)) diff(diff(u, t), t) Second derivative (chained)\nD(u, 2) diff(u, t, 2) Second derivative (direct)\nD(u)(0) ~ 1 \"u'(0)=1\" Initial condition for u'(0)","category":"section"},{"location":"mathematics/differential_equations/#First-Order-ODEs","page":"Differential Equations","title":"First-Order ODEs","text":"","category":"section"},{"location":"mathematics/differential_equations/#Basic-Example","page":"Differential Equations","title":"Basic Example","text":"Solve τu' + u = U₀ with initial condition u(0) = 1:\n\nusing Giac\nusing Giac.Commands: desolve\n\n@giac_var t u(t) tau U0\n\n# Define ODE: τu' + u = U₀\node = tau * D(u) + u ~ U0\n\n# Initial condition: u(0) = 1\ninitial = u(0) ~ 1\n\n# Solve\nresult = desolve([ode, initial], t, :u)\n# Returns: U0+(-U0+1)*exp(-t/tau)","category":"section"},{"location":"mathematics/differential_equations/#RC-Circuit-Example","page":"Differential Equations","title":"RC Circuit Example","text":"@giac_var t V(t) R C Vs\n\n# Capacitor voltage ODE: RC·V' + V = Vs\node = R * C * D(V) + V ~ Vs\ninitial = V(0) ~ 0\n\nresult = desolve([ode, initial], t, :V)\n# Returns: Vs*(1-exp(-t/(R*C)))","category":"section"},{"location":"mathematics/differential_equations/#Second-Order-ODEs","page":"Differential Equations","title":"Second-Order ODEs","text":"","category":"section"},{"location":"mathematics/differential_equations/#Harmonic-Oscillator","page":"Differential Equations","title":"Harmonic Oscillator","text":"Solve u'' + u = 0 with u(0) = 1, u'(0) = 0:\n\nusing Giac\nusing Giac.Commands: desolve\n\n@giac_var t u(t)\n\n# Define ODE using chained D\node = D(D(u)) + u ~ 0\n\n# Initial conditions\nu0 = u(0) ~ 1      # u(0) = 1\ndu0 = D(u)(0) ~ 0  # u'(0) = 0\n\n# Solve\nresult = desolve([ode, u0, du0], t, :u)\n# Returns: cos(t)","category":"section"},{"location":"mathematics/differential_equations/#Alternative-Syntax-with-D(u,-2)","page":"Differential Equations","title":"Alternative Syntax with D(u, 2)","text":"# Same ODE using direct order specification\node = D(u, 2) + u ~ 0\nresult = desolve([ode, u(0) ~ 1, D(u)(0) ~ 0], t, :u)\n# Returns: cos(t)","category":"section"},{"location":"mathematics/differential_equations/#Damped-Oscillator","page":"Differential Equations","title":"Damped Oscillator","text":"Solve u'' + 2ζω₀u' + ω₀²u = 0:\n\n@giac_var t u(t) zeta omega0\n\node = D(u, 2) + 2*zeta*omega0*D(u) + omega0^2*u ~ 0\nresult = desolve([ode, u(0) ~ 1, D(u)(0) ~ 0], t, :u)","category":"section"},{"location":"mathematics/differential_equations/#Third-Order-ODEs","page":"Differential Equations","title":"Third-Order ODEs","text":"Solve y''' - y = 0 with y(0) = 1, y'(0) = 1, y''(0) = 1:\n\nusing Giac\nusing Giac.Commands: desolve\n\n@giac_var t y(t)\n\n# Define ODE\node = D(y, 3) - y ~ 0\n\n# Initial conditions\ny0 = y(0) ~ 1\ndy0 = D(y)(0) ~ 1\nd2y0 = D(y, 2)(0) ~ 1\n\n# Solve\nresult = desolve([ode, y0, dy0, d2y0], t, :y)\n# Returns: exp(t)","category":"section"},{"location":"mathematics/differential_equations/#Using-D-in-ODE-Expressions","page":"Differential Equations","title":"Using D in ODE Expressions","text":"The D operator supports arithmetic operations, making it natural to build ODE expressions:\n\n@giac_var t u(t) a b c\n\n# Build complex ODE expressions\node1 = D(D(u)) + a*D(u) + b*u ~ c\node2 = D(u, 2) - 4*D(u) + 4*u ~ 0\n\n# Combine with other GiacExpr\nforcing = sin(t)\node3 = D(D(u)) + u ~ forcing","category":"section"},{"location":"mathematics/differential_equations/#Important-Notes","page":"Differential Equations","title":"Important Notes","text":"","category":"section"},{"location":"mathematics/differential_equations/#Function-Name-as-Symbol","page":"Differential Equations","title":"Function Name as Symbol","text":"When calling desolve, pass the function name as a Symbol (:u, :y) rather than the function expression (u, y):\n\n# Correct\ndesolve([ode, u(0) ~ 1], t, :u)\n\n# Incorrect - GIAC expects just the name, not u(t)\ndesolve([ode, u(0) ~ 1], t, u)  # May not work as expected","category":"section"},{"location":"mathematics/differential_equations/#Initial-Conditions-with-D","page":"Differential Equations","title":"Initial Conditions with D","text":"The D(u)(0) syntax creates an unevaluated derivative condition that GIAC interprets correctly:\n\nD(u)(0) ~ 1      # Creates \"u'(0)=1\" for GIAC\nD(u, 2)(0) ~ 0   # Creates \"u''(0)=0\" for GIAC","category":"section"},{"location":"mathematics/differential_equations/#Systems-of-ODEs","page":"Differential Equations","title":"Systems of ODEs","text":"GIAC can solve systems of first-order ODEs:\n\n@giac_var t x(t) y(t)\n\n# dx/dt = y, dy/dt = -x\nsys = [D(x) ~ y, D(y) ~ -x]\ninitial = [x(0) ~ 1, y(0) ~ 0]\n\n# Solve as a system (pass both variables)\nresult = desolve([sys..., initial...], t, [:x, :y])","category":"section"},{"location":"mathematics/differential_equations/#Physics-Applications","page":"Differential Equations","title":"Physics Applications","text":"","category":"section"},{"location":"mathematics/differential_equations/#Exponential-Decay","page":"Differential Equations","title":"Exponential Decay","text":"Model radioactive decay: dN/dt = -λN\n\n@giac_var t N(t) lambda N0\n\n# Decay equation\node = D(N) + lambda * N ~ 0\ninitial = N(0) ~ N0\n\nresult = desolve([ode, initial], t, :N)\n# Returns: N0*exp(-lambda*t)","category":"section"},{"location":"mathematics/differential_equations/#Population-Growth","page":"Differential Equations","title":"Population Growth","text":"Exponential growth model: dP/dt = rP\n\n@giac_var t P(t) r P0\n\node = D(P) - r * P ~ 0\ninitial = P(0) ~ P0\n\nresult = desolve([ode, initial], t, :P)\n# Returns: P0*exp(r*t)","category":"section"},{"location":"mathematics/differential_equations/#Newton's-Law-of-Cooling","page":"Differential Equations","title":"Newton's Law of Cooling","text":"Temperature change: dT/dt = -k(T - T_env)\n\n@giac_var t T(t) k T_env T0\n\node = D(T) + k * (T - T_env) ~ 0\ninitial = T(0) ~ T0\n\nresult = desolve([ode, initial], t, :T)\n# Returns exponential approach to T_env","category":"section"},{"location":"mathematics/differential_equations/#Limitations","page":"Differential Equations","title":"Limitations","text":"ODEs only: GIAC's desolve is designed for ordinary differential equations. For PDEs, consider Symbolics.jl + MethodOfLines.jl or other specialized packages.\nSymbolic solutions: desolve finds closed-form analytical solutions when possible. For numerical solutions of ODEs, use DifferentialEquations.jl.","category":"section"},{"location":"mathematics/differential_equations/#API-Reference","page":"Differential Equations","title":"API Reference","text":"","category":"section"},{"location":"mathematics/differential_equations/#Giac.D","page":"Differential Equations","title":"Giac.D","text":"D(expr::GiacExpr) -> DerivativeExpr\nD(expr::GiacExpr, n::Int) -> DerivativeExpr\nD(d::DerivativeExpr) -> DerivativeExpr\n\nDerivative operator following SciML/ModelingToolkit conventions.\n\nCreates a DerivativeExpr that can be:\n\nUsed in ODEs: D(D(u)) + u ~ 0 (converts to diff notation)\nCalled for initial conditions: D(u)(0) ~ 1 (produces prime notation u'(0)=1)\n\nArguments\n\nexpr::GiacExpr: A function expression created with @giac_var u(t)\nn::Int: Optional derivative order (default: 1)\nd::DerivativeExpr: A derivative expression to differentiate further\n\nExamples\n\nusing Giac\nusing Giac.Commands: desolve\n\n@giac_var t u(t)\n\n# First derivative\nD(u)              # Represents u'\n\n# Second derivative (two ways)\nD(D(u))           # Chain D operators\nD(u, 2)           # Specify order directly\n\n# ODE with initial conditions\node = D(D(u)) + u ~ 0       # u'' + u = 0\nu0 = u(0) ~ 1               # u(0) = 1\ndu0 = D(u)(0) ~ 0           # u'(0) = 0\n\ndesolve([ode, u0, du0], t, u)  # Returns: cos(t)\n\n# Third order example\n@giac_var t y(t)\node = D(y, 3) - y ~ 0          # y''' - y = 0\ndesolve([ode, y(0) ~ 1, D(y)(0) ~ 1, D(y,2)(0) ~ 1], t, y)\n\nSee also\n\nDerivativeExpr: The derivative expression type\ndesolve: Solving differential equations (via Giac.Commands)\n\n\n\n\n\n","category":"function"},{"location":"mathematics/differential_equations/#Giac.DerivativeExpr","page":"Differential Equations","title":"Giac.DerivativeExpr","text":"DerivativeExpr\n\nRepresents a derivative expression for use in ODE initial conditions.\n\nThis type enables the D operator syntax following SciML conventions:\n\nD(u) represents the first derivative u'\nD(D(u)) or D(u, 2) represents the second derivative u''\nD(u)(0) produces \"u'(0)\" for GIAC initial conditions\n\nFields\n\nbase_expr::GiacExpr: The original function expression (e.g., u(t))\nfuncname::String: The function name (e.g., \"u\")\nvarname::String: The differentiation variable (e.g., \"t\")\norder::Int: The derivative order (1 for first derivative, 2 for second, etc.)\n\nExample\n\n@giac_var t u(t)\n\n# Create derivative expressions\ndu = D(u)           # First derivative\nd2u = D(D(u))       # Second derivative\nd2u = D(u, 2)       # Alternative syntax\n\n# Use in initial conditions\nD(u)(0) ~ 1         # u'(0) = 1\nD(u, 2)(0) ~ 0      # u''(0) = 0\n\n# Use in ODEs (converts to diff notation)\node = D(D(u)) + u ~ 0   # Equivalent to diff(u,t,2) + u = 0\n\nSee also\n\nD: The derivative operator function\n@giac_var: For creating function variables\n\n\n\n\n\n","category":"type"},{"location":"mathematics/differential_equations/#Giac.DerivativePoint","page":"Differential Equations","title":"Giac.DerivativePoint","text":"DerivativePoint\n\nRepresents a derivative evaluated at a specific point, for use in ODE initial conditions.\n\nThis type is created when calling a DerivativeExpr with arguments, e.g., D(u)(0). It delays evaluation until used with the ~ operator to create an equation, because GIAC interprets prime notation differently in isolation vs. within desolve.\n\nFields\n\nfuncname::String: The function name (e.g., \"u\")\norder::Int: The derivative order\npoint_args::Vector{String}: The point arguments as strings\n\nExample\n\n@giac_var t u(t)\ndp = D(u)(0)          # Returns DerivativePoint, not GiacExpr\neq = D(u)(0) ~ 1      # Creates equation: \"u'(0)=1\"\n\n\n\n\n\n","category":"type"},{"location":"mathematics/differential_equations/#Giac.DerivativeCondition","page":"Differential Equations","title":"Giac.DerivativeCondition","text":"DerivativeCondition\n\nRepresents an unevaluated derivative initial condition for ODEs.\n\nThis type holds the string representation of a derivative condition (e.g., \"u'(0)=1\") without evaluating it through GIAC. When passed to desolve in an array, it gets converted to its string form, which GIAC interprets correctly.\n\nExample\n\n@giac_var t u(t)\ndc = D(u)(0) ~ 1     # Returns DerivativeCondition: \"u'(0)=1\"\n\n# Pass to desolve - the string is used directly\ndesolve([D(D(u)) + u ~ 0, u(0) ~ 1, D(u)(0) ~ 0], t, u)\n\n\n\n\n\n","category":"type"},{"location":"substitute/#Variable-Substitution","page":"Variable Substitution","title":"Variable Substitution","text":"Giac.jl provides a substitute function with a Symbolics.jl-compatible interface for variable substitution in symbolic expressions.","category":"section"},{"location":"substitute/#Basic-Usage","page":"Variable Substitution","title":"Basic Usage","text":"","category":"section"},{"location":"substitute/#Single-Variable-Substitution","page":"Variable Substitution","title":"Single Variable Substitution","text":"using Giac\n\n# Create symbolic variables\n@giac_var x y\n\n# Create an expression\nexpr = x^2 + 2*x + 1\n\n# Substitute x = 3\nresult = substitute(expr, Dict(x => 3))\n# Returns: 16 (which is 9 + 6 + 1)\n\n# Substitute with symbolic value\nresult = substitute(expr, Dict(x => y))\n# Returns: y^2 + 2*y + 1","category":"section"},{"location":"substitute/#Pair-Syntax-(Shorthand)","page":"Variable Substitution","title":"Pair Syntax (Shorthand)","text":"For single-variable substitutions, you can use the Pair syntax:\n\n@giac_var x\n\nsubstitute(x + 1, x => 5)  # Returns: 6","category":"section"},{"location":"substitute/#Multiple-Variable-Substitution","page":"Variable Substitution","title":"Multiple Variable Substitution","text":"Substitute multiple variables simultaneously:\n\n@giac_var x y z\n\nexpr = x*y + y*z + x*z\n\n# Substitute multiple variables at once\nresult = substitute(expr, Dict(x => 1, y => 2, z => 3))\n# Returns: 11 (which is 2 + 6 + 3)","category":"section"},{"location":"substitute/#Variable-Swapping","page":"Variable Substitution","title":"Variable Swapping","text":"The substitution is performed simultaneously, making variable swapping work correctly:\n\n@giac_var a b\n\nexpr = a^2 + b\n\n# Simultaneous substitution correctly swaps variables\nresult = substitute(expr, Dict(a => b, b => a))\n# Returns: b^2 + a","category":"section"},{"location":"substitute/#With-GIAC-Functions","page":"Variable Substitution","title":"With GIAC Functions","text":"The substitute function works with any GIAC-supported functions:\n\n@giac_var θ\n\nexpr = invoke_cmd(:sin, θ) + invoke_cmd(:cos, θ)\n\n# Substitute θ = π/4\nusing Giac.Commands: simplify\nresult = substitute(expr, Dict(θ => giac_eval(\"pi/4\"))) |> simplify\n# Returns: sqrt(2)","category":"section"},{"location":"substitute/#Symbolic-to-Symbolic-Substitution","page":"Variable Substitution","title":"Symbolic-to-Symbolic Substitution","text":"Replace variables with complex expressions:\n\n@giac_var x y\n\n# x^2 with x = y + 1\nresult = substitute(x^2, Dict(x => y + 1))\n# Returns: (y + 1)^2","category":"section"},{"location":"substitute/#Chained-Substitution","page":"Variable Substitution","title":"Chained Substitution","text":"Apply multiple substitutions in sequence:\n\n@giac_var x y z\n\nexpr = x + y + z\n\nstep1 = substitute(expr, x => 1)\nstep2 = substitute(step1, y => 2)\nfinal = substitute(step2, z => 3)\n# Returns: 6","category":"section"},{"location":"substitute/#Comparison-with-Symbolics.jl","page":"Variable Substitution","title":"Comparison with Symbolics.jl","text":"The API is designed to match Symbolics.jl's substitute function:\n\n# Symbolics.jl style (works in Giac.jl)\nsubstitute(expr, Dict(x => 2, y => 3))\n\n# Single variable shorthand\nsubstitute(expr, x => value)","category":"section"},{"location":"substitute/#Edge-Cases","page":"Variable Substitution","title":"Edge Cases","text":"@giac_var x y\n\n# Empty Dict returns original expression\nsubstitute(x + 1, Dict{GiacExpr, Int}())  # Returns: x + 1\n\n# Missing variable is ignored\nsubstitute(x + 1, Dict(y => 5))  # Returns: x + 1 (y not in expr)","category":"section"},{"location":"substitute/#Matrix-Substitution","page":"Variable Substitution","title":"Matrix Substitution","text":"The substitute function also works element-wise on GiacMatrix:","category":"section"},{"location":"substitute/#Single-Variable-in-Matrix","page":"Variable Substitution","title":"Single Variable in Matrix","text":"@giac_var x\n\nM = GiacMatrix([x x+1; 2*x x^2])\n\n# Substitute x = 3 in all elements\nresult = substitute(M, x => 3)\n# Returns: [[3, 4], [6, 9]]","category":"section"},{"location":"substitute/#Multiple-Variables-in-Matrix","page":"Variable Substitution","title":"Multiple Variables in Matrix","text":"@giac_var x y\n\nM = GiacMatrix([x+y x*y; x-y x/y])\n\n# Substitute x = 6, y = 2 in all elements\nresult = substitute(M, Dict(x => 6, y => 2))\n# Returns: [[8, 12], [4, 3]]","category":"section"},{"location":"substitute/#Partial-Substitution","page":"Variable Substitution","title":"Partial Substitution","text":"@giac_var x y\n\nM = GiacMatrix([x y; x+y x*y])\n\n# Only substitute x, leave y symbolic\nresult = substitute(M, Dict(x => 2))\n# Returns: [[2, y], [2+y, 2*y]]","category":"section"},{"location":"substitute/#Symbolic-Substitution-in-Matrix","page":"Variable Substitution","title":"Symbolic Substitution in Matrix","text":"@giac_var x y\n\nM = GiacMatrix([x^2 x; 1 x+1])\n\n# Replace x with y+1\nresult = substitute(M, Dict(x => y + 1))\n# Returns: [[(y+1)^2, y+1], [1, y+2]]","category":"section"},{"location":"substitute/#API-Reference","page":"Variable Substitution","title":"API Reference","text":"","category":"section"},{"location":"substitute/#Giac.substitute","page":"Variable Substitution","title":"Giac.substitute","text":"substitute(expr::GiacExpr, dict::AbstractDict{<:GiacExpr}) -> GiacExpr\n\nSubstitute variables in a symbolic expression according to a dictionary mapping.\n\nPerforms simultaneous substitution of all variables in dict. The original expression is not modified.\n\nArguments\n\nexpr::GiacExpr: The expression to transform\ndict::AbstractDict: Mapping from variables (GiacExpr) to replacement values\n\nReturns\n\nGiacExpr: New expression with substitutions applied\n\nExamples\n\n@giac_var x y\nexpr = x^2 + y\nsubstitute(expr, Dict(x => 2))        # Returns: 4 + y\nsubstitute(expr, Dict(x => 2, y => 3)) # Returns: 7\nsubstitute(expr, Dict(x => y, y => x)) # Swaps x and y: y^2 + x\n\nSee also\n\ninvoke_cmd: Lower-level command invocation\n@giac_var: Create symbolic variables\n\n\n\n\n\nsubstitute(expr::GiacExpr, pair::Pair{<:GiacExpr}) -> GiacExpr\n\nSubstitute a single variable using Pair syntax.\n\nConvenience method equivalent to substitute(expr, Dict(pair)).\n\nExamples\n\n@giac_var x\nsubstitute(x + 1, x => 5)  # Returns: 6\n\nSee also\n\nsubstitute(::GiacExpr, ::AbstractDict): Full Dict-based substitution\n\n\n\n\n\nsubstitute(m::GiacMatrix, dict::AbstractDict{<:GiacExpr}) -> GiacMatrix\n\nSubstitute variables in each element of a symbolic matrix.\n\nPerforms element-wise substitution, applying the same variable mappings to every element of the matrix. Returns a new matrix with the same dimensions.\n\nArguments\n\nm::GiacMatrix: The matrix to transform\ndict::AbstractDict: Mapping from variables (GiacExpr) to replacement values\n\nReturns\n\nGiacMatrix: New matrix with substitutions applied element-wise\n\nExamples\n\n@giac_var x y\nM = GiacMatrix([x+1 2*x; y x*y])\nsubstitute(M, Dict(x => 2))        # Returns matrix with x=2 substituted\nsubstitute(M, Dict(x => 2, y => 3)) # Returns fully numeric matrix\n\nSee also\n\nsubstitute(::GiacExpr, ::AbstractDict): Scalar expression substitution\n\n\n\n\n\nsubstitute(m::GiacMatrix, pair::Pair{<:GiacExpr}) -> GiacMatrix\n\nSubstitute a single variable in each element of a matrix using Pair syntax.\n\nConvenience method equivalent to substitute(m, Dict(pair)).\n\nExamples\n\n@giac_var x\nM = GiacMatrix([x 2*x; x+1 x^2])\nsubstitute(M, x => 3)  # Returns: [[3, 6], [4, 9]]\n\nSee also\n\nsubstitute(::GiacMatrix, ::AbstractDict): Full Dict-based matrix substitution\n\n\n\n\n\n","category":"function"},{"location":"mathematics/algebra/#Algebra","page":"Algebra","title":"Algebra","text":"Giac.jl provides powerful symbolic algebra capabilities including polynomial factorization, expansion, simplification, equation solving, and polynomial arithmetic.","category":"section"},{"location":"mathematics/algebra/#Setup","page":"Algebra","title":"Setup","text":"using Giac\nusing Giac.Commands: factor, expand, simplify, solve, gcd, lcm, quo, rem\n\n@giac_var x y","category":"section"},{"location":"mathematics/algebra/#Polynomial-Factorization","page":"Algebra","title":"Polynomial Factorization","text":"","category":"section"},{"location":"mathematics/algebra/#Factoring-Polynomials","page":"Algebra","title":"Factoring Polynomials","text":"Factor polynomials into irreducible factors using the factor command:\n\nfactor(x^2 - 1)\n# Output: (x-1)*(x+1)\n\nfactor(x^2 - 4)\n# Output: (x-2)*(x+2)\n\nfactor(x^2 + 2*x + 1)\n# Output: (x+1)^2","category":"section"},{"location":"mathematics/algebra/#Factoring-Higher-Degree-Polynomials","page":"Algebra","title":"Factoring Higher-Degree Polynomials","text":"factor(x^3 - 1)\n# Output: (x-1)*(x^2+x+1)\n\nfactor(x^4 - 1)\n# Output: (x-1)*(x+1)*(x^2+1)","category":"section"},{"location":"mathematics/algebra/#Polynomial-Expansion","page":"Algebra","title":"Polynomial Expansion","text":"","category":"section"},{"location":"mathematics/algebra/#Expanding-Products","page":"Algebra","title":"Expanding Products","text":"Expand products and powers of polynomials using the expand command:\n\nexpand((x + 1)^2)\n# Output: x^2+2*x+1\n\nexpand((x + 1)^3)\n# Output: x^3+3*x^2+3*x+1\n\nexpand((x - 1) * (x + 1))\n# Output: x^2-1","category":"section"},{"location":"mathematics/algebra/#Expanding-More-Complex-Expressions","page":"Algebra","title":"Expanding More Complex Expressions","text":"expand((x + 2) * (x - 3) * (x + 1))\n# Expands to full polynomial form\n\nexpand((x + y)^2)\n# Output: x^2+2*x*y+y^2","category":"section"},{"location":"mathematics/algebra/#Simplification","page":"Algebra","title":"Simplification","text":"","category":"section"},{"location":"mathematics/algebra/#Simplifying-Rational-Expressions","page":"Algebra","title":"Simplifying Rational Expressions","text":"Simplify expressions using the simplify command:\n\nsimplify((x^2-1)/(x-1))\n# Output: x+1\n\nsimplify((x^3-x)/(x^2-1))\n# Output: x","category":"section"},{"location":"mathematics/algebra/#Simplifying-Complex-Expressions","page":"Algebra","title":"Simplifying Complex Expressions","text":"simplify((x^2+2*x+1)/(x+1))\n# Output: x+1","category":"section"},{"location":"mathematics/algebra/#Equation-Solving","page":"Algebra","title":"Equation Solving","text":"","category":"section"},{"location":"mathematics/algebra/#Solving-Polynomial-Equations","page":"Algebra","title":"Solving Polynomial Equations","text":"Solve equations using the solve command:\n\nsolve(x^2 - 4, x)\n# Output: [-2, 2]\n\nsolve(x^2 - 1, x)\n# Output: [-1, 1]\n\nsolve(x^2 + 2*x + 1, x)\n# Output: [-1]","category":"section"},{"location":"mathematics/algebra/#Solving-Higher-Degree-Equations","page":"Algebra","title":"Solving Higher-Degree Equations","text":"solve(x^3 - 1, x)\n# Returns all roots including complex\n\nsolve(x^2 - 2, x)\n# Output includes sqrt(2) and -sqrt(2)","category":"section"},{"location":"mathematics/algebra/#GCD-and-LCM","page":"Algebra","title":"GCD and LCM","text":"","category":"section"},{"location":"mathematics/algebra/#Greatest-Common-Divisor","page":"Algebra","title":"Greatest Common Divisor","text":"Find the GCD of polynomials using the gcd command:\n\ngcd(x^2 - 1, x - 1)\n# Output: x-1\n\ngcd(x^2 - 4, x^2 - 4*x + 4)\n# Output: x-2","category":"section"},{"location":"mathematics/algebra/#Least-Common-Multiple","page":"Algebra","title":"Least Common Multiple","text":"Find the LCM of polynomials using the lcm command:\n\nlcm(x - 1, x + 1)\n# Output: (x-1)*(x+1) or equivalent\n\nlcm(x^2, x^3)\n# Output: x^3","category":"section"},{"location":"mathematics/algebra/#Polynomial-Division","page":"Algebra","title":"Polynomial Division","text":"","category":"section"},{"location":"mathematics/algebra/#Quotient","page":"Algebra","title":"Quotient","text":"Compute the quotient of polynomial division using the quo command:\n\nquo(x^3 - 1, x - 1)\n# Output: x^2+x+1\n\nquo(x^4, x^2)\n# Output: x^2","category":"section"},{"location":"mathematics/algebra/#Remainder","page":"Algebra","title":"Remainder","text":"Compute the remainder of polynomial division using the rem command:\n\nrem(x^3, x - 1)\n# Output: 1\n\nrem(x^3 + x, x^2 + 1)\n# Computes the polynomial remainder","category":"section"},{"location":"mathematics/algebra/#Quotient-and-Remainder-Together","page":"Algebra","title":"Quotient and Remainder Together","text":"For polynomial division, the relationship dividend = quotient * divisor + remainder always holds:\n\n# For x^3 - 1 divided by x - 1:\n# quo(x^3 - 1, x - 1) = x^2 + x + 1\n# rem(x^3 - 1, x - 1) = 0\n# Verification: (x - 1) * (x^2 + x + 1) = x^3 - 1 ✓","category":"section"},{"location":"mathematics/algebra/#Systems-of-Equations","page":"Algebra","title":"Systems of Equations","text":"","category":"section"},{"location":"mathematics/algebra/#Solving-Linear-Systems","page":"Algebra","title":"Solving Linear Systems","text":"Solve systems of equations by passing lists of equations and variables:\n\n@giac_var x y\n\n# System: x + y = 1, x - y = 0\nsolve([x + y ~ 1, x - y ~ 0], [x, y])\n# Output: [[1/2, 1/2]]","category":"section"},{"location":"mathematics/algebra/#Solving-Nonlinear-Systems","page":"Algebra","title":"Solving Nonlinear Systems","text":"# System: x^2 + y^2 = 1, x = y\nsolve([x^2 + y^2 ~ 1, x ~ y], [x, y])\n# Returns solutions on the unit circle where x = y","category":"section"},{"location":"mathematics/algebra/#Notes","page":"Algebra","title":"Notes","text":"All algebraic operations work symbolically, not numerically\nThe ~ operator creates equations for use with solve\nFor numerical solutions, convert results using to_julia\nsimplify may not always produce the simplest form; try normal for rational simplification\nfactor factors over the rationals by default; use cfactor for complex factorization\n\n","category":"section"},{"location":"developer/architecture/#Package-Architecture","page":"Package Architecture","title":"Package Architecture","text":"This page explains the internal structure of Giac.jl, helping developers understand how the package is organized and how components interact.","category":"section"},{"location":"developer/architecture/#Overview","page":"Package Architecture","title":"Overview","text":"Giac.jl wraps the GIAC computer algebra system (C++) for use in Julia. The package uses CxxWrap.jl for C++/Julia interoperability and provides a Julia-native API.\n\ngraph TB\n    subgraph Julia_User_Code[\"Julia User Code\"]\n        A[User Code]\n    end\n\n    subgraph Giac_jl_Package[\"Giac.jl Package\"]\n        B[\"api.jl (High-level API)\"]\n        C[\"command_utils.jl (giac_cmd)\"]\n        D[\"wrapper.jl (CxxWrap)\"]\n        E[\"types.jl (GiacExpr)\"]\n    end\n\n    subgraph External_Libraries[\"External Libraries\"]\n        F[\"libgiac-julia-wrapper\"]\n        G[\"libgiac (GIAC CAS)\"]\n    end\n\n    A --> B\n    A --> C\n    B --> D\n    C --> D\n    D --> F\n    F --> G\n    E -.-> D","category":"section"},{"location":"developer/architecture/#Source-File-Reference","page":"Package Architecture","title":"Source File Reference","text":"File Purpose Key Exports Dependencies\nGiac.jl Main module entry point Giac module All other files\ntypes.jl Type definitions GiacExpr, GiacContext, GiacMatrix, GiacError None\nwrapper.jl CxxWrap bindings, Tier 1/2 functions _giac_eval_string, _giac_*_tier1 types.jl\napi.jl High-level Julia API giac_eval, to_julia wrapper.jl, types.jl\ncommand_utils.jl Command invocation, Base extensions giac_cmd, Base.sin(::GiacExpr) wrapper.jl, types.jl\nCommands.jl Commands submodule invoke_cmd, ~2000 command functions command_utils.jl\ncommand_registry.jl Command discovery VALID_COMMANDS, suggest_commands None\nnamespace_commands.jl Namespace-specific commands Namespace command helpers command_registry.jl\noperators.jl Arithmetic operators +, -, *, /, ^ for GiacExpr types.jl\nmacros.jl User convenience macros @giac_var, @giac_several_vars api.jl\nutils.jl Helper utilities Internal utilities None\nTempApi.jl Temporary API submodule TempApi functions api.jl","category":"section"},{"location":"developer/architecture/#Module-Initialization","page":"Package Architecture","title":"Module Initialization","text":"When using Giac is executed, the following initialization sequence occurs:\n\nsequenceDiagram\n    participant User\n    participant Giac.jl\n    participant wrapper.jl\n    participant GiacCxxBindings\n    participant libgiac\n\n    User->>Giac.jl: using Giac\n    Giac.jl->>Giac.jl: include all source files\n    Giac.jl->>wrapper.jl: __init__()\n    wrapper.jl->>GiacCxxBindings: init_giac_library()\n    GiacCxxBindings->>libgiac: Load shared library (RTLD_GLOBAL)\n    libgiac-->>GiacCxxBindings: Library loaded\n    GiacCxxBindings-->>wrapper.jl: Ready\n    wrapper.jl->>Giac.jl: Create DEFAULT_CONTEXT\n    Giac.jl->>Giac.jl: _init_command_registry()\n    Giac.jl->>Commands.jl: Commands.__init__()\n    Commands.jl->>Commands.jl: Generate ~2000 command functions\n    Commands.jl-->>User: Ready to use","category":"section"},{"location":"developer/architecture/#What-Happens-in-__init__()","page":"Package Architecture","title":"What Happens in __init__()","text":"Library Loading: init_giac_library() loads the C++ wrapper library with RTLD_GLOBAL flag to ensure proper symbol resolution\nContext Creation: Creates DEFAULT_CONTEXT, the global evaluation context\nCommand Registry: Initializes the registry of valid GIAC commands\nCommands Module: Dynamically generates wrapper functions for all GIAC commands","category":"section"},{"location":"developer/architecture/#Type-System","page":"Package Architecture","title":"Type System","text":"Giac.jl defines four core types for working with GIAC:\n\nclassDiagram\n    class GiacExpr {\n        +Ptr~Cvoid~ ptr\n        +finalizer()\n        +show()\n        +getproperty()\n    }\n\n    class GiacContext {\n        +Ptr~Cvoid~ ptr\n        +ReentrantLock lock\n        +finalizer()\n    }\n\n    class GiacMatrix {\n        +Ptr~Cvoid~ ptr\n        +Int rows\n        +Int cols\n        +finalizer()\n        +getindex()\n    }\n\n    class GiacError {\n        +String message\n        +Symbol category\n    }\n\n    GiacExpr --> GiacContext : uses\n    GiacMatrix --> GiacExpr : contains","category":"section"},{"location":"developer/architecture/#GiacExpr","page":"Package Architecture","title":"GiacExpr","text":"The primary type representing a GIAC expression. Wraps a pointer to a C++ giac::gen object.\n\nmutable struct GiacExpr\n    ptr::Ptr{Cvoid}\nend\n\nAutomatic memory management: Uses Julia's finalizer to free C++ memory\nMethod-style syntax: Supports expr.factor() which translates to giac_cmd(:factor, expr)\nDisplay: Implements show for text and LaTeX output","category":"section"},{"location":"developer/architecture/#GiacContext","page":"Package Architecture","title":"GiacContext","text":"Evaluation context managing computation state.\n\nmutable struct GiacContext\n    ptr::Ptr{Cvoid}\n    lock::ReentrantLock\nend\n\nThread safety: Contains a ReentrantLock for concurrent access\nConfiguration: Holds computation settings (precision, assumptions, etc.)","category":"section"},{"location":"developer/architecture/#GiacMatrix","page":"Package Architecture","title":"GiacMatrix","text":"Symbolic matrix type with dimension tracking.\n\nmutable struct GiacMatrix\n    ptr::Ptr{Cvoid}\n    rows::Int\n    cols::Int\nend\n\nIndexing: Supports m[i,j] returning a GiacExpr\nConstruction: Can be created from Julia arrays or symbolically","category":"section"},{"location":"developer/architecture/#GiacError","page":"Package Architecture","title":"GiacError","text":"Exception type for GIAC-related errors.\n\nstruct GiacError <: Exception\n    message::String\n    category::Symbol  # :parse, :eval, :type, :memory\nend","category":"section"},{"location":"developer/architecture/#Data-Flow","page":"Package Architecture","title":"Data Flow","text":"A typical function call flows through the package like this:\n\nflowchart LR\n    A[\"User: sin(x)\"] --> B{GiacExpr?}\n    B -->|Yes| C[command_utils.jl]\n    B -->|No| D[Julia Base]\n    C --> E{Tier 1?}\n    E -->|Yes| F[\"wrapper.jl (_giac_sin_tier1)\"]\n    E -->|No| G[giac_cmd]\n    F --> H[C++ wrapper]\n    G --> I[String evaluation]\n    H --> J[libgiac]\n    I --> J\n    J --> K[\"Result: GiacExpr\"]","category":"section"},{"location":"developer/architecture/#File-Dependencies","page":"Package Architecture","title":"File Dependencies","text":"Understanding which files depend on which helps when making changes:\n\ngraph TD\n    A[types.jl] --> B[wrapper.jl]\n    A --> C[operators.jl]\n    B --> D[api.jl]\n    B --> E[command_utils.jl]\n    D --> F[macros.jl]\n    E --> G[Commands.jl]\n    H[command_registry.jl] --> E\n    H --> I[namespace_commands.jl]\n    D --> J[TempApi.jl]\n\n    K[Giac.jl] --> A\n    K --> B\n    K --> C\n    K --> D\n    K --> E\n    K --> F\n    K --> G\n    K --> H\n    K --> I\n    K --> J","category":"section"},{"location":"developer/architecture/#Where-to-Make-Changes","page":"Package Architecture","title":"Where to Make Changes","text":"Change Type Files to Modify\nAdd a new high-performance function wrapper.jl (Tier 1), command_utils.jl (Base extension)\nAdd a new type types.jl\nExtend an existing command command_utils.jl or Commands.jl\nAdd a new macro macros.jl\nModify operator behavior operators.jl\nChange initialization Giac.jl (__init__) or wrapper.jl\nAdd API documentation docstrings in relevant file","category":"section"},{"location":"developer/architecture/#See-Also","page":"Package Architecture","title":"See Also","text":"Performance Tiers - Deep dive into the tier system\nAdding Functions - Step-by-step contribution guide\nMemory Management - How memory is managed\n\n","category":"section"},{"location":"domains/signal/continuous_transforms/#Continuous-Time-Signal-Transforms","page":"Continuous-Time Transforms","title":"Continuous-Time Signal Transforms","text":"This page documents continuous-time signal processing functions in Giac.jl.","category":"section"},{"location":"domains/signal/continuous_transforms/#Laplace-Transform","page":"Continuous-Time Transforms","title":"Laplace Transform","text":"The Laplace transform is a mathematical tool for analyzing continuous-time signals and systems. GIAC provides two commands for computing Laplace transforms, available via Giac.Commands:\n\nlaplace(expr, t, s) - Computes the unilateral Laplace transform\nilaplace(expr, s, t) - Computes the inverse Laplace transform","category":"section"},{"location":"domains/signal/continuous_transforms/#Mathematical-Definition","page":"Continuous-Time Transforms","title":"Mathematical Definition","text":"The unilateral Laplace transform of a continuous function f(t) is defined as:\n\nF(s) = int_0^infty f(t) cdot e^-st  dt","category":"section"},{"location":"domains/signal/continuous_transforms/#Basic-Usage","page":"Continuous-Time Transforms","title":"Basic Usage","text":"using Giac\nusing Giac.Commands: laplace, ilaplace\n\n# Declare symbolic variables\n@giac_var t s a\n\n# Laplace transform of exponential decay exp(-a*t)\nF = laplace(exp(-a*t), t, s)\n# Returns 1/(a+s) which is equivalent to 1/(s+a)\n\n# Laplace transform of unit step (constant 1)\nF_step = laplace(1, t, s)\n# Returns 1/s\n\n# Laplace transform of ramp function t\nF_ramp = laplace(t, t, s)\n# Returns 1/s^2\n\n# Laplace transform of t^2\nF_t2 = laplace(t^2, t, s)\n# Returns 2/s^3","category":"section"},{"location":"domains/signal/continuous_transforms/#Inverse-Laplace-Transform","page":"Continuous-Time Transforms","title":"Inverse Laplace Transform","text":"using Giac\nusing Giac.Commands: ilaplace\n\n@giac_var t s a\n\n# Inverse Laplace transform of 1/s → unit step\nf_step = ilaplace(1/s, s, t)\n# Returns 1\n\n# Inverse Laplace transform of 1/(s+a) → exponential\nf_exp = ilaplace(1/(s+a), s, t)\n# Returns exp(-a*t)\n\n# Inverse Laplace transform of 1/s^2 → ramp\nf_ramp = ilaplace(1/s^2, s, t)\n# Returns t","category":"section"},{"location":"domains/signal/continuous_transforms/#Round-Trip-Verification","page":"Continuous-Time Transforms","title":"Round-Trip Verification","text":"The Laplace transform and inverse Laplace transform are mathematical inverses:\n\nusing Giac\nusing Giac.Commands: laplace, ilaplace, simplify\n\n@giac_var t s a\n\n# Verify: ilaplace(laplace(exp(-a*t))) = exp(-a*t)\noriginal = exp(-a*t)\ntransformed = laplace(original, t, s)\nrecovered = ilaplace(transformed, s, t)\nsimplified = simplify(recovered)\n# Result: exp(-a*t)","category":"section"},{"location":"domains/signal/continuous_transforms/#Common-Laplace-Transform-Pairs","page":"Continuous-Time Transforms","title":"Common Laplace Transform Pairs","text":"Time Domain f(t) S-Domain F(s) Region of Convergence\n1 (unit step) 1/s Re(s) > 0\nt (ramp) 1/s² Re(s) > 0\nt^n n!/s^(n+1) Re(s) > 0\nexp(-a*t) 1/(s+a) Re(s) > -Re(a)\nsin(w*t) w/(s²+w²) Re(s) > 0\ncos(w*t) s/(s²+w²) Re(s) > 0\nt·exp(-a*t) 1/(s+a)² Re(s) > -Re(a)","category":"section"},{"location":"domains/signal/continuous_transforms/#Using-invoke_cmd","page":"Continuous-Time Transforms","title":"Using invoke_cmd","text":"You can also use invoke_cmd directly:\n\nusing Giac\n\n@giac_var t s a\n\n# Using invoke_cmd\ninvoke_cmd(:laplace, exp(-a*t), t, s)\ninvoke_cmd(:ilaplace, 1/(s+a), s, t)","category":"section"},{"location":"domains/signal/continuous_transforms/#Notes","page":"Continuous-Time Transforms","title":"Notes","text":"Unilateral Transform: GIAC uses the unilateral Laplace transform (integration from t=0 to infinity), which is standard for causal systems.\nVariable Declaration: Always declare t and s as symbolic variables using @giac_var before using them in transforms.\nSimplification: Use simplify from Giac.Commands to reduce results to canonical form.","category":"section"},{"location":"domains/signal/continuous_transforms/#See-Also","page":"Continuous-Time Transforms","title":"See Also","text":"Discrete-Time Transforms - Z-transform and inverse Z-transform\nCalculus Operations - Integration, differentiation, and limits\nGIAC Laplace Documentation - Official GIAC documentation\n\n","category":"section"},{"location":"pluto/#Using-Giac.jl-with-Pluto-reactive-notebook","page":"Using with Pluto reactive notebooks","title":"Using Giac.jl with Pluto reactive notebook","text":"","category":"section"},{"location":"pluto/#LaTeX-Rendering-in-Pluto","page":"Using with Pluto reactive notebooks","title":"LaTeX Rendering in Pluto","text":"GiacExpr and GiacMatrix automatically render as LaTeX in Pluto notebooks! No extra conversion needed:\n\nusing Giac\n\nf = giac_eval(\"2/(1-x)\")  # Automatically displays as LaTeX fraction\ndf = invoke_cmd(:diff, f, giac_eval(\"x\"))  # Derivative also renders as LaTeX\n\nM = GiacMatrix([1 2; 3 4])  # Matrices render as LaTeX too\n\nThis works because Giac.jl implements Base.show(io, ::MIME\"text/latex\", expr) which calls GIAC's native latex command.\n\nA demo notebook is available at examples/latex_demo.jl:\n\nusing Pluto\nPluto.run(notebook=\"examples/latex_demo.jl\")\n\nSee screenshot:\n\n(Image: screencapture-pluto-notebook)\n\n","category":"section"},{"location":"mathematics/calculus/#Calculus","page":"Calculus","title":"Calculus","text":"Giac.jl provides powerful symbolic calculus capabilities including differentiation, integration, limits, and Taylor series expansion.","category":"section"},{"location":"mathematics/calculus/#Setup","page":"Calculus","title":"Setup","text":"using Giac\nusing Giac.Commands: diff, integrate, limit, series\n\n@giac_var x y","category":"section"},{"location":"mathematics/calculus/#Differentiation","page":"Calculus","title":"Differentiation","text":"","category":"section"},{"location":"mathematics/calculus/#Basic-Derivatives","page":"Calculus","title":"Basic Derivatives","text":"Compute derivatives using the diff command:\n\ndiff(x^2, x)\n# Output: 2*x\n\ndiff(x^3, x)\n# Output: 3*x^2","category":"section"},{"location":"mathematics/calculus/#Higher-Order-Derivatives","page":"Calculus","title":"Higher-Order Derivatives","text":"Compute second, third, or higher-order derivatives by specifying the order:\n\ndiff(x^4, x, 2)   # Second derivative\n# Output: 12*x^2\n\ndiff(x^5, x, 3)   # Third derivative\n# Output: 60*x^2","category":"section"},{"location":"mathematics/calculus/#Chain-Rule","page":"Calculus","title":"Chain Rule","text":"The chain rule is applied automatically:\n\ndiff(sin(x^2), x)\n# Output: 2*x*cos(x^2)","category":"section"},{"location":"mathematics/calculus/#Product-Rule","page":"Calculus","title":"Product Rule","text":"Derivatives of products are handled automatically:\n\ndiff(x * sin(x), x)\n# Output: sin(x)+x*cos(x)","category":"section"},{"location":"mathematics/calculus/#Partial-Derivatives","page":"Calculus","title":"Partial Derivatives","text":"For multivariable functions, specify the variable:\n\n@giac_var x y\n\ndiff(x^2 * y^3, x)\n# Output: 2*x*y^3\n\ndiff(x^2 * y^3, y)\n# Output: 3*x^2*y^2","category":"section"},{"location":"mathematics/calculus/#Integration","page":"Calculus","title":"Integration","text":"","category":"section"},{"location":"mathematics/calculus/#Indefinite-Integrals","page":"Calculus","title":"Indefinite Integrals","text":"Compute antiderivatives using the integrate command:\n\nintegrate(x^2, x)\n# Output: x^3/3\n\nintegrate(sin(x), x)\n# Output: -cos(x)\n\nintegrate(exp(x), x)\n# Output: exp(x)","category":"section"},{"location":"mathematics/calculus/#Definite-Integrals","page":"Calculus","title":"Definite Integrals","text":"Specify bounds for definite integrals:\n\n# ∫₀¹ x² dx = 1/3\nintegrate(x^2, x, 0, 1)\n# Output: 1/3\n\n# ∫₀^π sin(x) dx = 2\nintegrate(sin(x), x, 0, pi)\n# Output: 2","category":"section"},{"location":"mathematics/calculus/#Integration-Techniques","page":"Calculus","title":"Integration Techniques","text":"GIAC automatically applies various integration techniques:\n\n# Integration by parts\nintegrate(x * exp(x), x)\n# Output: (x-1)*exp(x)\n\n# Partial fractions\nintegrate(1/(x^2-1), x)\n# Uses partial fraction decomposition\n\n# Trigonometric integrals\nintegrate(sin(x)^2, x)\n# Output: x/2-sin(2*x)/4","category":"section"},{"location":"mathematics/calculus/#Limits","page":"Calculus","title":"Limits","text":"","category":"section"},{"location":"mathematics/calculus/#Basic-Limits","page":"Calculus","title":"Basic Limits","text":"Compute limits using the limit command:\n\n# Classic limit: sin(x)/x as x→0\nlimit(sin(x)/x, x, 0)\n# Output: 1","category":"section"},{"location":"mathematics/calculus/#Limits-at-Infinity","page":"Calculus","title":"Limits at Infinity","text":"@giac_var inf  # Create infinity symbol\n\nlimit(1/x, x, inf)\n# Output: 0\n\nlimit((x^2+1)/(2*x^2-3), x, inf)\n# Output: 1/2","category":"section"},{"location":"mathematics/calculus/#L'Hôpital's-Rule-Cases","page":"Calculus","title":"L'Hôpital's Rule Cases","text":"GIAC automatically handles indeterminate forms:\n\n# 0/0 form\nlimit((exp(x)-1)/x, x, 0)\n# Output: 1\n\n# ∞/∞ form\nlimit(ln(x)/x, x, inf)\n# Output: 0","category":"section"},{"location":"mathematics/calculus/#Taylor-Series","page":"Calculus","title":"Taylor Series","text":"","category":"section"},{"location":"mathematics/calculus/#Series-Expansion","page":"Calculus","title":"Series Expansion","text":"Expand functions as Taylor series using the series command:\n\n# exp(x) around x=0, order 4\nseries(exp(x), x, 0, 4)\n# Output: 1+x+x^2/2+x^3/6+x^4/24+O(x^5)\n\n# sin(x) around x=0, order 5\nseries(sin(x), x, 0, 5)\n# Output: x-x^3/6+x^5/120+O(x^6)\n\n# cos(x) around x=0, order 4\nseries(cos(x), x, 0, 4)\n# Output: 1-x^2/2+x^4/24+O(x^5)","category":"section"},{"location":"mathematics/calculus/#Series-Around-Other-Points","page":"Calculus","title":"Series Around Other Points","text":"Expand around a point other than zero:\n\n# exp(x) around x=1\nseries(exp(x), x, 1, 3)\n# Expansion around x=1","category":"section"},{"location":"mathematics/calculus/#Advanced-Topics","page":"Calculus","title":"Advanced Topics","text":"","category":"section"},{"location":"mathematics/calculus/#Gradient-and-Hessian","page":"Calculus","title":"Gradient and Hessian","text":"For multivariable calculus:\n\nusing Giac.Commands: gradient, hessian\n\n@giac_var x y\n\nf = x^2 + x*y + y^2\n\n# Gradient: [∂f/∂x, ∂f/∂y]\ngradient(f, [x, y])  # ToFix\n# Output: [2*x+y, x+2*y]\n\n# Hessian matrix\nhessian(f, [x, y])\n# Output: [[2, 1], [1, 2]]","category":"section"},{"location":"mathematics/calculus/#Implicit-Differentiation","page":"Calculus","title":"Implicit Differentiation","text":"using Giac.Commands: implicitdiff\n\n# For x² + y² = 1, find dy/dx\nimplicitdiff(x^2 + y^2 - 1, x, y)  # ToFix\n# Output: -x/y","category":"section"},{"location":"mathematics/calculus/#Notes","page":"Calculus","title":"Notes","text":"All calculus operations work symbolically, not numerically\nFor numerical integration, convert results using to_julia and use Julia's quadrature packages\nThe diff command uses Leibniz notation internally\nSeries expansions include the order term O(x^n) by default\n\n","category":"section"},{"location":"mathematics/linear_algebra/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"Giac.jl provides comprehensive symbolic linear algebra capabilities including matrix operations, determinants, eigenvalues, and linear system solving.","category":"section"},{"location":"mathematics/linear_algebra/#Setup","page":"Linear Algebra","title":"Setup","text":"using Giac, LinearAlgebra\nusing Giac.Commands: eigenvalues, linsolve\n\n@giac_var a b c d x y","category":"section"},{"location":"mathematics/linear_algebra/#Matrix-Creation","page":"Linear Algebra","title":"Matrix Creation","text":"","category":"section"},{"location":"mathematics/linear_algebra/#Numeric-Matrices","page":"Linear Algebra","title":"Numeric Matrices","text":"Create matrices from Julia arrays:\n\nA = GiacMatrix([1 2; 3 4])\n# 2×2 GiacMatrix:\n#  1  2\n#  3  4","category":"section"},{"location":"mathematics/linear_algebra/#Symbolic-Matrices","page":"Linear Algebra","title":"Symbolic Matrices","text":"Create matrices with symbolic entries:\n\n@giac_var a b c d\nB = GiacMatrix([[a, b],\n                [c, d]])\n# 2×2 GiacMatrix:\n#  a  b\n#  c  d","category":"section"},{"location":"mathematics/linear_algebra/#Symbol-Constructor","page":"Linear Algebra","title":"Symbol Constructor","text":"Create large symbolic matrices using the symbol constructor:\n\n@giac_several_vars m 2 2\nM = GiacMatrix([[m11, m12],\n                [m21, m22]])\ndet(M)  # m11*m22-m12*m21\n\n# Or use the compact constructor:\nM = GiacMatrix(:m, 3, 3)\n# 3×3 GiacMatrix with entries m11, m12, ...\n\nFor very large matrices:\n\nM = GiacMatrix(:m, 100, 100)\n# 100×100 GiacMatrix:\n#   m_1_1    m_1_2    m_1_3    ...    m_1_100\n#   m_2_1    m_2_2    m_2_3    ...    m_2_100\n#      ⋮        ⋮        ⋮     ⋱          ⋮\n# m_100_1  m_100_2  m_100_3   ...  m_100_100","category":"section"},{"location":"mathematics/linear_algebra/#Custom-Index-Ranges","page":"Linear Algebra","title":"Custom Index Ranges","text":"Create matrices with non-1-based indexing using UnitRange or StepRange arguments:\n\n# 0-based indexing (useful for physics, quantum mechanics)\nM = GiacMatrix(:ψ, 0:2, 0:2)\n# 3×3 GiacMatrix with entries ψ00, ψ01, ψ02, ψ10, ψ11, ...\n\n# Negative indices (useful for angular momentum states)\nJ = GiacMatrix(:J, -1:1)\n# 3×1 column vector with entries J_m1, J_0, J_1 (m = minus)\n\n# Custom ranges\nA = GiacMatrix(:A, 5:7, 1:3)\n# 3×3 GiacMatrix with entries A51, A52, A53, A61, ...\n\n# StepRange for even indices\nE = GiacMatrix(:E, 0:2:6)\n# 4×1 column vector with entries E0, E2, E4, E6\n\n# Mixed integer and range arguments\nM = GiacMatrix(:M, 3, 0:2)\n# 3×3 matrix: rows use 1:3, columns use 0:2\n# Entries: M10, M11, M12, M20, M21, M22, M30, M31, M32\n\nThe same range syntax works with @giac_several_vars:\n\n@giac_several_vars ψ 0:2\n# Creates: ψ0, ψ1, ψ2\n\n@giac_several_vars T 0:1 0:2\n# Creates: T00, T01, T02, T10, T11, T12\n\n@giac_several_vars c -1:1\n# Creates: c_m1, c_0, c_1 (m = minus for negative indices)\n\nNaming Convention:\n\nIndices 0-9: concatenated directly (e.g., m12, ψ00)\nIndices > 9: underscore separators (e.g., m_1_10)\nNegative indices: m prefix for minus (e.g., -1 → m1, so c_m1 for index -1)","category":"section"},{"location":"mathematics/linear_algebra/#Determinant","page":"Linear Algebra","title":"Determinant","text":"Compute the determinant using det:\n\nA = GiacMatrix([1 2; 3 4])\ndet(A)\n# Output: -2\n\n# Symbolic determinant\n@giac_var a b c d\nB = GiacMatrix([[a, b], [c, d]])\ndet(B)\n# Output: a*d-b*c","category":"section"},{"location":"mathematics/linear_algebra/#Inverse","page":"Linear Algebra","title":"Inverse","text":"Compute the matrix inverse using inv:\n\nA = GiacMatrix([1 2; 3 4])\ninv(A)\n# Returns the inverse matrix\n\nFor singular matrices, GIAC will return an error.","category":"section"},{"location":"mathematics/linear_algebra/#Trace","page":"Linear Algebra","title":"Trace","text":"Compute the trace (sum of diagonal elements) using tr:\n\nA = GiacMatrix([1 2; 3 4])\ntr(A)\n# Output: 5","category":"section"},{"location":"mathematics/linear_algebra/#Transpose","page":"Linear Algebra","title":"Transpose","text":"Compute the transpose using transpose:\n\nA = GiacMatrix([1 2; 3 4])\ntranspose(A)\n# 2×2 GiacMatrix:\n#  1  3\n#  2  4","category":"section"},{"location":"mathematics/linear_algebra/#Eigenvalues-and-Eigenvectors","page":"Linear Algebra","title":"Eigenvalues and Eigenvectors","text":"","category":"section"},{"location":"mathematics/linear_algebra/#Eigenvalues","page":"Linear Algebra","title":"Eigenvalues","text":"Compute eigenvalues using the eigenvalues command from Giac.Commands:\n\nusing Giac.Commands: eigenvalues\n\nA = GiacMatrix([2 1; 1 2])\n# Convert GiacMatrix to GiacExpr via ptr for eigenvalues command\neigenvalues(GiacExpr(A.ptr))\n# Output: 3,1","category":"section"},{"location":"mathematics/linear_algebra/#Characteristic-Polynomial","page":"Linear Algebra","title":"Characteristic Polynomial","text":"The characteristic polynomial can be computed for eigenvalue analysis.","category":"section"},{"location":"mathematics/linear_algebra/#Linear-System-Solving","page":"Linear Algebra","title":"Linear System Solving","text":"","category":"section"},{"location":"mathematics/linear_algebra/#Using-linsolve","page":"Linear Algebra","title":"Using linsolve","text":"Solve systems of linear equations using linsolve:\n\nusing Giac.Commands: linsolve\n\n@giac_var x y\n\n# System: x + y = 3, x - y = 1\nlinsolve([x + y ~ 3, x - y ~ 1], [x, y])\n# Output: [2, 1]","category":"section"},{"location":"mathematics/linear_algebra/#Using-solve","page":"Linear Algebra","title":"Using solve","text":"The general solve command also works for linear systems:\n\nusing Giac.Commands: solve\n\nsolve([x + y ~ 3, x - y ~ 1], [x, y])\n# Returns the solution","category":"section"},{"location":"mathematics/linear_algebra/#Matrix-Rank","page":"Linear Algebra","title":"Matrix Rank","text":"Compute the rank of a matrix using invoke_cmd(:rank, ...):\n\nA = GiacMatrix([1 2 3; 4 5 6; 7 8 9])\n# Use invoke_cmd because rank conflicts with LinearAlgebra.rank\n# Convert GiacMatrix to GiacExpr via ptr\ninvoke_cmd(:rank, GiacExpr(A.ptr))\n# Output: 2 (linearly dependent rows)","category":"section"},{"location":"mathematics/linear_algebra/#Matrix-Operations","page":"Linear Algebra","title":"Matrix Operations","text":"","category":"section"},{"location":"mathematics/linear_algebra/#Addition-and-Subtraction","page":"Linear Algebra","title":"Addition and Subtraction","text":"A = GiacMatrix([1 2; 3 4])\nB = GiacMatrix([5 6; 7 8])\n\nA + B\n# 2×2 GiacMatrix:\n#  6   8\n# 10  12\n\nA - B\n# 2×2 GiacMatrix:\n# -4  -4\n# -4  -4","category":"section"},{"location":"mathematics/linear_algebra/#Matrix-Multiplication","page":"Linear Algebra","title":"Matrix Multiplication","text":"A = GiacMatrix([1 2; 3 4])\nB = GiacMatrix([5 6; 7 8])\n\nA * B\n# 2×2 GiacMatrix:\n# 19  22\n# 43  50","category":"section"},{"location":"mathematics/linear_algebra/#Scalar-Multiplication","page":"Linear Algebra","title":"Scalar Multiplication","text":"A = GiacMatrix([1 2; 3 4])\n\n2 * A\n# 2×2 GiacMatrix:\n# 2  4\n# 6  8","category":"section"},{"location":"mathematics/linear_algebra/#Matrix-Powers","page":"Linear Algebra","title":"Matrix Powers","text":"A = GiacMatrix([1 2; 3 4])\n\nA^2\n# Computes A * A","category":"section"},{"location":"mathematics/linear_algebra/#Table-of-Functions","page":"Linear Algebra","title":"Table of Functions","text":"Function Description\nGiacMatrix(array) Create symbolic matrix from array\nGiacMatrix(:sym, m, n) Create m×n symbolic matrix (1-based)\nGiacMatrix(:sym, a:b, c:d) Create matrix with custom index ranges\nGiacMatrix(:sym, m, a:b) Mixed integer and range arguments\ndet(M) Determinant\ninv(M) Inverse\ntr(M) Trace\ntranspose(M) Transpose\neigenvalues(GiacExpr(M.ptr)) Eigenvalues\nlinsolve(eqs, vars) Solve linear system\ninvoke_cmd(:rank, GiacExpr(M.ptr)) Matrix rank","category":"section"},{"location":"mathematics/linear_algebra/#Notes","page":"Linear Algebra","title":"Notes","text":"All matrix operations work symbolically\nFor numerical evaluation, use to_julia to convert results\nLarge symbolic matrices can be created efficiently using the symbol constructor\nThe ~ operator creates equations for use with linsolve and solve\n\n","category":"section"},{"location":"physics/electromagnetism/#Electromagnetism","page":"Electromagnetism","title":"Electromagnetism","text":"Giac.jl enables symbolic solutions to electromagnetism problems, including electrostatics, circuit analysis, and electromagnetic waves.","category":"section"},{"location":"physics/electromagnetism/#Setup","page":"Electromagnetism","title":"Setup","text":"using Giac\nusing Giac.Commands: diff, integrate, solve, desolve\n\n@giac_var q r t V I R C L k","category":"section"},{"location":"physics/electromagnetism/#Electrostatics","page":"Electromagnetism","title":"Electrostatics","text":"","category":"section"},{"location":"physics/electromagnetism/#Coulomb's-Law","page":"Electromagnetism","title":"Coulomb's Law","text":"Calculate electric forces between point charges:\n\n@giac_var q1 q2 r k F\n\n# Coulomb's law: F = k*q1*q2/r²\n# Solve for distance given force\nsolve(F ~ k * q1 * q2 / r^2, r)\n# Returns r in terms of other variables\n\n# Solve for charge\nsolve(F ~ k * q1 * q2 / r^2, q1)\n# Output: [F*r^2/(k*q2)]","category":"section"},{"location":"physics/electromagnetism/#Electric-Field","page":"Electromagnetism","title":"Electric Field","text":"@giac_var q r k E\n\n# Electric field: E = k*q/r²\n# Solve for charge given field\nsolve(E ~ k * q / r^2, q)\n# Output: [E*r^2/k]","category":"section"},{"location":"physics/electromagnetism/#Electric-Potential","page":"Electromagnetism","title":"Electric Potential","text":"@giac_var q r k V\n\n# Electric potential: V = k*q/r\n# Solve for charge\nsolve(V ~ k * q / r, q) |> first |> simplify\n# Output: [V*r/k]\n\n# Relationship between field and potential\n# E = -dV/dr\nV_r = k * q / r\nE_r = -diff(V_r, r)\n# Output: k*q/r^2","category":"section"},{"location":"physics/electromagnetism/#Capacitor-Systems","page":"Electromagnetism","title":"Capacitor Systems","text":"@giac_var C1 C2 C_eq\n\n# Series capacitors: 1/C_eq = 1/C1 + 1/C2\nsolve(1/C_eq ~ 1/C1 + 1/C2, C_eq)\n\n# Parallel capacitors: C_eq = C1 + C2\nC_parallel = C1 + C2","category":"section"},{"location":"physics/electromagnetism/#Circuit-Analysis","page":"Electromagnetism","title":"Circuit Analysis","text":"","category":"section"},{"location":"physics/electromagnetism/#Ohm's-Law","page":"Electromagnetism","title":"Ohm's Law","text":"@giac_var V I R\n\n# Ohm's law: V = IR\nsolve(V ~ I * R, I)\n# Output: [V/R]\n\nsolve(V ~ I * R, R)\n# Output: [V/I]","category":"section"},{"location":"physics/electromagnetism/#RC-Circuits","page":"Electromagnetism","title":"RC Circuits","text":"Solve the RC circuit differential equation using the D operator:\n\n@giac_var t R C V(t)\n\n# Capacitor discharging: dV/dt + V/(RC) = 0 using D operator\node = D(V) + V/(R*C) ~ 0\ndesolve([ode], t, :V)\n# Output: V(t) = c_0*exp(-t/(R*C))\n\n# With initial condition, use function syntax from @giac_var V(t)\n# The solution will contain exp(-t/(R*C)) terms","category":"section"},{"location":"physics/electromagnetism/#Time-Constant","page":"Electromagnetism","title":"Time Constant","text":"@giac_var R C tau\n\n# Time constant: τ = RC\nsolve(tau ~ R * C, R)\n# Output: [tau/C]","category":"section"},{"location":"physics/electromagnetism/#RL-Circuits","page":"Electromagnetism","title":"RL Circuits","text":"Solve the RL circuit differential equation using the D operator:\n\n@giac_var t R L I(t) E\n\n# Current decay in RL circuit: dI/dt + (R/L)*I = 0 using D operator\node = D(I) + R/L*I ~ 0\ninitial = I(0) ~ E / R\ndesolve([ode, initial], t, :I)\n# Output: I(t) = E/R*exp(-R*t/L)\n\n# Time constant for RL circuit: τ = L/R\n# Initial current: I0 = E/R","category":"section"},{"location":"physics/electromagnetism/#RLC-Circuits","page":"Electromagnetism","title":"RLC Circuits","text":"@giac_var R L C omega\n\n# RLC resonance frequency: ω = 1/sqrt(LC)\nsolve(omega^2 ~ 1/(L*C), omega)\n# Output: [sqrt(1/(L*C)), -sqrt(1/(L*C))]","category":"section"},{"location":"physics/electromagnetism/#Energy-in-Electromagnetic-Systems","page":"Electromagnetism","title":"Energy in Electromagnetic Systems","text":"","category":"section"},{"location":"physics/electromagnetism/#Capacitor-Energy","page":"Electromagnetism","title":"Capacitor Energy","text":"@giac_var C V E Q\n\n# Energy stored in capacitor: E = (1/2)CV²\nsolve(E ~ C * V^2 / 2, V)\n# Output: [sqrt(2*E/C), -sqrt(2*E/C)]\n\n# Alternative form: E = Q²/(2C)\nsolve(E ~ Q^2 / (2 * C), Q)","category":"section"},{"location":"physics/electromagnetism/#Inductor-Energy","page":"Electromagnetism","title":"Inductor Energy","text":"@giac_var L I E\n\n# Energy stored in inductor: E = (1/2)LI²\nsolve(E ~ L * I^2 / 2, I)\n# Output: [sqrt(2*E/L), -sqrt(2*E/L)]","category":"section"},{"location":"physics/electromagnetism/#Power-Dissipation","page":"Electromagnetism","title":"Power Dissipation","text":"@giac_var P V I R\n\n# Power: P = IV = I²R = V²/R\nsolve(P ~ I * V, I)\n# Output: [P/V]\n\nsolve(P ~ I^2 * R, I)\n# Output: [sqrt(P/R), -sqrt(P/R)]","category":"section"},{"location":"physics/electromagnetism/#Electromagnetic-Waves","page":"Electromagnetism","title":"Electromagnetic Waves","text":"","category":"section"},{"location":"physics/electromagnetism/#Wave-Equation","page":"Electromagnetism","title":"Wave Equation","text":"@giac_var x t k omega E0\n\n# Electric field wave: E = E0*sin(kx - ωt)\nE = E0 * sin(k * x - omega * t)\n\n# Time derivative\ndE_dt = diff(E, t)\n# Output: -E0*omega*cos(k*x-omega*t)\n\n# Spatial derivative\ndE_dx = diff(E, x)\n# Output: E0*k*cos(k*x-omega*t)","category":"section"},{"location":"physics/electromagnetism/#Dispersion-Relation","page":"Electromagnetism","title":"Dispersion Relation","text":"@giac_var k omega c\n\n# For electromagnetic waves in vacuum: ω = c*k\nsolve(omega ~ c * k, k)\n# Output: [omega/c]","category":"section"},{"location":"physics/electromagnetism/#Wavelength-and-Frequency","page":"Electromagnetism","title":"Wavelength and Frequency","text":"@giac_var lambda f c\n\n# c = λf\nsolve(c ~ lambda * f, lambda)\n# Output: [c/f]","category":"section"},{"location":"physics/electromagnetism/#Table-of-Useful-Equations","page":"Electromagnetism","title":"Table of Useful Equations","text":"Equation Description\nF = k*q1*q2/r² Coulomb's law\nV = k*q/r Electric potential\nV = IR Ohm's law\nτ = RC RC time constant\nτ = L/R RL time constant\nω = 1/√(LC) RLC resonance\nE = (1/2)CV² Capacitor energy\nE = (1/2)LI² Inductor energy","category":"section"},{"location":"physics/electromagnetism/#Notes","page":"Electromagnetism","title":"Notes","text":"Use desolve for solving circuit differential equations\nThe time constant τ appears in exponential decay solutions\nFor AC circuits, complex impedance analysis can be performed symbolically\nElectromagnetic wave solutions involve sinusoidal functions\n\n","category":"section"},{"location":"variables/#Symbolic-variables","page":"Variable Declaration","title":"Symbolic variables","text":"","category":"section"},{"location":"variables/#Simple-Variable-Creation","page":"Variable Declaration","title":"Simple Variable Creation","text":"Create a symbolic variable with @giac_var:\n\nusing Giac\n\n@giac_var a\n@giac_var a\n\na + b\n\n# or simply\n\n@giac_var a b","category":"section"},{"location":"variables/#Batch-Variable-Creation","page":"Variable Declaration","title":"Batch Variable Creation","text":"Create multiple indexed symbolic variables with @giac_several_vars:\n\nusing Giac\n\n# 1D vector of variables\n@giac_several_vars a 3\n# Creates: a1, a2, a3\n# Returns: (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# 2D matrix of variables\n@giac_several_vars m 2 3\n# Creates: m11, m12, m13, m21, m22, m23 (row-major order)\n# Returns: (m11, m12, m13, m21, m22, m23)\n\n# N-dimensional tensors\n@giac_several_vars t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n\n# Large dimensions use underscore separators\n@giac_several_vars b 2 10\n# Creates: b_1_1, b_1_2, ..., b_2_10\n\n# Unicode base names supported\n@giac_several_vars α 2\n# Creates: α1, α2\n\n# Capture return tuple for iteration\nvars = @giac_several_vars c 4\nfor v in vars\n    println(v)\nend\n\n","category":"section"},{"location":"api/commands_submodule/#Commands-Submodule","page":"Commands submodule","title":"Commands Submodule","text":"The Giac.Commands submodule provides access to all exportable GIAC commands as Julia functions.","category":"section"},{"location":"api/commands_submodule/#Usage","page":"Commands submodule","title":"Usage","text":"","category":"section"},{"location":"api/commands_submodule/#Selective-Import-(Recommended)","page":"Commands submodule","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.Commands: factor, expand, diff\n\nexpr = giac_eval(\"x^2 - 1\")\nfactor(expr)  # (x-1)*(x+1)","category":"section"},{"location":"api/commands_submodule/#Full-Import","page":"Commands submodule","title":"Full Import","text":"using Giac\nusing Giac.Commands\n\n# All ~2000+ commands available\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))","category":"section"},{"location":"api/commands_submodule/#Qualified-Access","page":"Commands submodule","title":"Qualified Access","text":"using Giac\n\nGiac.Commands.factor(giac_eval(\"x^2-1\"))","category":"section"},{"location":"api/commands_submodule/#Core-Function","page":"Commands submodule","title":"Core Function","text":"","category":"section"},{"location":"api/commands_submodule/#Conflicting-Commands","page":"Commands submodule","title":"Conflicting Commands","text":"Commands that conflict with Julia keywords, builtins, or standard library functions are NOT exported from this module. Use invoke_cmd to call them:\n\n# These conflict with Julia and are NOT exported:\n# eval, sin, cos, det, inv, sum, prod, etc.\n\n# Use invoke_cmd instead:\ninvoke_cmd(:eval, expr)\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))\ninvoke_cmd(:det, matrix)\n\nSee JULIA_CONFLICTS for the complete list of conflicting commands.","category":"section"},{"location":"api/commands_submodule/#Available-Commands","page":"Commands submodule","title":"Available Commands","text":"Use exportable_commands() to get a list of all commands available in this module:\n\ncmds = exportable_commands()\nlength(cmds)  # ~2000+\n\n","category":"section"},{"location":"api/commands_submodule/#Giac.Commands","page":"Commands submodule","title":"Giac.Commands","text":"Giac.Commands\n\nA submodule containing all exportable GIAC commands as functions.\n\nThis module provides access to ~2000+ GIAC commands while keeping the main Giac namespace clean. Commands can be accessed through three patterns:\n\nAccess Patterns\n\nQualified access (cleanest namespace):\nusing Giac\nGiac.Commands.factor(expr)\nGiac.Commands.diff(expr, x)\nSelective import (recommended for most use cases):\nusing Giac\nusing Giac.Commands: factor, expand, diff\nfactor(expr)  # Works directly\nFull import (for interactive exploration):\nusing Giac\nusing Giac.Commands\nfactor(expr)   # All ~2000+ commands available\nifactor(expr)  # Works directly\n\nConflicting Commands\n\nCommands that conflict with Julia keywords, builtins, or standard library functions (like eval, sin, det) are NOT exported from this module. Use invoke_cmd to call them:\n\nusing Giac\ninvoke_cmd(:eval, expr)  # Works for any command\ninvoke_cmd(:sin, x)      # Including conflicting ones\n\nExports\n\ninvoke_cmd: Universal command invocation function\nAll ~2000+ non-conflicting GIAC commands (runtime-generated)\n\nSee also\n\ninvoke_cmd: Call any GIAC command by name\nGiac.JULIA_CONFLICTS: Commands that conflict with Julia\nGiac.exportable_commands: List of exportable commands\n\n\n\n\n\n","category":"module"},{"location":"api/commands_submodule/#Giac.Commands.invoke_cmd","page":"Commands submodule","title":"Giac.Commands.invoke_cmd","text":"invoke_cmd(cmd::Symbol, args...) -> GiacExpr\n\nInvoke any GIAC command by name and return the result as a GiacExpr.\n\nThis is the core function for dynamic command invocation, enabling access to all 2200+ GIAC commands through a uniform interface. It works for all commands, including those that conflict with Julia builtins.\n\nArguments\n\ncmd::Symbol: GIAC command name (e.g., :factor, :sin, :integrate)\nargs...: Command arguments (GiacExpr, String, Number, or Symbol)\n\nReturns\n\nGiacExpr: Result of command execution\n\nThrows\n\nGiacError(:eval): If command is unknown or execution fails\nArgumentError: If arguments cannot be converted to GIAC format\n\nExamples\n\nusing Giac\n\n# Single argument\nexpr = giac_eval(\"x^2 - 1\")\nresult = invoke_cmd(:factor, expr)  # Returns (x-1)*(x+1)\n\n# Multiple arguments\nx = giac_eval(\"x\")\nderivative = invoke_cmd(:diff, expr, x)  # Returns 2*x\n\n# Trigonometric functions (conflicts with Base)\nresult = invoke_cmd(:sin, giac_eval(\"pi/6\"))  # Returns 1/2\n\n# Evaluation (conflicts with Base.eval)\nresult = invoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\ngiac_eval: Direct string evaluation\nGiac.search_commands: Find available commands\ngiac_help: Get raw help for a command\n\n\n\n\n\n","category":"function"},{"location":"developer/tier-system/#Performance-Tier-System","page":"Performance Tiers","title":"Performance Tier System","text":"Giac.jl uses a three-tier performance system to balance execution speed with flexibility. Understanding this system is essential for contributing efficiently.","category":"section"},{"location":"developer/tier-system/#Overview","page":"Performance Tiers","title":"Overview","text":"graph TB\n    subgraph Performance_Pyramid[\"Performance Pyramid\"]\n        A[\"Tier 1: Direct C++ (~1-10μs)\"]\n        B[\"Tier 2: Generic Dispatch (~10-100μs)\"]\n        C[\"Tier 3: String Eval (~100μs-1ms)\"]\n    end\n\n    A --> B\n    B --> C\n\n    style A fill:#2ecc71\n    style B fill:#f1c40f\n    style C fill:#e74c3c\n\nTier Mechanism Performance Use Case\nTier 1 Direct C++ function call Fastest (~1-10μs) Frequently-used mathematical functions\nTier 2 Generic apply_funcN dispatch Medium (~10-100μs) Functions with C++ wrappers, any arity\nTier 3 String concatenation & eval Slowest (~100μs-1ms) All 2200+ GIAC commands (fallback)","category":"section"},{"location":"developer/tier-system/#Tier-1:-Direct-C-Wrappers","page":"Performance Tiers","title":"Tier 1: Direct C++ Wrappers","text":"Tier 1 provides the highest performance by calling C++ functions directly through CxxWrap bindings, with no name lookup or string processing.","category":"section"},{"location":"developer/tier-system/#How-It-Works","page":"Performance Tiers","title":"How It Works","text":"# In wrapper.jl\n_giac_sin_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sin, expr_ptr)\n\nThe _tier1_unary helper:\n\nConverts the pointer to a GIAC gen object\nCalls the C++ function directly\nConverts the result back to a pointer","category":"section"},{"location":"developer/tier-system/#Helper-Functions","page":"Performance Tiers","title":"Helper Functions","text":"Located in wrapper.jl:\n\nHelper Arity Lines\n_tier1_unary(func, ptr) 1 argument 946-959\n_tier1_binary(func, a, b) 2 arguments 961-976\n_tier1_ternary(func, a, b, c) 3 arguments 978-995","category":"section"},{"location":"developer/tier-system/#Complete-Tier-1-Function-List","page":"Performance Tiers","title":"Complete Tier 1 Function List","text":"Trigonometric (6 functions):\n\n_giac_sin_tier1, _giac_cos_tier1, _giac_tan_tier1\n_giac_asin_tier1, _giac_acos_tier1, _giac_atan_tier1\n\nExponential/Logarithmic (4 functions):\n\n_giac_exp_tier1, _giac_ln_tier1, _giac_log10_tier1, _giac_sqrt_tier1\n\nArithmetic (4 functions):\n\n_giac_abs_tier1, _giac_sign_tier1, _giac_floor_tier1, _giac_ceil_tier1\n\nComplex Numbers (3 functions):\n\n_giac_re_tier1, _giac_im_tier1, _giac_conj_tier1\n\nAlgebraic (2 functions):\n\n_giac_normal_tier1, _giac_evalf_tier1\n\nCalculus (6 functions):\n\n_giac_diff_tier1 (binary), _giac_integrate_tier1 (binary)\n_giac_subst_tier1 (ternary), _giac_solve_tier1 (binary)\n_giac_limit_tier1 (ternary), _giac_series_tier1 (ternary)\n\nBinary Operations (3 functions):\n\n_giac_gcd_tier1, _giac_lcm_tier1, _giac_pow_tier1","category":"section"},{"location":"developer/tier-system/#Tier-2:-Generic-C-Dispatch","page":"Performance Tiers","title":"Tier 2: Generic C++ Dispatch","text":"Tier 2 uses C++ generic dispatch functions (apply_func0, apply_func1, apply_func2, apply_func3, apply_funcN) to call GIAC functions by name with moderate overhead.","category":"section"},{"location":"developer/tier-system/#Available-Functions","page":"Performance Tiers","title":"Available Functions","text":"Function Arity Description\napply_func0(name) 0 Zero-argument functions (e.g., rand())\napply_func1(name, arg) 1 Single-argument functions\napply_func2(name, arg1, arg2) 2 Two-argument functions\napply_func3(name, arg1, arg2, arg3) 3 Three-argument functions\napply_funcN(name, args) N N-argument functions via StdVector{Gen}","category":"section"},{"location":"developer/tier-system/#How-It-Works-2","page":"Performance Tiers","title":"How It Works","text":"# In wrapper.jl\nfunction _apply_func_generic(name::String, args::Vector{String})::Ptr{Cvoid}\n    gen_args = [GiacCxxBindings.giac_eval(arg) for arg in args]\n\n    result_gen = if length(gen_args) == 0\n        GiacCxxBindings.apply_func0(name)\n    elseif length(gen_args) == 1\n        GiacCxxBindings.apply_func1(name, gen_args[1])\n    elseif length(gen_args) == 2\n        GiacCxxBindings.apply_func2(name, gen_args[1], gen_args[2])\n    elseif length(gen_args) == 3\n        GiacCxxBindings.apply_func3(name, gen_args[1], gen_args[2], gen_args[3])\n    else\n        # N>3 args: use apply_funcN with StdVector\n        std_vec = GiacCxxBindings.StdVector{GiacCxxBindings.Gen}()\n        for g in gen_args\n            push!(std_vec, g)\n        end\n        GiacCxxBindings.apply_funcN(name, std_vec)\n    end\n\n    return _make_stub_ptr(GiacCxxBindings.to_string(result_gen))\nend","category":"section"},{"location":"developer/tier-system/#Examples-of-N-ary-Functions-(4-parameters)","page":"Performance Tiers","title":"Examples of N-ary Functions (4+ parameters)","text":"# series(expr, var, point, order) - 4 params\ngiac_eval(\"series(exp(x),x,0,4)\")  # Taylor expansion\n\n# sum(expr, var, start, end) - 4 params\ngiac_eval(\"sum(k,k,1,10)\")  # = 55\n\n# product(expr, var, start, end) - 4 params\ngiac_eval(\"product(k,k,1,5)\")  # = 120\n\n# seq(expr, var, start, end) - 4 params\ngiac_eval(\"seq(k^2,k,1,5)\")  # = [1,4,9,16,25]","category":"section"},{"location":"developer/tier-system/#When-Tier-2-Is-Used","page":"Performance Tiers","title":"When Tier 2 Is Used","text":"Functions with any number of arguments that don't have Tier 1 wrappers\nAutomatic fallback when Tier 1 fails\nWhen giac_cmd is called","category":"section"},{"location":"developer/tier-system/#Tier-3:-String-Evaluation","page":"Performance Tiers","title":"Tier 3: String Evaluation","text":"Tier 3 is the universal fallback that works for all 2200+ GIAC commands by building a command string and evaluating it.","category":"section"},{"location":"developer/tier-system/#How-It-Works-3","page":"Performance Tiers","title":"How It Works","text":"flowchart LR\n    A[\"giac_cmd(:factor, x)\"] --> B[\"_arg_to_giac_string(x)\"]\n    B --> C[\"_build_command_string\"]\n    C --> D[\"'factor(x)'\"]\n    D --> E[\"giac_eval(cmd_string)\"]\n    E --> F[\"GiacExpr result\"]","category":"section"},{"location":"developer/tier-system/#The-Command-Flow","page":"Performance Tiers","title":"The Command Flow","text":"Located in command_utils.jl (lines 109-143):\n\nfunction giac_cmd(cmd::Symbol, args...)::GiacExpr\n    cmd_str = string(cmd)\n\n    # 1. Validate command exists\n    if !isempty(VALID_COMMANDS) && cmd_str ∉ VALID_COMMANDS\n        throw(GiacError(\"Unknown command: $cmd_str\", :eval))\n    end\n\n    # 2. Convert arguments to strings\n    arg_strings = [_arg_to_giac_string(arg) for arg in args]\n\n    # 3. Build command string: \"factor(x^2-1)\"\n    cmd_string = _build_command_string(cmd_str, arg_strings)\n\n    # 4. Evaluate with thread safety\n    return with_giac_lock() do\n        giac_eval(cmd_string)\n    end\nend","category":"section"},{"location":"developer/tier-system/#Argument-Conversion","page":"Performance Tiers","title":"Argument Conversion","text":"The _arg_to_giac_string function (lines 20-43) handles various types:\n\nType Conversion\nGiacExpr string(expr)\nString Pass through\nNumber string(n)\nSymbol string(sym)\nAbstractVector \"[elem1,elem2,...]\"","category":"section"},{"location":"developer/tier-system/#The-_tier1_or_fallback-Pattern","page":"Performance Tiers","title":"The _tier1_or_fallback Pattern","text":"This pattern elegantly bridges Tier 1 and Tier 3, trying the fast path first and falling back if needed.","category":"section"},{"location":"developer/tier-system/#Implementation","page":"Performance Tiers","title":"Implementation","text":"Located in command_utils.jl (lines 152-180):\n\nfunction _tier1_or_fallback(tier1_func::Function, cmd::Symbol, expr::GiacExpr)::GiacExpr\n    result_ptr = tier1_func(expr.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)  # Tier 1 succeeded\n    end\n    return giac_cmd(cmd, expr)  # Fall back to Tier 3\nend\n\nfunction _tier1_or_fallback_binary(tier1_func, cmd, a::GiacExpr, b::GiacExpr)\n    result_ptr = tier1_func(a.ptr, b.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)\n    end\n    return giac_cmd(cmd, a, b)\nend\n\nfunction _tier1_or_fallback_ternary(tier1_func, cmd, a, b, c)\n    result_ptr = tier1_func(a.ptr, b.ptr, c.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)\n    end\n    return giac_cmd(cmd, a, b, c)\nend","category":"section"},{"location":"developer/tier-system/#Usage-in-Base-Extensions","page":"Performance Tiers","title":"Usage in Base Extensions","text":"# In command_utils.jl - extending Julia's Base functions\nBase.sin(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sin_tier1, :sin, expr)\n\nBase.gcd(a::GiacExpr, b::GiacExpr)::GiacExpr =\n    _tier1_or_fallback_binary(_giac_gcd_tier1, :gcd, a, b)","category":"section"},{"location":"developer/tier-system/#Performance-Implications","page":"Performance Tiers","title":"Performance Implications","text":"","category":"section"},{"location":"developer/tier-system/#Choosing-the-Right-Tier","page":"Performance Tiers","title":"Choosing the Right Tier","text":"flowchart TD\n    A[New Function] --> B{Frequently used?}\n    B -->|Yes| C{C++ wrapper exists?}\n    B -->|No| D[Use Tier 2/3: giac_cmd]\n    C -->|Yes| E[Add Tier 1 wrapper]\n    C -->|No| F[Tier 2 automatic for any arity]","category":"section"},{"location":"developer/tier-system/#Performance-Comparison","page":"Performance Tiers","title":"Performance Comparison","text":"Operation Tier 1 Tier 2 Tier 3\nSimple unary (sin, cos) ~2μs ~20μs ~200μs\nBinary (gcd, pow) ~3μs ~25μs ~250μs\nComplex expression ~5μs ~50μs ~500μs\n\nNote: Actual performance varies by system and expression complexity","category":"section"},{"location":"developer/tier-system/#When-Tier-Fallback-Occurs","page":"Performance Tiers","title":"When Tier Fallback Occurs","text":"Tier 1 falls back to Tier 3 when:\n\nThe C++ function returns an error\nMemory allocation fails\nThe library is in stub mode (testing)\n\nTier 2 falls back to Tier 3 when:\n\nGeneric dispatch fails\nAn exception occurs during evaluation","category":"section"},{"location":"developer/tier-system/#Determining-Which-Tier-Is-Used","page":"Performance Tiers","title":"Determining Which Tier Is Used","text":"To predict which tier handles a function call:\n\nCheck if it's a Base extension (sin, cos, sqrt, etc.):\nIf Tier 1 function exists → Tier 1 with fallback\nOtherwise → Tier 2/3\nUsing giac_cmd directly:\nAny arity with C++ support → Tier 2\nFallback on error → Tier 3\nUsing Commands submodule (using Giac.Commands: factor):\nGoes through invoke_cmd → Tier 2/3","category":"section"},{"location":"developer/tier-system/#See-Also","page":"Performance Tiers","title":"See Also","text":"Adding Functions - How to add functions at each tier\nPackage Architecture - Overall package structure\n\n","category":"section"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"using Giac\nusing Giac.Commands: factor, expand, diff, integrate, limit, simplify, solve\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())  # if library is installed correctly it should return false\n\n# Basic evaluation through GIAC\nresult = giac_eval(\"2 + 3\")        # 5\nfactored = giac_eval(\"factor(x^2 - 1)\")  # (x-1)*(x+1)\n\n# Create symbolic variables\n@giac_var x y\n\n# Arithmetic\nprintln(x + y)   # x+y\nprintln(x * y)   # x*y\nprintln(x ^ 2)   # x^2\n\n# Evaluate expressions\nexpr = x^2 + 2*x*y + y^2\n\n# Factor polynomials\nresult = factor(expr)  # Returns (x+y)^2\n\n# Differentiate\nderivative = diff(result, x)  # Returns 2*(x+y)\n\n# Integrate\nintegral = integrate(x^2, x)  # Returns x^3/3\n\n# Calculus using Giac.Commands\nf = giac_eval(\"x^3\")\n# or using simpler syntax\nf = x^3\ndf = diff(f, x)                    # 3*x^2\nF = integrate(f, x)                # x^4/4\nf = sin(x)/x  # or using more heavy syntax giac_eval(\"sin(x)/x\")\nlim = limit(f, x, 0)  # 1\n\n# Algebra using Giac.Commands\nfactor(x^2 - 1)           # (x-1)*(x+1)\nexpand((x+1)^3)           # x^3+3*x^2+3*x+1\nsimplify((x^2-1)/(x-1))   # x+1\nsolve(x^2 - 4, x)         # list[-2,2]\n\n# Equation syntax using ~ operator (Symbolics.jl convention)\neq = x^2 - 1 ~ 0                       # Creates equation: x^2-1=0\nsolve(eq, x)                           # Solves: [-1, 1]\n\n# ~ works with mixed types\neq1 = x ~ 5                            # x=5\neq2 = 0 ~ x^2 - 4                      # 0=x^2-4\n\n# Mixed-type arithmetic with Julia numbers\nx - (1//2)                             # x-1/2 (Rational)\nx + (1 + 2im)                          # x+1+2*i (Complex)\nx + π                                  # x+pi (Irrational)\nx * ℯ                                  # e*x (Euler's number)\n\n# Or use invoke_cmd for any command\ninvoke_cmd(:factor, giac_eval(\"x^2 - 1\"))  # (x-1)*(x+1)\n\n# Convert to Julia types\nto_julia(giac_eval(\"42\"))    # 42::Int64\nto_julia(giac_eval(\"3/4\"))   # 3//4::Rational{Int64}\n# or using |> operator\ngiac_eval(\"3/4\") |> to_julia\n\n","category":"section"},{"location":"developer/contributing/#Adding-Functions-to-Giac.jl","page":"Adding Functions","title":"Adding Functions to Giac.jl","text":"This guide walks you through adding new mathematical functions to Giac.jl at each performance tier.","category":"section"},{"location":"developer/contributing/#Decision-Tree","page":"Adding Functions","title":"Decision Tree","text":"Use this flowchart to determine which tier to use for your new function:\n\nflowchart TD\n    A[New Function to Add] --> B{Is it frequently used?}\n    B -->|Yes| C{C++ wrapper exists?}\n    B -->|No| D[Use Tier 3: giac_cmd]\n\n    C -->|Yes| E[Add Tier 1 Wrapper]\n    C -->|No| F{Can add C++ wrapper?}\n\n    F -->|Yes| G[Add C++ wrapper, then Tier 1]\n    F -->|No| H{1-3 arguments?}\n\n    H -->|Yes| I[Tier 2 via apply_func]\n    H -->|No| D\n\n    E --> J[Add Base extension]\n    G --> J\n    I --> K[Use giac_cmd directly]\n    D --> L[Add to Commands submodule]\n\n    style E fill:#2ecc71\n    style G fill:#2ecc71\n    style I fill:#f1c40f\n    style D fill:#e74c3c\n    style L fill:#e74c3c","category":"section"},{"location":"developer/contributing/#Step-by-Step:-Adding-a-Tier-1-Function","page":"Adding Functions","title":"Step-by-Step: Adding a Tier 1 Function","text":"Adding a Tier 1 function requires modifications to two files and provides the best performance.","category":"section"},{"location":"developer/contributing/#Prerequisites","page":"Adding Functions","title":"Prerequisites","text":"Confirm the C++ function exists in libgiac-julia-wrapper\nKnow the function's arity (number of arguments)\nKnow the GIAC command name","category":"section"},{"location":"developer/contributing/#Step-1:-Add-the-Tier-1-Wrapper","page":"Adding Functions","title":"Step 1: Add the Tier 1 Wrapper","text":"In src/wrapper.jl, add the wrapper function after the existing Tier 1 functions (around line 1038):\n\n# For unary functions (1 argument)\n_giac_sinh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sinh, expr_ptr)\n\n# For binary functions (2 arguments)\n_giac_hypot_tier1(a_ptr::Ptr{Cvoid}, b_ptr::Ptr{Cvoid}) =\n    _tier1_binary(GiacCxxBindings.giac_hypot, a_ptr, b_ptr)\n\n# For ternary functions (3 arguments)\n_giac_horner_tier1(a::Ptr{Cvoid}, b::Ptr{Cvoid}, c::Ptr{Cvoid}) =\n    _tier1_ternary(GiacCxxBindings.giac_horner, a, b, c)","category":"section"},{"location":"developer/contributing/#Step-2:-Add-the-Base-Extension","page":"Adding Functions","title":"Step 2: Add the Base Extension","text":"In src/command_utils.jl, add the user-facing function (around line 330):\n\n# For unary functions\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)\n\n# For binary functions\nBase.hypot(a::GiacExpr, b::GiacExpr)::GiacExpr =\n    _tier1_or_fallback_binary(_giac_hypot_tier1, :hypot, a, b)","category":"section"},{"location":"developer/contributing/#Step-3:-Export-the-Function-(if-needed)","page":"Adding Functions","title":"Step 3: Export the Function (if needed)","text":"If extending a Base function, no export is needed. For new functions, add to exports in src/Giac.jl:\n\nexport my_new_function","category":"section"},{"location":"developer/contributing/#Step-4:-Add-Tests","page":"Adding Functions","title":"Step 4: Add Tests","text":"In test/test_commands.jl:\n\n@testset \"sinh function\" begin\n    x = giac_eval(\"x\")\n\n    # Test symbolic evaluation\n    result = sinh(x)\n    @test result isa GiacExpr\n    @test string(result) == \"sinh(x)\"\n\n    # Test numeric evaluation\n    result_num = sinh(giac_eval(\"0\"))\n    @test to_julia(result_num) == 0\nend","category":"section"},{"location":"developer/contributing/#Step-5:-Add-Documentation","page":"Adding Functions","title":"Step 5: Add Documentation","text":"Add a docstring to your function:\n\n\"\"\"\n    sinh(expr::GiacExpr) -> GiacExpr\n\nCompute the hyperbolic sine of a GIAC expression.\n\n# Examples\n\njldoctest julia> using Giac\n\njulia> x = giac_eval(\"x\") x\n\njulia> sinh(x) sinh(x)\n\n\"\"\"\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)","category":"section"},{"location":"developer/contributing/#Step-by-Step:-Adding-a-Tier-2/3-Function","page":"Adding Functions","title":"Step-by-Step: Adding a Tier 2/3 Function","text":"For functions that don't need maximum performance or don't have C++ wrappers.","category":"section"},{"location":"developer/contributing/#Option-A:-Using-giac_cmd-Directly","page":"Adding Functions","title":"Option A: Using giac_cmd Directly","text":"For occasional use, simply call giac_cmd:\n\n# In your code\nresult = giac_cmd(:my_function, arg1, arg2)","category":"section"},{"location":"developer/contributing/#Option-B:-Adding-to-Commands-Submodule","page":"Adding Functions","title":"Option B: Adding to Commands Submodule","text":"For functions you want accessible via Giac.Commands:\n\nIn src/Commands.jl, the functions are auto-generated from VALID_COMMANDS. To add a custom function:\n\n# In src/Commands.jl or command_utils.jl\n\"\"\"\n    my_special_function(expr) -> GiacExpr\n\nCompute something special.\n\"\"\"\nfunction my_special_function(expr::GiacExpr)::GiacExpr\n    return giac_cmd(:my_special_function, expr)\nend\n\nexport my_special_function","category":"section"},{"location":"developer/contributing/#Option-C:-Creating-a-Convenience-Wrapper","page":"Adding Functions","title":"Option C: Creating a Convenience Wrapper","text":"For better ergonomics, create a dedicated function:\n\n# In src/api.jl or a new file\n\"\"\"\n    partial_fractions(expr, var) -> GiacExpr\n\nCompute partial fraction decomposition of `expr` with respect to `var`.\n\"\"\"\nfunction partial_fractions(expr::GiacExpr, var::GiacExpr)::GiacExpr\n    return giac_cmd(:partfrac, expr, var)\nend\n\nexport partial_fractions","category":"section"},{"location":"developer/contributing/#Extending-Base-Functions","page":"Adding Functions","title":"Extending Base Functions","text":"When extending Julia's Base module functions, follow these guidelines:","category":"section"},{"location":"developer/contributing/#Pattern-for-GiacExpr","page":"Adding Functions","title":"Pattern for GiacExpr","text":"# Correct: Use _tier1_or_fallback when Tier 1 exists\nBase.sin(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sin_tier1, :sin, expr)\n\n# Correct: Use giac_cmd when no Tier 1\nBase.sinc(expr::GiacExpr)::GiacExpr =\n    giac_cmd(:sinc, expr)","category":"section"},{"location":"developer/contributing/#Avoiding-Type-Piracy","page":"Adding Functions","title":"Avoiding Type Piracy","text":"Only extend Base functions for types you own (GiacExpr, GiacMatrix):\n\n# Good: Extending for our type\nBase.sin(expr::GiacExpr) = ...\n\n# Bad: This would be type piracy\nBase.sin(x::Float64) = ...  # Don't do this!","category":"section"},{"location":"developer/contributing/#Method-Signatures","page":"Adding Functions","title":"Method Signatures","text":"Match Julia's expected signatures where possible:\n\n# Good: Matches Base.diff signature pattern\nBase.diff(f::GiacExpr, x::GiacExpr) = giac_diff(f, x)\n\n# For multiple dispatch\nBase.diff(f::GiacExpr, x::GiacExpr, n::Integer) = giac_diff(f, x, n)","category":"section"},{"location":"developer/contributing/#Complete-Example:-Adding-sinh","page":"Adding Functions","title":"Complete Example: Adding sinh","text":"Here's a complete example of adding the hyperbolic sine function.","category":"section"},{"location":"developer/contributing/#1.-Check-C-Availability","page":"Adding Functions","title":"1. Check C++ Availability","text":"First, verify giac_sinh exists in GiacCxxBindings:\n\n# In Julia REPL\nusing Giac\nhasmethod(Giac.GiacCxxBindings.giac_sinh, Tuple{Any})","category":"section"},{"location":"developer/contributing/#2.-Add-Tier-1-Wrapper-(wrapper.jl)","page":"Adding Functions","title":"2. Add Tier 1 Wrapper (wrapper.jl)","text":"# Add after line ~1037 in wrapper.jl\n\n# Hyperbolic trigonometry (Tier 1)\n_giac_sinh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sinh, expr_ptr)\n_giac_cosh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_cosh, expr_ptr)\n_giac_tanh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_tanh, expr_ptr)","category":"section"},{"location":"developer/contributing/#3.-Add-Base-Extension-(command_utils.jl)","page":"Adding Functions","title":"3. Add Base Extension (command_utils.jl)","text":"# Add after line ~330 in command_utils.jl\n\n# Hyperbolic functions\n\"\"\"\n    sinh(expr::GiacExpr) -> GiacExpr\n\nCompute the hyperbolic sine of a GIAC expression.\n\n# Examples\n\njldoctest julia> using Giac\n\njulia> sinh(giac_eval(\"0\")) 0\n\n\"\"\"\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)\n\nBase.cosh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_cosh_tier1, :cosh, expr)\n\nBase.tanh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_tanh_tier1, :tanh, expr)","category":"section"},{"location":"developer/contributing/#4.-Add-Tests-(test/test_commands.jl)","page":"Adding Functions","title":"4. Add Tests (test/test_commands.jl)","text":"@testset \"Hyperbolic functions\" begin\n    x = giac_eval(\"x\")\n\n    @testset \"sinh\" begin\n        @test sinh(x) isa GiacExpr\n        @test string(sinh(x)) == \"sinh(x)\"\n        @test to_julia(sinh(giac_eval(\"0\"))) == 0\n    end\n\n    @testset \"cosh\" begin\n        @test cosh(x) isa GiacExpr\n        @test to_julia(cosh(giac_eval(\"0\"))) == 1\n    end\n\n    @testset \"tanh\" begin\n        @test tanh(x) isa GiacExpr\n        @test to_julia(tanh(giac_eval(\"0\"))) == 0\n    end\nend","category":"section"},{"location":"developer/contributing/#5.-Run-Tests","page":"Adding Functions","title":"5. Run Tests","text":"julia --project -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"developer/contributing/#Checklist-for-Adding-Functions","page":"Adding Functions","title":"Checklist for Adding Functions","text":"[ ] Determine the appropriate tier (1, 2, or 3)\n[ ] If Tier 1: Add wrapper in wrapper.jl\n[ ] Add user-facing function in command_utils.jl or api.jl\n[ ] Add docstring with examples\n[ ] Add tests in test/\n[ ] Run test suite\n[ ] Update documentation if needed","category":"section"},{"location":"developer/contributing/#See-Also","page":"Adding Functions","title":"See Also","text":"Performance Tiers - Detailed tier system explanation\nPackage Architecture - Where files are located\nMemory Management - Important for wrapped types\n\n","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help","page":"Command discovery and help","title":"Command Discovery and Help","text":"","category":"section"},{"location":"command_discovery_help/#Command-Discovery","page":"Command discovery and help","title":"Command Discovery","text":"using Giac\n\n# Search for commands by prefix\nsearch_commands(\"sin\")        # [\"sin\", \"sinc\", \"sinh\", ...]\n\n# Search with regex\nsearch_commands(r\"^a.*n$\")    # Commands starting with 'a' and ending with 'n'\n\n# Search by description (find commands by what they do)\nsearch_commands_by_description(\"polynomial\")  # Commands related to polynomials\nsearch_commands_by_description(\"matrix\", n=5) # Limit to 5 results\n\n# Get command metadata\ninfo = command_info(:factor)\ninfo.name                     # \"factor\"\ninfo.category                 # :algebra\n\n# List available categories\nlist_categories()             # [:trigonometry, :calculus, :algebra, ...]\n\n# Get commands in a category\ncommands_in_category(:trigonometry)  # [\"sin\", \"cos\", \"tan\", \"asin\", ...]\ncommands_in_category(:calculus)      # [\"diff\", \"integrate\", \"limit\", ...]\ncommands_in_category(:algebra)       # [\"factor\", \"expand\", \"simplify\", ...]","category":"section"},{"location":"command_discovery_help/#Help-System","page":"Command discovery and help","title":"Help System","text":"Use Julia's native help system to get documentation for GIAC commands:\n\nusing Giac\nusing Giac.Commands: factor, sin\n\n# Use Julia's native help system (recommended)\n?factor\n#   factor(expr::GiacInput, args...)\n#\n#   GIAC command: `factor`\n#\n#   Factorizes a polynomial.\n#\n#   # Related Commands\n#   - `ifactor`\n#   - `partfrac`\n#   - `normal`\n#\n#   # Examples (GIAC syntax)\n#   factor(x^4-1)\n#   factor(x^4-4,sqrt(2))\n\n# Or use @doc macro\n@doc factor\n\n# For programmatic access to raw help text\nhelp_text = giac_help(:factor)\n\n# List all available commands\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))  # 2215\n\n# Get help count\nprintln(\"Help entries: \", help_count())  # 2215\n\nnote: Internal help() Function\nThe help(:cmd) function is no longer exported. Use ?cmd for interactive help or giac_help(:cmd) for programmatic access to raw help text.","category":"section"},{"location":"command_discovery_help/#Command-Suggestions","page":"Command discovery and help","title":"Command Suggestions","text":"When you mistype a command, Giac.jl automatically suggests similar commands:\n\nusing Giac\n\n# Get suggestions programmatically\nsuggest_commands(:factr)        # [\"factor\", \"cfactor\", \"ifactor\", ...]\nsuggest_commands(:integrat)     # [\"integrate\", \"integral\", ...]\n\n# Configure number of suggestions\nget_suggestion_count()          # 4 (default)\nset_suggestion_count(6)         # Show more suggestions\n\n# Get suggestions with edit distances\nGiac.suggest_commands_with_distances(:factr)\n# [(\"factor\", 1), (\"cfactor\", 2), (\"ifactor\", 2), ...]\n\nThe suggestion system uses Levenshtein edit distance with an adaptive threshold based on input length.","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help-2","page":"Command discovery and help","title":"Command Discovery & Help","text":"Function Description\n?cmd View help in REPL (after importing cmd from Giac.Commands)\ngiac_help(cmd) Get raw help text as a string\nlist_commands() List all available GIAC commands\nhelp_count() Number of commands in help database\nsearch_commands(pattern) Search commands by prefix or regex\ncommand_info(cmd) Get CommandInfo with name, category, aliases\nlist_categories() List all command categories\ncommands_in_category(cat) List commands in a category\nsuggest_commands(input) Suggest similar commands for mistyped input\nset_suggestion_count(n) Set number of suggestions (default: 4)\nget_suggestion_count() Get current suggestion count\nsearch_commands_by_description(query; n=20) Search commands by help text keywords","category":"section"},{"location":"command_discovery_help/#Command-Access","page":"Command discovery and help","title":"Command Access","text":"Function Description\navailable_commands() List all commands starting with ASCII letters\nexportable_commands() List commands safe to export (no Julia conflicts)\nis_valid_command(name) Check if a command name is valid\nconflict_reason(cmd) Get why a command conflicts (:keyword, :builtin, etc.)\nJULIA_CONFLICTS Set of commands that conflict with Julia\nreset_conflict_warnings!() Reset conflict warning tracker (for testing)","category":"section"},{"location":"command_discovery_help/#Types","page":"Command discovery and help","title":"Types","text":"Type Description\nGiacExpr Symbolic expression type\nGiacMatrix Symbolic matrix type\nGiacContext Evaluation context\nHelpResult Parsed help information with .command, .description, .related, .examples fields\nCommandInfo Command metadata with .name, .category, .aliases, .doc fields","category":"section"},{"location":"command_discovery_help/#Calculus","page":"Command discovery and help","title":"Calculus","text":"Use Giac.Commands or invoke_cmd:\n\nFunction Description\nGiac.Commands.diff(f, x) Derivative of f with respect to x\nGiac.Commands.integrate(f, x) Indefinite integral\ninvoke_cmd(:diff, f, x, n) nth derivative of f with respect to x\ninvoke_cmd(:integrate, f, x, a, b) Definite integral from a to b\ninvoke_cmd(:limit, f, x, point) Limit as x approaches point\ninvoke_cmd(:series, f, x, point, order) Taylor series expansion","category":"section"},{"location":"command_discovery_help/#Algebra","page":"Command discovery and help","title":"Algebra","text":"Use Giac.Commands or invoke_cmd:\n\nFunction Description\nGiac.Commands.factor(expr) Factor polynomial\nGiac.Commands.expand(expr) Expand expression\nGiac.Commands.simplify(expr) Simplify expression\nGiac.Commands.solve(expr, x) Solve equation for x\nGiac.Commands.gcd(a, b) Greatest common divisor\n\n","category":"section"},{"location":"#Giac.jl","page":"Home","title":"Giac.jl","text":"A Julia wrapper for the GIAC computer algebra system.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Dynamic Command Invocation: Access all 2200+ GIAC commands via invoke_cmd(:cmd, args...)\nCommands Submodule: All ~2000+ commands available via Giac.Commands for clean namespace\nExpression Evaluation: Parse and evaluate mathematical expressions\nCommand Discovery: Search commands, browse by category, built-in help via ?cmd\nArithmetic Operations: +, -, *, /, ^, unary negation, equality\nAlgebra: Factorization, expansion, simplification, equation solving and GCD\nCalculus: Differentiation, integration, limits, and series expansion\nInfinity Support: Use Julia's Inf and -Inf directly in limits and improper integrals\nLinear Algebra: Symbolic matrices with determinant, inverse, trace, transpose operations\nBase Extensions: Use sin(expr), cos(expr), exp(expr) with GiacExpr\nMethod Syntax: Call commands as methods: expr.factor(), expr.diff(x)\nVariable Substitution: Symbolics.jl-compatible substitute(expr, Dict(var => value)) interface\nLaplace Transform: laplace and ilaplace commands for continuous-time signal processing\nZ-Transform: ztrans and invztrans commands for discrete-time signal processing\nType Conversion: Convert results to Julia native types (Int64, Float64, Rational)\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl\nTables.jl Compatibility: Convert GiacMatrix and command help to DataFrames, CSV export\nLaTeX Support: Automatic LaTeX rendering in Pluto notebooks\nTempApi Submodule: Simplified function names (diff, factor, etc.) via Giac.TempApi","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Giac\")  # when registered to Julia General Registry\n\nFor full GIAC integration with C++ library, see the Installation Guide.","category":"section"},{"location":"#Command-Access","page":"Home","title":"Command Access","text":"GIAC commands are available through multiple access patterns:","category":"section"},{"location":"#1.-Selective-Import-from-Commands-Submodule-(Recommanded)","page":"Home","title":"1. Selective Import from Commands Submodule (Recommanded)","text":"using Giac\nusing Giac.Commands: factor, expand, ifactor\n\n@giac_var x\nfactor(x^2 - 1)","category":"section"},{"location":"#2.-Full-Import-(Interactive-Use)","page":"Home","title":"2. Full Import (Interactive Use)","text":"using Giac\nusing Giac.Commands\n\n@giac_var x\nfactor(x^2 - 1)\nifactor(120)  # All ~2000+ commands available","category":"section"},{"location":"#3.-Universal-Command-Invocation","page":"Home","title":"3. Universal Command Invocation","text":"using Giac\n\n# Works for ALL commands, including those conflicting with Julia\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))","category":"section"},{"location":"#Type-Conversion-and-Introspection","page":"Home","title":"Type Conversion and Introspection","text":"Convert GIAC results to native Julia types:\n\nusing Giac\n\n# Boolean conversion\nto_julia(giac_eval(\"true\"))   # true::Bool\nto_julia(giac_eval(\"1==1\"))   # true::Bool (comparison result)\nto_julia(giac_eval(\"1\"))      # 1::Int64 (integer, not boolean)\n\n# Use in control flow\nif to_julia(giac_eval(\"2 > 1\"))\n    println(\"Works!\")\nend\n\n# Automatic type conversion\ng = giac_eval(\"[1, 2, 3]\")\nresult = to_julia(g)  # Vector{Int64}\n\n# Boolean detection\nis_boolean(giac_eval(\"true\"))  # true\nis_boolean(giac_eval(\"1\"))     # false\n\n# Type introspection\ngiac_type(g) == GIAC_VECT  # true\nis_vector(g)               # true\n\n# Fraction components\nfrac = giac_eval(\"3/4\")\nnumer(frac)  # 3\ndenom(frac)  # 4\n\n# Complex components\nz = giac_eval(\"3+4*i\")\nreal_part(z)  # 3\nimag_part(z)  # 4\n\n# Matrix conversion\nm = GiacMatrix(giac_eval(\"[[1, 2], [3, 4]]\"))\nto_julia(m)  # 2×2 Matrix{Int64}","category":"section"},{"location":"#Vector-Indexing-and-Iteration","page":"Home","title":"Vector Indexing and Iteration","text":"Access GIAC vectors with Julia's native indexing:\n\nusing Giac\n\ng = giac_eval(\"[10, 20, 30]\")\ng[1]  # GiacExpr(10)\ng[2]  # GiacExpr(20)\n\n# Iterate over elements\nfor elem in g\n    println(to_julia(elem))\nend\n\n# Collect to Julia vector\nto_julia(g)  # [10, 20, 30]::Vector{Int64}","category":"section"},{"location":"#Infinity-Support","page":"Home","title":"Infinity Support","text":"Use Julia's native Inf and -Inf in limits and improper integrals:\n\nusing Giac\nusing Giac.Commands: limit, integrate\n\n@giac_var x\n\n# Limits at infinity\nlimit(1/x, x, Inf)     # 0\nlimit(1/x, x, -Inf)    # 0\nlimit(x^2, x, Inf)     # +infinity\n\n# Improper integrals\nintegrate(exp(-x), x, 0, Inf)    # 1\nintegrate(1/x^2, x, 1, Inf)      # 1\nintegrate(exp(x), x, -Inf, 0)    # 1","category":"section"},{"location":"#Modules","page":"Home","title":"Modules","text":"Core API: Types, evaluation, and main functions\nCommands: All GIAC commands as functions\nTempApi: Convenience functions with simple names","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"Installation Guide\nQuick Start\nVariable Declaration","category":"section"},{"location":"#Mathematics","page":"Home","title":"Mathematics","text":"Algebra - Factorization, expansion, simplification, solving\nCalculus - Differentiation, integration, limits, series\nLinear Algebra - Matrices, determinants, eigenvalues\nDifferential Equations - ODE solving with D operator\nTrigonometry - Identities, simplification, equations","category":"section"},{"location":"#Physics","page":"Home","title":"Physics","text":"Mechanics - Kinematics, dynamics, oscillations, energy\nElectromagnetism - Circuits, fields, waves","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Core API - Types, evaluation, and main functions\nCommands Submodule - All GIAC commands as functions\nTempApi - Convenience functions with simple names","category":"section"},{"location":"#Related-Projects","page":"Home","title":"Related Projects","text":"GIAC - The underlying computer algebra system\nlibgiac-julia-wrapper - CxxWrap bindings for GIAC\nCxxWrap.jl - C++ wrapper generator for Julia\n\n","category":"section"},{"location":"tables/#Tables.jl-Compatibility","page":"Tables.jl Compatibility","title":"Tables.jl Compatibility","text":"Giac.jl provides full Tables.jl compatibility, enabling seamless integration with the Julia data ecosystem including DataFrames.jl and CSV.jl.","category":"section"},{"location":"tables/#GiacMatrix-to-DataFrame","page":"Tables.jl Compatibility","title":"GiacMatrix to DataFrame","text":"Convert symbolic matrices to DataFrames for analysis and export:\n\nusing Giac\nusing DataFrames\n\n# Create a numeric matrix\nm = GiacMatrix([1 2 3; 4 5 6])\n\n# Convert to DataFrame\ndf = DataFrame(m)\n# 2×3 DataFrame\n#  Row │ col1    col2    col3\n#      │ String  String  String\n# ─────┼────────────────────────\n#    1 │ 1       2       3\n#    2 │ 4       5       6","category":"section"},{"location":"tables/#Symbolic-Matrices","page":"Tables.jl Compatibility","title":"Symbolic Matrices","text":"Symbolic values are converted to strings:\n\n@giac_var x y\nm = GiacMatrix([x y; x+1 y+1])\n\ndf = DataFrame(m)\n# 2×2 DataFrame\n#  Row │ col1    col2\n#      │ String  String\n# ─────┼────────────────\n#    1 │ x       y\n#    2 │ x+1     y+1","category":"section"},{"location":"tables/#Row-and-Column-Access","page":"Tables.jl Compatibility","title":"Row and Column Access","text":"Access data using the Tables.jl interface:\n\n# Row iteration\nfor row in Tables.rows(m)\n    println(Tables.getcolumn(row, :col1))\nend\n\n# Column access\ncols = Tables.columns(m)\nfirst_col = Tables.getcolumn(cols, :col1)  # Vector of values","category":"section"},{"location":"tables/#CSV-Export","page":"Tables.jl Compatibility","title":"CSV Export","text":"Export matrices directly to CSV files:\n\nusing CSV\n\nm = GiacMatrix(giac_eval(\"[[1,2,3],[4,5,6]]\"))\nCSV.write(\"matrix.csv\", m)","category":"section"},{"location":"tables/#Command-Help-as-Tables","page":"Tables.jl Compatibility","title":"Command Help as Tables","text":"","category":"section"},{"location":"tables/#Single-Command-Help","page":"Tables.jl Compatibility","title":"Single Command Help","text":"Convert help information for a single command to a table:\n\nusing Giac\nusing DataFrames\n\nhr = Giac.help(:factor)  # Internal function for programmatic access\ndf = DataFrame(hr)\n# 1×5 DataFrame\n#  Row │ command  category  description  related           examples\n#      │ String   String    String       String            String\n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ factor   algebra   ...          ifactor, partfrac ...\n\ntip: Interactive Help\nFor interactive help, use Julia's native help system:using Giac.Commands: factor\n?factor  # Shows GIAC documentation in REPL","category":"section"},{"location":"tables/#All-Commands-Table","page":"Tables.jl Compatibility","title":"All Commands Table","text":"Get a table of all ~2000 GIAC commands with documentation:\n\nusing DataFrames\n\nct = commands_table()\ndf = DataFrame(ct)\n# ~2000×5 DataFrame with columns:\n# - command: Command name\n# - category: Category (algebra, calculus, etc.)\n# - description: Command description\n# - related: Related commands (comma-separated)\n# - examples: Usage examples (semicolon-separated)","category":"section"},{"location":"tables/#Filtering-Commands","page":"Tables.jl Compatibility","title":"Filtering Commands","text":"Use DataFrame operations to filter and search commands:\n\nusing DataFrames\n\ndf = DataFrame(commands_table())\n\n# Find all algebra commands\nalgebra_cmds = filter(row -> row.category == \"algebra\", df)\n\n# Search by description\nfactor_cmds = filter(row -> occursin(\"factor\", lowercase(row.description)), df)","category":"section"},{"location":"tables/#Caching","page":"Tables.jl Compatibility","title":"Caching","text":"The commands table is cached for performance. To refresh:\n\nclear_commands_cache!()\nct = commands_table()  # Fresh collection","category":"section"},{"location":"tables/#Table-of-Functions","page":"Tables.jl Compatibility","title":"Table of Functions","text":"Function Description\nTables.istable(GiacMatrix) Returns true\nTables.rows(m::GiacMatrix) Row iterator\nTables.columns(m::GiacMatrix) Column accessor\nTables.schema(m::GiacMatrix) Column names and types\nTables.istable(HelpResult) Returns true\nTables.rows(hr::HelpResult) Single-row iterator\ncommands_table() All commands as table\nclear_commands_cache!() Clear commands cache","category":"section"},{"location":"tables/#API-Reference","page":"Tables.jl Compatibility","title":"API Reference","text":"","category":"section"},{"location":"tables/#Giac.commands_table","page":"Tables.jl Compatibility","title":"Giac.commands_table","text":"commands_table() -> CommandsTable\n\nReturn a Tables.jl-compatible collection of all GIAC command help.\n\nResults are cached after the first call for performance. Use clear_commands_cache!() to invalidate the cache.\n\nExample\n\nusing DataFrames\n\n# Get all commands as DataFrame\ndf = DataFrame(commands_table())\n\n# Filter by category\nalgebra_cmds = filter(row -> row.category == \"algebra\", df)\n\n# Export to CSV\nusing CSV\nCSV.write(\"giac_commands.csv\", commands_table())\n\nSee also\n\nclear_commands_cache!: Invalidate the cache\ngiac_help: Get raw help for a single command\n\n\n\n\n\n","category":"function"},{"location":"tables/#Giac.clear_commands_cache!","page":"Tables.jl Compatibility","title":"Giac.clear_commands_cache!","text":"clear_commands_cache!()\n\nClear the cached CommandsTable, forcing re-collection on next commands_table() call.\n\nExample\n\nct1 = commands_table()  # Collects all commands\nclear_commands_cache!()\nct2 = commands_table()  # Re-collects all commands\n\nSee also\n\ncommands_table: Get the commands table\n\n\n\n\n\n","category":"function"},{"location":"tables/#Giac.CommandsTable","page":"Tables.jl Compatibility","title":"Giac.CommandsTable","text":"CommandsTable\n\nCached collection of all GIAC command help as Tables.jl source.\n\nCreated by commands_table(). Contains pre-collected help information for all available GIAC commands.\n\nExample\n\nusing DataFrames\n\nct = commands_table()\ndf = DataFrame(ct)\nfilter(row -> row.category == \"algebra\", df)\n\n\n\n\n\n","category":"type"}]
}
