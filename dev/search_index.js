var documenterSearchIndex = {"docs":
[{"location":"developer/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"This guide covers common issues encountered when developing with Giac.jl and strategies for debugging them.","category":"section"},{"location":"developer/troubleshooting/#Library-Loading-Errors","page":"Troubleshooting","title":"Library Loading Errors","text":"","category":"section"},{"location":"developer/troubleshooting/#libgiac_jll-Issues","page":"Troubleshooting","title":"libgiac_jll Issues","text":"Symptom: Error on using Giac mentioning missing library or symbols.\n\nERROR: LoadError: could not load library \"libgiac\"\n\nCauses and Solutions:\n\nMissing JLL package:\nusing Pkg\nPkg.add(\"libgiac_jll\")\nVersion mismatch: Ensure compatible versions:\nPkg.status(\"libgiac_jll\")\nPkg.status(\"CxxWrap\")\nCorrupted installation:\nPkg.rm(\"Giac\")\nPkg.gc()  # Clean up\nPkg.add(\"Giac\")","category":"section"},{"location":"developer/troubleshooting/#CxxWrap-Compatibility","page":"Troubleshooting","title":"CxxWrap Compatibility","text":"Symptom: Errors about missing methods or incorrect types.\n\nERROR: MethodError: no method matching ...\n\nCauses:\n\nCxxWrap version mismatch: Check versions match what Giac.jl expects\nPkg.status(\"CxxWrap\")\nRecompilation needed:\nusing Pkg\nPkg.build(\"Giac\")","category":"section"},{"location":"developer/troubleshooting/#RTLD_GLOBAL-Requirement","page":"Troubleshooting","title":"RTLD_GLOBAL Requirement","text":"Symptom: Symbols not found at runtime despite library loading.\n\nERROR: symbol \"giac_...\" not found\n\nCause: The C++ library wasn't loaded with RTLD_GLOBAL flag.\n\nFix: This should be handled automatically by Giac.jl's init_giac_library(). If you see this error:\n\nCheck that __init__() is being called\nVerify the library loading code in wrapper.jl:\n# Should use RTLD_GLOBAL\nLibdl.dlopen(lib_path, RTLD_GLOBAL | RTLD_LAZY)","category":"section"},{"location":"developer/troubleshooting/#Runtime-Errors","page":"Troubleshooting","title":"Runtime Errors","text":"","category":"section"},{"location":"developer/troubleshooting/#GiacError-Types","page":"Troubleshooting","title":"GiacError Types","text":"Giac.jl categorizes errors with a category field:\n\nCategory Description Common Causes\n:parse GIAC couldn't parse the expression Syntax error in expression string\n:eval Evaluation failed Unknown command, domain error\n:type Type conversion error Incompatible types\n:memory Memory-related error Null pointer, freed object\n\nDebugging:\n\ntry\n    result = giac_eval(\"invalid(\")\ncatch e\n    if e isa GiacError\n        println(\"Category: \", e.category)\n        println(\"Message: \", e.message)\n    end\n    rethrow()\nend","category":"section"},{"location":"developer/troubleshooting/#Unknown-Command-Errors","page":"Troubleshooting","title":"Unknown Command Errors","text":"Symptom:\n\nGiacError: Unknown command: myfunction\n\nCauses:\n\nTypo in command name:\ngiac_cmd(:factr, x)  # Wrong: should be :factor\nCommand not in GIAC: Not all mathematical functions are in GIAC\n# Check if command exists\nusing Giac: VALID_COMMANDS\n:my_function in VALID_COMMANDS\nCommand suggestions: Giac.jl suggests similar commands:\nUnknown command: factr. Did you mean: factor?","category":"section"},{"location":"developer/troubleshooting/#Type-Conversion-Failures","page":"Troubleshooting","title":"Type Conversion Failures","text":"Symptom:\n\nERROR: Cannot convert GiacExpr to Float64\n\nCauses and Solutions:\n\nExpression is symbolic:\nx = giac_eval(\"x\")\nto_julia(x)  # Error: x is symbolic\n\n# Fix: Evaluate numerically first\nto_julia(giac_cmd(:evalf, x))  # Still symbolic\n\n# Or: Use numeric values\nx = giac_eval(\"3.14\")\nto_julia(x)  # Works: 3.14\nComplex result:\nresult = sqrt(giac_eval(\"-1\"))\nto_julia(Float64, result)  # Error: result is complex\n\n# Fix: Use Complex type\nto_julia(ComplexF64, result)  # Works","category":"section"},{"location":"developer/troubleshooting/#Performance-Issues","page":"Troubleshooting","title":"Performance Issues","text":"","category":"section"},{"location":"developer/troubleshooting/#Identifying-Tier-Fallbacks","page":"Troubleshooting","title":"Identifying Tier Fallbacks","text":"If operations seem slower than expected, a function may be falling back from Tier 1 to Tier 3.\n\nDebug strategy:\n\n# Enable debug logging\nENV[\"JULIA_DEBUG\"] = \"Giac\"\n\n# Run your operation\nresult = sin(giac_eval(\"x\"))\n\n# Check logs for fallback messages:\n# \"Tier 1 function failed: ...\"\n\nCommon causes of fallback:\n\nLibrary in stub mode: Check Giac._stub_mode[]\nC++ exception: Error in the C++ wrapper\nInvalid input: Pointer is null or invalid","category":"section"},{"location":"developer/troubleshooting/#Profiling-Tips","page":"Troubleshooting","title":"Profiling Tips","text":"Using Julia's profiler:\n\nusing Profile\n\n# Profile the operation\n@profile for i in 1:10000\n    sin(giac_eval(\"x\"))\nend\n\n# View results\nProfile.print()\n\nBenchmarking tiers:\n\nusing BenchmarkTools\n\nx = giac_eval(\"x\")\n\n# Benchmark Tier 1 path\n@btime sin($x)\n\n# Force Tier 3 path for comparison\n@btime giac_cmd(:sin, $x)","category":"section"},{"location":"developer/troubleshooting/#Memory-Allocation-Tracking","page":"Troubleshooting","title":"Memory Allocation Tracking","text":"Check for excessive allocations:\n\n@time begin\n    for i in 1:1000\n        x = giac_eval(\"x^$i\")\n    end\nend\n\nForce GC to check for leaks:\n\nGC.gc()\ninitial = Sys.maxrss()\n\nfor i in 1:10000\n    x = giac_eval(\"x^2\")\nend\n\nGC.gc()\nfinal = Sys.maxrss()\nprintln(\"Memory growth: $(final - initial) bytes\")","category":"section"},{"location":"developer/troubleshooting/#Test-Failures","page":"Troubleshooting","title":"Test Failures","text":"","category":"section"},{"location":"developer/troubleshooting/#Common-Test-Failure-Causes","page":"Troubleshooting","title":"Common Test Failure Causes","text":"String representation changes:\n# May fail if GIAC changes output format\n@test string(factor(x^2 - 1)) == \"(x-1)*(x+1)\"\n\n# More robust:\n@test expand(factor(x^2 - 1)) == x^2 - 1\nFloating point precision:\n# May fail due to precision\n@test to_julia(sin(giac_eval(\"pi/6\"))) == 0.5\n\n# Better:\n@test to_julia(sin(giac_eval(\"pi/6\"))) ≈ 0.5\nOrder-dependent results:\n# Polynomial terms may appear in different orders\n@test string(expand(x+y)) == \"x+y\"  # May be \"y+x\"\n\n# Better: Compare evaluated equality\nresult = expand((x+1)*(x-1))\n@test giac_cmd(:expand, result - (x^2 - 1)) == giac_eval(\"0\")","category":"section"},{"location":"developer/troubleshooting/#Debugging-Test-Failures","page":"Troubleshooting","title":"Debugging Test Failures","text":"Run single test:\n\nusing Pkg\nPkg.test(\"Giac\", test_args=[\"--testset\", \"sin function\"])\n\nInteractive debugging:\n\nusing Giac\n\n# Reproduce the test manually\nx = giac_eval(\"x\")\nresult = sin(x)\n@show result\n@show string(result)\n@show typeof(result)\n\nCheck test environment:\n\n# Ensure clean state\nGC.gc()\n\n# Check context\n@show Giac.DEFAULT_CONTEXT","category":"section"},{"location":"developer/troubleshooting/#Debugging-Strategies","page":"Troubleshooting","title":"Debugging Strategies","text":"","category":"section"},{"location":"developer/troubleshooting/#Isolating-Julia-vs-C-Issues","page":"Troubleshooting","title":"Isolating Julia vs C++ Issues","text":"Step 1: Check if the issue is in argument conversion:\n\n# Test argument conversion\nexpr = giac_eval(\"x\")\n@show Giac._arg_to_giac_string(expr)\n\nStep 2: Check if GIAC understands the command:\n\n# Direct string evaluation\nresult = giac_eval(\"sin(x)\")  # Bypasses Julia wrappers\n\nStep 3: Check the tier being used:\n\n# Enable debug mode\nENV[\"JULIA_DEBUG\"] = \"Giac\"\n\n# Run operation\nsin(giac_eval(\"x\"))\n# Look for tier fallback messages","category":"section"},{"location":"developer/troubleshooting/#Using-GIAC-Directly","page":"Troubleshooting","title":"Using GIAC Directly","text":"For advanced debugging, test in GIAC directly:\n\n# Install GIAC CLI (if available)\ngiac\n\n# Test commands directly\n>> sin(x)\n>> factor(x^2-1)","category":"section"},{"location":"developer/troubleshooting/#Wrapper-Layer-Debugging","page":"Troubleshooting","title":"Wrapper Layer Debugging","text":"Check wrapper availability:\n\nusing Giac: GiacCxxBindings\n\n# Check if wrapper is loaded\n@show GiacCxxBindings._have_library\n\n# List available functions\nnames(GiacCxxBindings)","category":"section"},{"location":"developer/troubleshooting/#Getting-Help","page":"Troubleshooting","title":"Getting Help","text":"","category":"section"},{"location":"developer/troubleshooting/#GitHub-Issues","page":"Troubleshooting","title":"GitHub Issues","text":"For bugs or feature requests:\n\nSearch existing issues at github.com/s-celles/Giac.jl/issues\nCreate a new issue with:\nGiac.jl version (Pkg.status(\"Giac\"))\nJulia version (VERSION)\nMinimal reproducible example\nFull error message with stack trace","category":"section"},{"location":"developer/troubleshooting/#Providing-Debug-Information","page":"Troubleshooting","title":"Providing Debug Information","text":"Include this information in bug reports:\n\nusing Pkg\nusing Giac\n\nprintln(\"Julia: \", VERSION)\nprintln(\"Giac.jl: \", Pkg.dependencies()[Base.PkgId(Giac).uuid].version)\nprintln(\"CxxWrap: \", Pkg.dependencies()[Base.PkgId(CxxWrap).uuid].version)\nprintln(\"Platform: \", Sys.MACHINE)\nprintln(\"OS: \", Sys.KERNEL)","category":"section"},{"location":"developer/troubleshooting/#Community-Resources","page":"Troubleshooting","title":"Community Resources","text":"Julia Discourse: discourse.julialang.org - Tag with giac or computer-algebra\nJulia Slack/Zulip: #mathematics channel\nGIAC Documentation: www-fourier.univ-grenoble-alpes.fr/~parMDisse/giac.html","category":"section"},{"location":"developer/troubleshooting/#See-Also","page":"Troubleshooting","title":"See Also","text":"Memory Management - For memory-related issues\nPerformance Tiers - Understanding tier fallbacks\nPackage Architecture - Where to find source code\n\n","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#User-mode-installation-(not-yet-available)","page":"Installation","title":"User mode installation (not yet available)","text":"This command will install Giac.jl (when both GIAC_jll and libgiac-julia-wrapper will be published)\n\nusing Pkg\nPkg.add(\"Giac\")  # when registered in Julia General Registry\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")  # until unregistered","category":"section"},{"location":"install/#Developer-mode-installation","page":"Installation","title":"Developer mode installation","text":"","category":"section"},{"location":"install/#Option-1:-Stub-Mode-(No-C-Dependencies)","page":"Installation","title":"Option 1: Stub Mode (No C++ Dependencies)","text":"For development or testing without the full GIAC library:\n\nusing Pkg\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")\n\nIn stub mode, basic operations work but return placeholder values.","category":"section"},{"location":"install/#Option-2:-Full-Integration-(With-GIAC-2.0.0)","page":"Installation","title":"Option 2: Full Integration (With GIAC 2.0.0)","text":"","category":"section"},{"location":"install/#Prerequisites","page":"Installation","title":"Prerequisites","text":"Julia 1.10+ (LTS recommended)\nC++ compiler with C++17 support\nCMake 3.15+\nGIAC 2.0.0 source","category":"section"},{"location":"install/#Step-1:-Build-GIAC-2.0.0","page":"Installation","title":"Step 1: Build GIAC 2.0.0","text":"# Download GIAC\nwget https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/giac_stable.tgz\ntar xzf giac_stable.tgz\ncd giac-2.0.0\n\n# Configure and build\n./configure --enable-shared --disable-gui --disable-pari\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-2:-Build-libgiac-julia-wrapper","page":"Installation","title":"Step 2: Build libgiac-julia-wrapper","text":"git clone https://github.com/s-celles/libgiac-julia-wrapper\ncd libgiac-julia-wrapper\nmkdir build && cd build\ncmake .. -DGIAC_ROOT=/path/to/giac-2.0.0\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-3:-Set-Environment","page":"Installation","title":"Step 3: Set Environment","text":"export GIAC_WRAPPER_LIB=/path/to/libgiac-julia-wrapper/build/src/libgiac_wrapper.so\nexport LD_LIBRARY_PATH=/path/to/giac-2.0.0/src/.libs:$LD_LIBRARY_PATH\n# or\nexport LD_LIBRARY_PATH=$(julia -e 'using GIAC_jll; print(GIAC_jll.artifact_dir)')/lib:$LD_LIBRARY_PATH","category":"section"},{"location":"install/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"using Giac\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())\n\n# If stub mode is false, full GIAC integration is working\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\n","category":"section"},{"location":"extensions/symbolics/#Symbolics.jl-Integration","page":"Symbolics.jl","title":"Symbolics.jl Integration","text":"using Giac, Symbolics\n\n@variables x y\ngiac_expr = to_giac(x^2 + 2*x + 1)\nfactored = invoke_cmd(:factor, giac_expr)  # (x+1)^2\nsym_result = to_symbolics(factored)  # Num: (1+x)^2\n\n","category":"section"},{"location":"api/giac_commands/#GIAC-commands","page":"GIAC Commands","title":"GIAC commands","text":"","category":"section"},{"location":"api/giac_commands/#Dynamic-Command-Invocation","page":"GIAC Commands","title":"Dynamic Command Invocation","text":"Call any of GIAC's 2200+ commands dynamically:\n\nusing Giac\n\n@giac_var x\nexpr = x^2 - 1\n\n# Function syntax with invoke_cmd (works for ALL commands)\nresult = invoke_cmd(:factor, expr)           # (x-1)*(x+1)\nderiv = invoke_cmd(:diff, expr, x)           # 2*x\nintegral = invoke_cmd(:integrate, expr, x)   # x^3/3-x\n\n# Method syntax on GiacExpr (equivalent to invoke_cmd)\nresult = expr.factor()                     # (x-1)*(x+1)\nderiv = expr.diff(x)                       # 2*x\n\n# Chaining methods\n@giac_var a b\nresult = ((a+b)^2).expand()\nresult = ((a+b)^2).expand().factor()\n# or using |> operator\n(a+b)^2 |> expand\n(a+b)^2 |> expand |> factor\n\n# Natural Julia syntax with Base extensions\n@giac_var y\nsin(y)         # sin(y)\ncos(y)         # cos(y)\nexp(y)         # exp(y)\nlog(y)         # ln(y)\nsqrt(y)        # sqrt(y)\nsin(y) + cos(y)  # sin(y)+cos(y)","category":"section"},{"location":"api/giac_commands/#Commands-Submodule","page":"GIAC Commands","title":"Commands Submodule","text":"Giac.jl provides three ways to access GIAC's 2200+ commands via the Giac.Commands submodule:","category":"section"},{"location":"api/giac_commands/#1.-Qualified-Access","page":"GIAC Commands","title":"1. Qualified Access","text":"Access commands via Giac.Commands.commandname:\n\nusing Giac\n\n@giac_var x\nexpr = x^2 - 1\n\n# Access commands via Giac.Commands\nGiac.Commands.factor(expr)          # (x-1)*(x+1)\nGiac.Commands.expand((x+1)^2)  # x^2+2*x+1\nGiac.Commands.diff(expr, x)         # 2*x\nGiac.Commands.integrate(expr, x)    # x^3/3-x\nGiac.Commands.ifactor(120)  # 2^3*3*5","category":"section"},{"location":"api/giac_commands/#2.-Selective-Import","page":"GIAC Commands","title":"2. Selective Import","text":"Import specific commands you need:\n\nusing Giac\nusing Giac.Commands: factor, expand, diff, integrate\n\n@giac_var x\nexpr = x^2 - 1\n\n# Direct function syntax (no prefix needed)\nfactor(expr)              # (x-1)*(x+1)\nexpand((x+1)^2)  # x^2+2*x+1\ndiff(expr, x)             # 2*x\nintegrate(expr, x)        # x^3/3-x","category":"section"},{"location":"api/giac_commands/#3.-Full-Import-(Interactive-Use)","page":"GIAC Commands","title":"3. Full Import (Interactive Use)","text":"Import all ~2000+ commands for interactive exploration:\n\nusing Giac\nusing Giac.Commands  # Imports ALL exportable commands\n\n@giac_var x\nfactor(x^2 - 1)    # (x-1)*(x+1)\nifactor(120)       # 2^3*3*5\nnextprime(100)     # 101\nairy_ai(0)         # Airy function\n\n# Discover available commands\nexportable_commands()            # ~2000+ command names","category":"section"},{"location":"api/giac_commands/#invoke_cmd-for-ALL-Commands","page":"GIAC Commands","title":"invoke_cmd for ALL Commands","text":"For commands that conflict with Julia (like sin, cos, eval, det), use invoke_cmd:\n\nusing Giac\n\n@giac_var k n\n\n# Conflicting commands must use invoke_cmd\ninvoke_cmd(:eval, giac_eval(\"2+3\"))      # 5\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))      # 1/2\ninvoke_cmd(:det, giac_eval(\"[[1,2],[3,4]]\"))  # -2\ninvoke_cmd(:det, giac_eval(\"[[a,b],[c,d]]\"))  # a*d-b*c\ninvoke_cmd(:sum, k, k, giac_eval(\"1\"), n)  # 1/2*n^2+1/2*n\ninvoke_cmd(:product, k, k, giac_eval(\"1\"), n)  # n!\n\n# invoke_cmd works for ANY command\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))  # (x-1)*(x+1)","category":"section"},{"location":"api/giac_commands/#TempApi-Submodule","page":"GIAC Commands","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for some common symbolic computation operations. These are wrappers around the giac_* functions.\n\nusing Giac.TempApi: diff, expand, factor, integrate, limit, simplify, solve\n#Overlapping with Julia: eval, include, \n@giac_var x a b\ndiff(x^2, x)  # 2*x\nexpand((a+b)^2)  # a^2+b^2+2*a*b\nfactor(x^2-1)  # (x-1)*(x+1)\nintegrate(x^2, x)  # x^3/3\nintegrate(x^2, x, 0, 1)  # returns\n    // ∫ ~= 0.333333333333\n    GiacExpr: 1/3\nlimit(sin(x)/x, x, 0)  # 1\nsimplify(a + b - a)  # b\nsolve(x^2 - 1)\nsolve(x^2 - 1, x)  # list[-1,1]","category":"section"},{"location":"api/giac_commands/#Available-Functions","page":"GIAC Commands","title":"Available Functions","text":"TempApi Function Uses Description\ndiff(expr, var, n=1) invoke_cmd(:diff, ...) Differentiate expression\nintegrate(expr, var) invoke_cmd(:integrate, ...) Indefinite integral\nintegrate(expr, var, a, b) invoke_cmd(:integrate, ...) Definite integral\nlimit(expr, var, point) invoke_cmd(:limit, ...) Compute limit\nfactor(expr) invoke_cmd(:factor, ...) Factor polynomial\nexpand(expr) invoke_cmd(:expand, ...) Expand expression\nsimplify(expr) invoke_cmd(:simplify, ...) Simplify expression\nsolve(expr, var) invoke_cmd(:solve, ...) Solve equation","category":"section"},{"location":"api/giac_commands/#Usage-Patterns","page":"GIAC Commands","title":"Usage Patterns","text":"using Giac\n\n# 1. Selective import (recommended)\nusing Giac.TempApi: diff, factor, integrate, limit\n\n@giac_var x\nexpr = x^2 - 1\n\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nintegrate(expr, x)      # x^3/3-x\nlimit(sin(x)/x, x, 0)  # 1\nlimit(1/x, x, 0, 1)  # limit of 1/x at 0+ should be +infinity\nlimit(1/x, x, 0, -1)  # limit of 1/x at 0- should be -infinity\n\n# 2. Qualified access\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)","category":"section"},{"location":"api/giac_commands/#Comparison:-TempApi-vs-Commands-vs-invoke_cmd","page":"GIAC Commands","title":"Comparison: TempApi vs Commands vs invoke_cmd","text":"Pattern Import Usage Best For\nTempApi using Giac.TempApi diff(expr, x) Clean, simple names for common operations\nCommands using Giac.Commands diff(expr, x) Access to ALL 2200+ GIAC commands\ninvoke_cmd using Giac invoke_cmd(:diff, expr, x) Universal, works for ALL commands\n\nNote: Both TempApi and Commands export diff, factor, etc. Use selective imports to avoid conflicts, or choose one submodule based on your needs.","category":"section"},{"location":"api/giac_commands/#Commands-That-Conflict-with-Julia","page":"GIAC Commands","title":"Commands That Conflict with Julia","text":"Some GIAC commands have the same name as Julia built-ins. These are not exported from Giac.Commands to avoid shadowing Julia's functions:\n\nCategory Conflicting Commands\nKeywords if, for, while, end, in, or, and, not\nBuiltins eval, float, sum, prod, collect, abs, sign\nMath sin, cos, tan, exp, log, sqrt, gcd, lcm\nLinearAlgebra det, inv, trace, rank, transpose, norm\nStatistics mean, median, var, std\n\nUse invoke_cmd(:name, args...) for these commands. A warning is shown on first use to remind you:\n\ninvoke_cmd(:eval, giac_eval(\"2+3\"))\n# ┌ Warning: GIAC command 'eval' conflicts with Julia (builtin).\n# │ Use invoke_cmd(:eval, args...) to call it.\n\n","category":"section"},{"location":"developer/#Developer-Guide","page":"Overview","title":"Developer Guide","text":"Welcome to the Giac.jl Developer Guide. This documentation is intended for developers who want to contribute to Giac.jl or understand its internal architecture.","category":"section"},{"location":"developer/#Audience","page":"Overview","title":"Audience","text":"This guide is for:\n\nContributors wanting to add new mathematical functions\nMaintainers needing to understand the codebase\nAdvanced users curious about performance optimization","category":"section"},{"location":"developer/#Prerequisites","page":"Overview","title":"Prerequisites","text":"Before diving in, you should be familiar with:\n\nJulia programming fundamentals\nBasic understanding of C/C++ interop concepts\nGit version control","category":"section"},{"location":"developer/#Guide-Contents","page":"Overview","title":"Guide Contents","text":"","category":"section"},{"location":"developer/#[Package-Architecture](architecture.md)","page":"Overview","title":"Package Architecture","text":"Understand how Giac.jl is structured, including the purpose of each source file and how they interact.","category":"section"},{"location":"developer/#[Performance-Tiers](tier-system.md)","page":"Overview","title":"Performance Tiers","text":"Learn about the three-tier performance system that powers Giac.jl's function calls, from high-performance C++ wrappers to flexible string evaluation.","category":"section"},{"location":"developer/#[Adding-Functions](contributing.md)","page":"Overview","title":"Adding Functions","text":"Step-by-step guides for adding new mathematical functions at each tier level.","category":"section"},{"location":"developer/#[Memory-Management](memory.md)","page":"Overview","title":"Memory Management","text":"Understand how Giac.jl manages memory for C++ objects, including finalizers and thread safety.","category":"section"},{"location":"developer/#[Troubleshooting](troubleshooting.md)","page":"Overview","title":"Troubleshooting","text":"Common issues and debugging strategies for development work.","category":"section"},{"location":"developer/#Quick-Reference","page":"Overview","title":"Quick Reference","text":"Task Where to Start\nAdd a new high-performance function Performance Tiers then Adding Functions\nUnderstand the codebase Package Architecture\nDebug a crash or memory issue Memory Management then Troubleshooting\nFix a failing test Troubleshooting","category":"section"},{"location":"developer/#Getting-Started","page":"Overview","title":"Getting Started","text":"Clone the repository and set up your development environment\nRead the Package Architecture to understand the codebase structure\nFamiliarize yourself with the Performance Tiers system\nFollow the Adding Functions guide for your contribution","category":"section"},{"location":"developer/#Version-Compatibility","page":"Overview","title":"Version Compatibility","text":"This documentation applies to Giac.jl v0.x (current development version). API and internal structure may change before v1.0.\n\n","category":"section"},{"location":"api/core/#Core-API","page":"Core API","title":"Core API","text":"The main Giac module provides core types and functions for symbolic computation.","category":"section"},{"location":"api/core/#Types","page":"Core API","title":"Types","text":"","category":"section"},{"location":"api/core/#Expression-Evaluation","page":"Core API","title":"Expression Evaluation","text":"","category":"section"},{"location":"api/core/#Symbolic-Variables","page":"Core API","title":"Symbolic Variables","text":"","category":"section"},{"location":"api/core/#Calculus-Operations","page":"Core API","title":"Calculus Operations","text":"Calculus functions are available via Giac.Commands or invoke_cmd:\n\nusing Giac\nusing Giac.Commands: diff, integrate, limit, series\n\n# Or use invoke_cmd\ninvoke_cmd(:diff, expr, x)\ninvoke_cmd(:integrate, expr, x)\ninvoke_cmd(:limit, expr, x, point)\ninvoke_cmd(:series, expr, x, point, order)","category":"section"},{"location":"api/core/#Algebraic-Operations","page":"Core API","title":"Algebraic Operations","text":"Algebra functions are available via Giac.Commands or invoke_cmd:\n\nusing Giac\nusing Giac.Commands: factor, expand, simplify, solve, gcd\n\n# Or use invoke_cmd\ninvoke_cmd(:factor, expr)\ninvoke_cmd(:expand, expr)\ninvoke_cmd(:simplify, expr)\ninvoke_cmd(:solve, expr, x)\ninvoke_cmd(:gcd, a, b)","category":"section"},{"location":"api/core/#Command-Discovery","page":"Core API","title":"Command Discovery","text":"note: Getting Help for Commands\nUse Julia's native help system after importing commands:using Giac.Commands: factor\n?factor  # Shows GIAC documentation","category":"section"},{"location":"api/core/#Command-Suggestions","page":"Core API","title":"Command Suggestions","text":"","category":"section"},{"location":"api/core/#Namespace-Management","page":"Core API","title":"Namespace Management","text":"","category":"section"},{"location":"api/core/#Substitution","page":"Core API","title":"Substitution","text":"See Variable Substitution for the substitute function documentation.","category":"section"},{"location":"api/core/#Conversion-Functions","page":"Core API","title":"Conversion Functions","text":"","category":"section"},{"location":"api/core/#Utility-Functions","page":"Core API","title":"Utility Functions","text":"","category":"section"},{"location":"api/core/#Core-Functions","page":"Core API","title":"Core Functions","text":"Function Description\ngiac_eval(expr) Evaluate a GIAC expression string\ninvoke_cmd(cmd, args...) Invoke any GIAC command dynamically\nis_stub_mode() Check if running without GIAC library\nto_julia(expr) Convert GiacExpr to Julia type\n\n","category":"section"},{"location":"api/core/#Giac","page":"Core API","title":"Giac","text":"Giac\n\nA Julia wrapper for the GIAC computer algebra system.\n\nProvides symbolic expression evaluation, calculus operations, polynomial manipulation, and linear algebra with a Julia-native API.\n\nCore Exports\n\nGiacExpr: Symbolic expression type\nGiacContext: Evaluation context\nGiacMatrix: Symbolic matrix type\nGiacError: Exception type for GIAC errors\ngiac_eval: Evaluate expression strings\n@giac_var: Create symbolic variables from Julia symbols\nto_julia: Convert GiacExpr to Julia types\ninvoke_cmd: Universal command invocation (works for ALL commands)\n\nCommand Access\n\nGIAC commands are available through the Giac.Commands submodule:\n\nusing Giac\n\n# Use invoke_cmd for any command (always available)\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))  # Works for conflicting commands too\n\n# Import commands selectively (recommended)\nusing Giac.Commands: factor, expand, diff\nfactor(giac_eval(\"x^2-1\"))\n\n# Or import all ~2000+ commands\nusing Giac.Commands\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))\n\nQuick Start\n\nusing Giac\n\n# Declare symbolic variables with @giac_var macro\n@giac_var x y\n\n# Build and manipulate expressions using Giac.Commands\nusing Giac.Commands: factor, expand, diff\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\nresult = factor(expr)   # (x+y)^2\n\n# Or use string-based evaluation directly\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\nSee also\n\nGiac.Commands: Submodule with all exportable commands\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"module"},{"location":"api/core/#Giac.GiacExpr","page":"Core API","title":"Giac.GiacExpr","text":"GiacExpr\n\nRepresents a symbolic mathematical expression from GIAC.\n\nWraps a pointer to a C++ giac::gen object. Memory is managed automatically via Julia's garbage collector and finalizers.\n\nExample\n\nexpr = giac_eval(\"x^2 + 1\")\nprintln(expr)  # x^2+1\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacContext","page":"Core API","title":"Giac.GiacContext","text":"GiacContext\n\nRepresents a GIAC evaluation context.\n\nManages configuration settings, variable bindings, and computation state. Thread-safe via internal locking.\n\nExample\n\nctx = GiacContext()\nresult = giac_eval(\"x + 1\", ctx)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacMatrix","page":"Core API","title":"Giac.GiacMatrix","text":"GiacMatrix\n\nRepresents a symbolic matrix with GiacExpr elements.\n\nFields\n\nptr::Ptr{Cvoid}: Pointer to GIAC matrix object\nrows::Int: Number of rows\ncols::Int: Number of columns\n\nExample\n\nA = GiacMatrix([[a, b], [c, d]])\ndet(A)  # a*d - b*c\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacError","page":"Core API","title":"Giac.GiacError","text":"GiacError <: Exception\n\nException type for errors from the GIAC library.\n\nFields\n\nmsg::String: Error message\ncategory::Symbol: Error category (:parse, :eval, :type, :memory)\n\nExample\n\nthrow(GiacError(\"Failed to parse expression\", :parse))\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.HelpResult","page":"Core API","title":"Giac.HelpResult","text":"HelpResult\n\nA structured representation of parsed GIAC command help information.\n\nFields\n\ncommand::String: The command name being documented\ndescription::String: Description text from GIAC help\nrelated::Vector{String}: List of related command names\nexamples::Vector{String}: List of individual example expressions\n\nExample\n\n# Use Julia's help system for interactive help:\n# ?factor (after using Giac.Commands: factor)\n\n# For programmatic access, use Giac.help (internal) or giac_help:\nresult = Giac.help(:factor)\nresult.command      # \"factor\"\nresult.description  # \"Factorizes a polynomial.\"\nresult.related      # [\"ifactor\", \"partfrac\", \"normal\"]\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\ngiac_help: Get raw help string\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacCommand","page":"Core API","title":"Giac.GiacCommand","text":"GiacCommand\n\nA callable wrapper for GIAC commands.\n\nThis type stores a command name and can be called with arguments to execute the underlying GIAC command. It provides a structured way to represent commands that can be passed around and invoked.\n\nFields\n\nname::Symbol: The GIAC command name (e.g., :factor, :diff)\n\nExample\n\n# Create a command and call it\nfactor_cmd = GiacCommand(:factor)\nexpr = giac_eval(\"x^2 - 1\")\nresult = factor_cmd(expr)  # Returns (x-1)*(x+1)\n\n# Equivalent to:\nresult = giac_cmd(:factor, expr)\n\nSee also\n\ninvoke_cmd: Direct command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacInput","page":"Core API","title":"Giac.GiacInput","text":"GiacInput\n\nUnion type representing all valid input types for GIAC command functions.\n\nThis type alias enables generated GIAC command functions to accept native Julia types in addition to GiacExpr, providing a more ergonomic API.\n\nSupported Types\n\nGiacExpr: Native GIAC expressions\nNumber: All Julia numeric types (Integer, AbstractFloat, Rational, Complex, etc.)\nString: String representations of GIAC expressions\nSymbol: Variable names (e.g., :x, :y)\n\nExamples\n\nusing Giac\nusing Giac.Commands\n\n# All of these work:\nifactor(1000)           # Integer\nifactor(giac_eval(\"1000\"))  # GiacExpr\nsimplify(\"x^2 - 1\")     # String\n\nSee also\n\nGiacExpr: The primary GIAC expression type\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.giac_eval","page":"Core API","title":"Giac.giac_eval","text":"giac_eval(expr::String, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nEvaluate a GIAC expression string and return a GiacExpr.\n\nArguments\n\nexpr::String: A string containing a valid GIAC expression\nctx::GiacContext: Optional evaluation context (uses DEFAULT_CONTEXT if not provided)\n\nReturns\n\nGiacExpr: The evaluated expression\n\nThrows\n\nGiacError(:parse): If the expression cannot be parsed\nGiacError(:eval): If evaluation fails\n\nExample\n\nresult = giac_eval(\"2 + 3\")\nprintln(result)  # 5\n\n# Symbolic computation\nexpr = giac_eval(\"diff(x^2, x)\")\nprintln(expr)  # 2*x\n\n\n\n\n\ngiac_eval(expr::GiacExpr, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nRe-evaluate an existing GiacExpr in a context (useful after variable assignments).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_julia","page":"Core API","title":"Giac.to_julia","text":"to_julia(expr::GiacExpr)\n\nConvert a GIAC expression to a Julia-native value if possible.\n\nReturns\n\nInt64 or BigInt for integer results\nFloat64 for floating-point results\nComplexF64 for complex results\nRational for rational results\nGiacExpr if the expression is symbolic (cannot be converted)\n\nExample\n\nresult = giac_eval(\"2 + 3\")\njulia_value = to_julia(result)  # Returns Int64(5)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.@giac_var","page":"Core API","title":"Giac.@giac_var","text":"@giac_var sym...\n\nCreate symbolic variables from Julia symbols.\n\nCreates GiacExpr variables in the calling scope by internally calling giac_eval with the stringified symbol name. This provides a cleaner syntax for variable declaration similar to @variables in Symbolics.jl.\n\nExamples\n\nSingle variable:\n\n@giac_var x           # Creates x as a GiacExpr\nstring(x)             # \"x\"\nx isa GiacExpr        # true\n\nMultiple variables:\n\n@giac_var x y z       # Creates x, y, z as GiacExpr variables\n\nUsage\n\nusing Giac\n\n@giac_var x y\nexpr = giac_eval(\"x^2 + y^2\")\nresult = giac_diff(expr, x)  # 2*x\n\nSee also\n\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.@giac_several_vars","page":"Core API","title":"Giac.@giac_several_vars","text":"@giac_several_vars base dims...\n\nCreate multiple indexed symbolic variables for N-dimensional tensors.\n\nThis macro generates multiple GiacExpr variables in the calling scope with names formed from a base name and indices. It supports any number of dimensions and returns a tuple of all created variables.\n\nArguments\n\nbase: Symbol - The base name for variables (e.g., a, coeff, α)\ndims...: Integer literals - Dimensions of the tensor (1 or more)\n\nReturns\n\nTuple{GiacExpr...}: A tuple containing all created variables in lexicographic order\n\nNaming Convention\n\nIf all dimensions ≤ 9: indices are concatenated directly (e.g., a123)\nIf any dimension > 9: underscore separators are used (e.g., a_1_10_3)\n\nExamples\n\n1D vector:\n\n@giac_several_vars a 3\n# Creates: a1, a2, a3 and returns (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# Capture return value\nvars = @giac_several_vars c 4\nlength(vars)  # 4\n\n2D matrix:\n\nresult = @giac_several_vars m 2 3\n# Creates: m11, m12, m13, m21, m22, m23\n# Returns: (m11, m12, m13, m21, m22, m23)\nlength(result)  # 6\n\n3D tensor:\n\n@giac_several_vars t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n# Returns tuple of 8 variables\n\nLarge dimensions (separator used):\n\n@giac_several_vars b 2 10 3\n# Creates: b_1_1_1, b_1_1_2, ..., b_2_10_3\n\nUnicode base names:\n\n@giac_several_vars α 2\n# Creates: α1, α2\n\nEdge cases:\n\n@giac_several_vars x 0     # Returns empty tuple ()\n@giac_several_vars y 1     # Creates y1, returns (y1,)\n@giac_several_vars z 2 0   # Returns empty tuple (0 in any dim)\n\nSee also\n\n@giac_var: For creating single symbolic variables\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.list_commands","page":"Core API","title":"Giac.list_commands","text":"list_commands()\n\nReturn a vector of all available GIAC command names.\n\nExample\n\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))\nprintln(\"First 10: \", cmds[1:10])\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help_count","page":"Core API","title":"Giac.help_count","text":"help_count()\n\nReturn the number of commands in the GIAC help database.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands","page":"Core API","title":"Giac.search_commands","text":"search_commands(pattern::String) -> Vector{Symbol}\n\nSearch for commands matching a string prefix.\n\nArguments\n\npattern::String: Prefix to match\n\nReturns\n\nVector{Symbol}: List of matching command names (as Symbols), sorted alphabetically\n\nExample\n\nsearch_commands(\"sin\")  # Returns [:sin, :sinc, :sincos, :sinh, ...]\n\n\n\n\n\nsearch_commands(pattern::Regex) -> Vector{Symbol}\n\nSearch for commands matching a regular expression.\n\nArguments\n\npattern::Regex: Regular expression to match\n\nReturns\n\nVector{Symbol}: List of matching command names (as Symbols), sorted alphabetically\n\nExample\n\nsearch_commands(r\"^a.*n$\")  # Returns commands starting with 'a' and ending with 'n'\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.commands_in_category","page":"Core API","title":"Giac.commands_in_category","text":"commands_in_category(category::Symbol) -> Vector{Symbol}\n\nGet all commands in a specific category.\n\nArguments\n\ncategory::Symbol: Category name (e.g., :trigonometry, :algebra)\n\nReturns\n\nVector{Symbol}: List of command names (as Symbols) in the category, sorted alphabetically\n\nThrows\n\nArgumentError: If the category does not exist\n\nExample\n\ntrig = commands_in_category(:trigonometry)\n# [:acos, :asin, :atan, :cos, :sin, :tan, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.command_info","page":"Core API","title":"Giac.command_info","text":"command_info(cmd::Symbol) -> Union{CommandInfo, Nothing}\n\nGet metadata about a specific command.\n\nArguments\n\ncmd::Symbol: Command name\n\nReturns\n\nCommandInfo: Metadata about the command\nnothing: If the command is not found\n\nExample\n\ninfo = command_info(:factor)\nif info !== nothing\n    println(info.name)      # \"factor\"\n    println(info.category)  # :algebra\nend\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_categories","page":"Core API","title":"Giac.list_categories","text":"list_categories() -> Vector{Symbol}\n\nList all available command categories.\n\nReturns\n\nVector{Symbol}: Category names, sorted alphabetically\n\nExample\n\ncats = list_categories()\n# [:algebra, :calculus, :combinatorics, :geometry, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_help","page":"Core API","title":"Giac.giac_help","text":"giac_help(cmd::Union{Symbol, String}) -> String\n\nGet GIAC help text for a command.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nString: Help text from GIAC, or empty string if not found\n\nExample\n\nhelp = giac_help(:factor)\nprintln(help)  # \"factor(Expr) - Factor a polynomial...\"\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.suggest_commands","page":"Core API","title":"Giac.suggest_commands","text":"suggest_commands(input::Union{Symbol, String}; n::Int=get_suggestion_count()) -> Vector{Symbol}\n\nFind commands similar to the given input using edit distance.\n\nThis function helps users recover from typos by suggesting valid GIAC commands that are similar to the input.\n\nArguments\n\ninput: The mistyped command name (Symbol or String)\nn: Maximum number of suggestions to return (default: get_suggestion_count())\n\nReturns\n\nVector{Symbol}: Similar command names, sorted by edit distance (ascending), then alphabetically. Returns empty vector if no similar commands found.\n\nExample\n\nsuggest_commands(:factr)\n# [:factor, :cfactor, :ifactor, ...]\n\nsuggest_commands(\"integrat\", n=2)\n# [:integrate, ...]\n\nsuggest_commands(:factor)  # Exact match\n# []  (empty, no suggestions needed)\n\nSee also\n\nsuggest_commands_with_distances: Also returns edit distances (internal function)\nset_suggestion_count: Configure default suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.set_suggestion_count","page":"Core API","title":"Giac.set_suggestion_count","text":"set_suggestion_count(n::Int) -> Nothing\n\nSet the default number of command suggestions.\n\nArguments\n\nn: Number of suggestions (must be > 0, otherwise resets to default 4)\n\nExample\n\nset_suggestion_count(6)\nget_suggestion_count()  # 6\n\nset_suggestion_count(-1)  # Invalid, resets to default\nget_suggestion_count()  # 4\n\nSee also\n\nget_suggestion_count: Get the current count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.get_suggestion_count","page":"Core API","title":"Giac.get_suggestion_count","text":"get_suggestion_count() -> Int\n\nGet the current default number of command suggestions.\n\nReturns\n\nInt: Current suggestion count (default: 4)\n\nExample\n\nget_suggestion_count()  # 4 (default)\n\nSee also\n\nset_suggestion_count: Set the suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands_by_description","page":"Core API","title":"Giac.search_commands_by_description","text":"search_commands_by_description(query; n=20) -> Vector{Symbol}\n\nSearch for GIAC commands whose help text contains the given keyword.\n\nUnlike search_commands which matches command names, this function searches the description and example text of each command's help documentation.\n\nArguments\n\nquery::Union{String, Symbol}: Search term to find in help text\nn::Int=20: Maximum number of results to return\n\nReturns\n\nVector{Symbol}: Matching command names (as Symbols), sorted by relevance\n\nExample\n\n# Find commands related to factorization\nsearch_commands_by_description(\"factor\")\n# Returns: [:factor, :ifactor, :cfactor, ...]\n\n# Search for matrix operations\nsearch_commands_by_description(\"matrix\", n=10)\n\nSee also\n\nsearch_commands: Search by command name pattern\ngiac_help: Get raw help for a specific command\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.JULIA_CONFLICTS","page":"Core API","title":"Giac.JULIA_CONFLICTS","text":"JULIA_CONFLICTS\n\nSet of GIAC command names (as Symbols) that conflict with Julia keywords, builtins, or standard library functions. These commands cannot be safely exported as top-level functions but remain accessible via invoke_cmd(:name, args...).\n\nConflict Categories\n\nJulia keywords: if, for, while, end, in, or, and, etc.\nBase builtins: eval, float, sum, prod, div, mod, abs, etc.\nBase math functions: sin, cos, tan, exp, log, sqrt, etc.\nLinearAlgebra: det, inv, trace, rank, transpose, etc.\n\nExample\n\n:eval in JULIA_CONFLICTS  # true\n:factor in JULIA_CONFLICTS  # false\n\n# Conflicting commands still work via invoke_cmd\ninvoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\nexportable_commands: Commands safe to export\nconflict_reason: Get the conflict category for a command\n\n\n\n\n\n","category":"constant"},{"location":"api/core/#Giac.exportable_commands","page":"Core API","title":"Giac.exportable_commands","text":"exportable_commands() -> Vector{Symbol}\n\nGet a list of GIAC commands that can be safely exported without conflicting with Julia keywords, builtins, or standard library functions.\n\nThis function filters the complete command list to include only commands that:\n\nStart with an ASCII letter (a-z, A-Z)\nDo not conflict with Julia (not in JULIA_CONFLICTS)\n\nReturns\n\nVector{Symbol}: Sorted list of exportable command names (as Symbols)\n\nExample\n\ncmds = exportable_commands()\nlength(cmds)        # ~2000+\n:factor in cmds     # true\n:eval in cmds       # false (conflicts with Julia)\n:sin in cmds        # false (conflicts with Base.sin)\nissorted(cmds, by=string)  # true\n\nSee also\n\navailable_commands: All commands starting with ASCII letters\nJULIA_CONFLICTS: Commands that conflict with Julia\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_valid_command","page":"Core API","title":"Giac.is_valid_command","text":"is_valid_command(name::Union{Symbol, String}) -> Bool\n\nCheck if a command name is a valid GIAC command.\n\nArguments\n\nname: Command name as Symbol or String\n\nReturns\n\ntrue if the command exists in GIAC's command list\nfalse otherwise\n\nExample\n\nis_valid_command(:factor)      # true\nis_valid_command(\"integrate\")  # true\nis_valid_command(:notacommand) # false\n\nSee also\n\nlist_commands: Get all command names\nsuggest_commands: Get suggestions for misspelled commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.conflict_reason","page":"Core API","title":"Giac.conflict_reason","text":"conflict_reason(cmd::Union{Symbol, String}) -> Union{Symbol, Nothing}\n\nGet the reason why a GIAC command conflicts with Julia.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\n:keyword - Conflicts with Julia keyword (if, for, while, etc.)\n:builtin - Conflicts with Julia builtin function (eval, float, etc.)\n:base_math - Conflicts with Base math function (sin, cos, exp, etc.)\n:linear_algebra - Conflicts with LinearAlgebra (det, inv, trace, etc.)\n:statistics - Conflicts with Statistics (mean, median, var, etc.)\nnothing - No conflict\n\nExample\n\nconflict_reason(:eval)    # :builtin\nconflict_reason(:sin)     # :base_math\nconflict_reason(:det)     # :linear_algebra\nconflict_reason(:for)     # :keyword\nconflict_reason(:factor)  # nothing\n\nSee also\n\nJULIA_CONFLICTS: Set of all conflicting commands\nexportable_commands: Commands safe to export\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.available_commands","page":"Core API","title":"Giac.available_commands","text":"available_commands()\n\nReturn a sorted vector of all available GIAC command names that start with an ASCII letter (a-z, A-Z).\n\nThis function provides programmatic discovery of available commands. It filters out operators, keywords, and commands starting with non-ASCII characters.\n\nReturns\n\nVector{String}: Sorted list of command names starting with ASCII letters\n\nExample\n\n# List all available commands\ncmds = available_commands()\nprintln(\"Found $(length(cmds)) commands\")  # ~2100+\n\n# Check if a command exists\n\"factor\" in cmds  # true\n\"+\" in cmds       # false (operator)\n\n# Compare with exportable commands\nexportable = exportable_commands()\nlength(exportable)  # ~2000+ (excludes Julia conflicts)\n\nAccessing Commands\n\ninvoke_cmd (all commands): Universal access, always available\ninvoke_cmd(:eval, expr)  # Works for conflicting commands too\ninvoke_cmd(:factor, expr)\nSelective import: Import specific commands from Giac.Commands\nusing Giac.Commands: factor, expand\nfactor(expr)  # Works directly\nFull import: Import all ~2000+ commands\nusing Giac.Commands\nfactor(expr)   # Works directly\nifactor(expr)  # All commands available\n\nSee also\n\nexportable_commands: Commands safe to export (no Julia conflicts)\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all exportable commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.reset_conflict_warnings!","page":"Core API","title":"Giac.reset_conflict_warnings!","text":"reset_conflict_warnings!()\n\nReset the conflict warning tracker, allowing warnings to be shown again.\n\nThis is primarily useful for testing.\n\nExample\n\ngiac_cmd(:eval, expr)  # Shows warning\ngiac_cmd(:eval, expr)  # No warning (already shown)\nreset_conflict_warnings!()\ngiac_cmd(:eval, expr)  # Shows warning again\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_giac","page":"Core API","title":"Giac.to_giac","text":"to_giac(expr)\n\nConvert an expression to GiacExpr. Extended by GiacSymbolicsExt for Symbolics.Num types.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_symbolics","page":"Core API","title":"Giac.to_symbolics","text":"to_symbolics(expr::GiacExpr)\n\nConvert a GiacExpr to a Symbolics.jl expression. Extended by GiacSymbolicsExt.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_stub_mode","page":"Core API","title":"Giac.is_stub_mode","text":"is_stub_mode()\n\nCheck if the wrapper is running in stub mode (without the actual library).\n\n\n\n\n\n","category":"function"},{"location":"developer/memory/#Memory-Management","page":"Memory Management","title":"Memory Management","text":"This guide explains how Giac.jl manages memory for C++ objects, ensuring safe interoperation between Julia's garbage collector and GIAC's memory model.","category":"section"},{"location":"developer/memory/#Overview","page":"Memory Management","title":"Overview","text":"Giac.jl wraps C++ objects from the GIAC library. Since Julia's garbage collector doesn't know about C++ memory, we use Julia's finalizer mechanism to ensure proper cleanup.\n\ngraph LR\n    subgraph \"Julia\"\n        A[GiacExpr]\n        B[Julia GC]\n    end\n\n    subgraph \"C++\"\n        C[giac::gen]\n        D[libgiac memory]\n    end\n\n    A -->|ptr| C\n    B -->|finalizer| A\n    A -.->|cleanup| C\n    C --> D","category":"section"},{"location":"developer/memory/#Key-Principles","page":"Memory Management","title":"Key Principles","text":"Every C++ allocation has a corresponding deallocation\nFinalizers ensure cleanup when Julia objects are garbage collected\nRaw pointers are never exposed in the public API\nThread safety is ensured via locks","category":"section"},{"location":"developer/memory/#GiacExpr-Lifecycle","page":"Memory Management","title":"GiacExpr Lifecycle","text":"Understanding the lifecycle of a GiacExpr is essential for safe development.\n\nsequenceDiagram\n    participant User\n    participant GiacExpr\n    participant Finalizer\n    participant C++\n\n    User->>C++: giac_eval(\"x^2\")\n    C++-->>GiacExpr: Create with ptr\n    Note over GiacExpr: Register finalizer\n\n    User->>GiacExpr: Use expression\n    GiacExpr->>C++: Operations via ptr\n\n    Note over User: GiacExpr goes out of scope\n    User->>GiacExpr: (unreachable)\n\n    Note over GiacExpr: Julia GC runs\n    GiacExpr->>Finalizer: Trigger finalizer\n    Finalizer->>C++: _giac_free_expr(ptr)\n    C++-->>Finalizer: Memory freed","category":"section"},{"location":"developer/memory/#Creation","page":"Memory Management","title":"Creation","text":"When a GiacExpr is created, a finalizer is automatically registered:\n\n# In types.jl\nmutable struct GiacExpr\n    ptr::Ptr{Cvoid}\n\n    function GiacExpr(ptr::Ptr{Cvoid})\n        expr = new(ptr)\n        finalizer(_finalize_giacexpr, expr)  # Register cleanup\n        return expr\n    end\nend","category":"section"},{"location":"developer/memory/#Usage","page":"Memory Management","title":"Usage","text":"During its lifetime, the GiacExpr can be used normally:\n\nx = giac_eval(\"x\")\ny = sin(x) + cos(x)  # Creates new GiacExpr objects\nresult = y.simplify()  # Method-style syntax also works","category":"section"},{"location":"developer/memory/#Finalization","page":"Memory Management","title":"Finalization","text":"When the Julia GC determines the object is unreachable, the finalizer runs:\n\nfunction _finalize_giacexpr(expr::GiacExpr)\n    if expr.ptr != C_NULL\n        _giac_free_expr(expr.ptr)  # Call C++ destructor\n        expr.ptr = C_NULL  # Prevent double-free\n    end\nend","category":"section"},{"location":"developer/memory/#Finalizer-Functions","page":"Memory Management","title":"Finalizer Functions","text":"Giac.jl defines three finalizer functions for its wrapped types.","category":"section"},{"location":"developer/memory/#_finalize_giacexpr","page":"Memory Management","title":"_finalize_giacexpr","text":"Cleans up GIAC expression objects.\n\nfunction _finalize_giacexpr(expr::GiacExpr)\n    if expr.ptr != C_NULL\n        _giac_free_expr(expr.ptr)\n        expr.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacExpr object is garbage collected.","category":"section"},{"location":"developer/memory/#_finalize_giaccontext","page":"Memory Management","title":"_finalize_giaccontext","text":"Cleans up GIAC context objects.\n\nfunction _finalize_giaccontext(ctx::GiacContext)\n    if ctx.ptr != C_NULL\n        _giac_free_context(ctx.ptr)\n        ctx.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacContext object is garbage collected.\n\nNote: The DEFAULT_CONTEXT is never garbage collected during normal operation since it's referenced by the module.","category":"section"},{"location":"developer/memory/#_finalize_giacmatrix","page":"Memory Management","title":"_finalize_giacmatrix","text":"Cleans up GIAC matrix objects.\n\nfunction _finalize_giacmatrix(m::GiacMatrix)\n    if m.ptr != C_NULL\n        _giac_free_matrix(m.ptr)\n        m.ptr = C_NULL\n    end\nend\n\nCalled when: A GiacMatrix object is garbage collected.","category":"section"},{"location":"developer/memory/#Thread-Safety","page":"Memory Management","title":"Thread Safety","text":"GIAC is not inherently thread-safe, so Giac.jl uses locks to prevent concurrent access.","category":"section"},{"location":"developer/memory/#The-with_giac_lock-Pattern","page":"Memory Management","title":"The with_giac_lock Pattern","text":"All evaluation operations use with_giac_lock:\n\nfunction with_giac_lock(f::Function, ctx::GiacContext=DEFAULT_CONTEXT)\n    lock(ctx.lock)\n    try\n        return f()\n    finally\n        unlock(ctx.lock)\n    end\nend","category":"section"},{"location":"developer/memory/#Usage-in-Code","page":"Memory Management","title":"Usage in Code","text":"# In command_utils.jl\nfunction giac_cmd(cmd::Symbol, args...)::GiacExpr\n    # ... argument processing ...\n\n    return with_giac_lock() do\n        giac_eval(cmd_string)\n    end\nend","category":"section"},{"location":"developer/memory/#GiacContext-Lock","page":"Memory Management","title":"GiacContext Lock","text":"Each GiacContext contains a ReentrantLock:\n\nmutable struct GiacContext\n    ptr::Ptr{Cvoid}\n    lock::ReentrantLock  # For thread safety\n\n    function GiacContext(ptr::Ptr{Cvoid})\n        ctx = new(ptr, ReentrantLock())\n        finalizer(_finalize_giaccontext, ctx)\n        return ctx\n    end\nend\n\nWhy ReentrantLock?: Allows the same thread to acquire the lock multiple times (nested calls), which is necessary for complex expression evaluation.","category":"section"},{"location":"developer/memory/#Best-Practices","page":"Memory Management","title":"Best Practices","text":"","category":"section"},{"location":"developer/memory/#Do:-Use-Finalizers-for-New-Types","page":"Memory Management","title":"Do: Use Finalizers for New Types","text":"If you create a new type that wraps C++ memory:\n\nmutable struct MyNewType\n    ptr::Ptr{Cvoid}\n\n    function MyNewType(ptr::Ptr{Cvoid})\n        obj = new(ptr)\n        finalizer(_finalize_mynewtype, obj)  # Always register!\n        return obj\n    end\nend\n\nfunction _finalize_mynewtype(obj::MyNewType)\n    if obj.ptr != C_NULL\n        _my_free_function(obj.ptr)\n        obj.ptr = C_NULL\n    end\nend","category":"section"},{"location":"developer/memory/#Do:-Check-for-Null-Pointers","page":"Memory Management","title":"Do: Check for Null Pointers","text":"Always check before using pointers:\n\nfunction safe_operation(expr::GiacExpr)\n    if expr.ptr == C_NULL\n        throw(GiacError(\"Expression has been freed\", :memory))\n    end\n    # ... proceed with operation\nend","category":"section"},{"location":"developer/memory/#Do:-Use-the-Lock-for-Evaluation","page":"Memory Management","title":"Do: Use the Lock for Evaluation","text":"Always use with_giac_lock when calling GIAC:\n\nfunction my_custom_eval(expr::GiacExpr)\n    return with_giac_lock() do\n        # All GIAC calls inside the lock\n        result = giac_eval(string(expr))\n        return result\n    end\nend","category":"section"},{"location":"developer/memory/#Don't:-Expose-Raw-Pointers","page":"Memory Management","title":"Don't: Expose Raw Pointers","text":"Never expose Ptr{Cvoid} in public API:\n\n# Bad: Exposes internal pointer\nfunction get_ptr(expr::GiacExpr)\n    return expr.ptr  # Don't do this!\nend\n\n# Good: Return wrapped type or Julia value\nfunction get_value(expr::GiacExpr)\n    return to_julia(expr)  # Returns proper Julia type\nend","category":"section"},{"location":"developer/memory/#Don't:-Hold-References-Across-Threads","page":"Memory Management","title":"Don't: Hold References Across Threads","text":"Avoid sharing GiacExpr between threads without proper synchronization:\n\n# Risky: expr shared across threads\n@threads for i in 1:10\n    result = sin(expr)  # Race condition!\nend\n\n# Better: Create local copies or use proper synchronization\nresults = Vector{GiacExpr}(undef, 10)\n@threads for i in 1:10\n    local_expr = giac_eval(string(expr))  # Local copy\n    results[i] = sin(local_expr)\nend","category":"section"},{"location":"developer/memory/#Don't:-Manually-Free-Memory","page":"Memory Management","title":"Don't: Manually Free Memory","text":"Let finalizers handle cleanup:\n\n# Bad: Manual memory management\nexpr = giac_eval(\"x\")\n_giac_free_expr(expr.ptr)  # Don't do this!\nexpr.ptr = C_NULL\n\n# Good: Let Julia GC handle it\nexpr = giac_eval(\"x\")\n# Just let it go out of scope","category":"section"},{"location":"developer/memory/#Common-Pitfalls","page":"Memory Management","title":"Common Pitfalls","text":"","category":"section"},{"location":"developer/memory/#Memory-Leaks","page":"Memory Management","title":"Memory Leaks","text":"Symptom: Memory usage grows over time without bound.\n\nCause: Finalizers not registered, or C++ objects created without wrapping.\n\nFix: Ensure every Ptr{Cvoid} from C++ is wrapped in a Julia type with a finalizer.","category":"section"},{"location":"developer/memory/#Dangling-Pointers","page":"Memory Management","title":"Dangling Pointers","text":"Symptom: Segmentation fault or garbage values.\n\nCause: Using a pointer after its memory has been freed.\n\nFix: Always check for C_NULL before using pointers; don't manually free memory.","category":"section"},{"location":"developer/memory/#Race-Conditions","page":"Memory Management","title":"Race Conditions","text":"Symptom: Intermittent crashes or wrong results with multithreading.\n\nCause: Multiple threads accessing GIAC without synchronization.\n\nFix: Use with_giac_lock for all GIAC operations.","category":"section"},{"location":"developer/memory/#Double-Free","page":"Memory Management","title":"Double Free","text":"Symptom: Crash with \"double free or corruption\" error.\n\nCause: Memory freed twice, often from manual _giac_free_* calls.\n\nFix: Never call free functions manually; let finalizers handle it. Set pointer to C_NULL in finalizer to prevent double-free.","category":"section"},{"location":"developer/memory/#Debugging-Memory-Issues","page":"Memory Management","title":"Debugging Memory Issues","text":"","category":"section"},{"location":"developer/memory/#Using-Julia's-GC","page":"Memory Management","title":"Using Julia's GC","text":"Force garbage collection to trigger finalizers:\n\nGC.gc()  # Run garbage collector","category":"section"},{"location":"developer/memory/#Checking-for-Leaks","page":"Memory Management","title":"Checking for Leaks","text":"Monitor memory usage:\n\nfunction memory_test()\n    initial = Sys.maxrss()\n    for i in 1:10000\n        x = giac_eval(\"x^$i\")\n    end\n    GC.gc()\n    final = Sys.maxrss()\n    println(\"Memory change: $(final - initial) bytes\")\nend","category":"section"},{"location":"developer/memory/#Pointer-Validation","page":"Memory Management","title":"Pointer Validation","text":"Check if a pointer is valid:\n\nfunction is_valid(expr::GiacExpr)\n    return expr.ptr != C_NULL\nend","category":"section"},{"location":"developer/memory/#See-Also","page":"Memory Management","title":"See Also","text":"Package Architecture - Type definitions in types.jl\nTroubleshooting - Debugging memory-related errors\nPerformance Tiers - How tier wrappers handle pointers\n\n","category":"section"},{"location":"api/tempapi/#TempApi-Submodule","page":"TempApi","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for common symbolic computation operations.","category":"section"},{"location":"api/tempapi/#Usage","page":"TempApi","title":"Usage","text":"","category":"section"},{"location":"api/tempapi/#Selective-Import-(Recommended)","page":"TempApi","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.TempApi: diff, factor, integrate\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)     # 2*x\nfactor(expr)      # (x-1)*(x+1)","category":"section"},{"location":"api/tempapi/#Full-Import","page":"TempApi","title":"Full Import","text":"using Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\ndiff(giac_eval(\"x^3\"), x)  # 3*x^2","category":"section"},{"location":"api/tempapi/#Calculus-Functions","page":"TempApi","title":"Calculus Functions","text":"","category":"section"},{"location":"api/tempapi/#Algebra-Functions","page":"TempApi","title":"Algebra Functions","text":"","category":"section"},{"location":"api/tempapi/#Giac.TempApi","page":"TempApi","title":"Giac.TempApi","text":"Giac.TempApi\n\nA submodule providing convenience functions with simplified names for common symbolic computation operations. These functions delegate to invoke_cmd from the main Giac module.\n\nThis is intended as a temporary API for interactive use and quick access to  common commands without needing to import the entire Giac.Commands submodule.\n\nAccess Patterns\n\nFull import (for interactive use):\nusing Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nSelective import (recommended):\nusing Giac\nusing Giac.TempApi: diff, factor\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)    # Works\nfactor(expr)     # Works\nQualified access:\nusing Giac\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)\n\nExports\n\ndiff: Differentiate an expression (uses invoke_cmd(:diff, ...))\nintegrate: Integrate an expression (uses invoke_cmd(:integrate, ...))\nlimit: Compute limit (uses invoke_cmd(:limit, ...))\nfactor: Factor a polynomial (uses invoke_cmd(:factor, ...))\nexpand: Expand an expression (uses invoke_cmd(:expand, ...))\nsimplify: Simplify an expression (uses invoke_cmd(:simplify, ...))\nsolve: Solve an equation (uses invoke_cmd(:solve, ...))\n\nSee also\n\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all GIAC commands\n\n\n\n\n\n","category":"module"},{"location":"api/tempapi/#Giac.TempApi.diff","page":"TempApi","title":"Giac.TempApi.diff","text":"diff(expr, var, n=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nUses invoke_cmd(:diff, ...).\n\nArguments\n\nexpr: Expression to differentiate (GiacExpr or String)\nvar: Variable to differentiate with respect to (GiacExpr or String)\nn: Order of differentiation (default: 1)\n\nReturns\n\nGiacExpr: The derivative\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndiff(f, x)      # 3*x^2\ndiff(f, x, 2)   # 6*x\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.integrate","page":"TempApi","title":"Giac.TempApi.integrate","text":"integrate(expr, var)\nintegrate(expr, var, a, b)\n\nCompute indefinite or definite integral.\n\nUses invoke_cmd(:integrate, ...).\n\nArguments\n\nexpr: Expression to integrate (GiacExpr or String)\nvar: Variable of integration (GiacExpr or String)\na, b: Optional bounds for definite integration\n\nReturns\n\nGiacExpr: The integral\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nintegrate(f, x)           # x^3/3\nintegrate(f, x, 0, 1)     # 1/3\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.limit","page":"TempApi","title":"Giac.TempApi.limit","text":"limit(expr, var, point; direction=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nUses invoke_cmd(:limit, ...).\n\nArguments\n\nexpr: The expression (GiacExpr or String)\nvar: The variable (GiacExpr or String)\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nReturns\n\nGiacExpr: The limit\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlimit(f, x, giac_eval(\"0\"))  # 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.factor","page":"TempApi","title":"Giac.TempApi.factor","text":"factor(expr)\n\nFactor a polynomial expression.\n\nUses invoke_cmd(:factor, ...).\n\nArguments\n\nexpr: Expression to factor (GiacExpr or String)\n\nReturns\n\nGiacExpr: The factored expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"x^2 - 1\")\nfactor(p)  # (x-1)*(x+1)\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.expand","page":"TempApi","title":"Giac.TempApi.expand","text":"expand(expr)\n\nExpand a polynomial expression.\n\nUses invoke_cmd(:expand, ...).\n\nArguments\n\nexpr: Expression to expand (GiacExpr or String)\n\nReturns\n\nGiacExpr: The expanded expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"(x+1)^3\")\nexpand(p)  # x^3 + 3*x^2 + 3*x + 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.simplify","page":"TempApi","title":"Giac.TempApi.simplify","text":"simplify(expr)\n\nSimplify an expression.\n\nUses invoke_cmd(:simplify, ...).\n\nArguments\n\nexpr: Expression to simplify (GiacExpr or String)\n\nReturns\n\nGiacExpr: The simplified expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\nsimplify(e)  # x + 1\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.solve","page":"TempApi","title":"Giac.TempApi.solve","text":"solve(expr, var)\n\nSolve an equation for a variable.\n\nUses invoke_cmd(:solve, ...).\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsolve(eq, x)  # [-2, 2]\n\nSee also\n\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"function"},{"location":"substitute/#Variable-Substitution","page":"Variable Substitution","title":"Variable Substitution","text":"Giac.jl provides a substitute function with a Symbolics.jl-compatible interface for variable substitution in symbolic expressions.","category":"section"},{"location":"substitute/#Basic-Usage","page":"Variable Substitution","title":"Basic Usage","text":"","category":"section"},{"location":"substitute/#Single-Variable-Substitution","page":"Variable Substitution","title":"Single Variable Substitution","text":"using Giac\n\n# Create symbolic variables\n@giac_var x y\n\n# Create an expression\nexpr = x^2 + 2*x + 1\n\n# Substitute x = 3\nresult = substitute(expr, Dict(x => 3))\n# Returns: 16 (which is 9 + 6 + 1)\n\n# Substitute with symbolic value\nresult = substitute(expr, Dict(x => y))\n# Returns: y^2 + 2*y + 1","category":"section"},{"location":"substitute/#Pair-Syntax-(Shorthand)","page":"Variable Substitution","title":"Pair Syntax (Shorthand)","text":"For single-variable substitutions, you can use the Pair syntax:\n\n@giac_var x\n\nsubstitute(x + 1, x => 5)  # Returns: 6","category":"section"},{"location":"substitute/#Multiple-Variable-Substitution","page":"Variable Substitution","title":"Multiple Variable Substitution","text":"Substitute multiple variables simultaneously:\n\n@giac_var x y z\n\nexpr = x*y + y*z + x*z\n\n# Substitute multiple variables at once\nresult = substitute(expr, Dict(x => 1, y => 2, z => 3))\n# Returns: 11 (which is 2 + 6 + 3)","category":"section"},{"location":"substitute/#Variable-Swapping","page":"Variable Substitution","title":"Variable Swapping","text":"The substitution is performed simultaneously, making variable swapping work correctly:\n\n@giac_var a b\n\nexpr = a^2 + b\n\n# Simultaneous substitution correctly swaps variables\nresult = substitute(expr, Dict(a => b, b => a))\n# Returns: b^2 + a","category":"section"},{"location":"substitute/#With-GIAC-Functions","page":"Variable Substitution","title":"With GIAC Functions","text":"The substitute function works with any GIAC-supported functions:\n\n@giac_var θ\n\nexpr = invoke_cmd(:sin, θ) + invoke_cmd(:cos, θ)\n\n# Substitute θ = π/4\nusing Giac.Commands: simplify\nresult = substitute(expr, Dict(θ => giac_eval(\"pi/4\"))) |> simplify\n# Returns: sqrt(2)","category":"section"},{"location":"substitute/#Symbolic-to-Symbolic-Substitution","page":"Variable Substitution","title":"Symbolic-to-Symbolic Substitution","text":"Replace variables with complex expressions:\n\n@giac_var x y\n\n# x^2 with x = y + 1\nresult = substitute(x^2, Dict(x => y + 1))\n# Returns: (y + 1)^2","category":"section"},{"location":"substitute/#Chained-Substitution","page":"Variable Substitution","title":"Chained Substitution","text":"Apply multiple substitutions in sequence:\n\n@giac_var x y z\n\nexpr = x + y + z\n\nstep1 = substitute(expr, x => 1)\nstep2 = substitute(step1, y => 2)\nfinal = substitute(step2, z => 3)\n# Returns: 6","category":"section"},{"location":"substitute/#Comparison-with-Symbolics.jl","page":"Variable Substitution","title":"Comparison with Symbolics.jl","text":"The API is designed to match Symbolics.jl's substitute function:\n\n# Symbolics.jl style (works in Giac.jl)\nsubstitute(expr, Dict(x => 2, y => 3))\n\n# Single variable shorthand\nsubstitute(expr, x => value)","category":"section"},{"location":"substitute/#Edge-Cases","page":"Variable Substitution","title":"Edge Cases","text":"@giac_var x y\n\n# Empty Dict returns original expression\nsubstitute(x + 1, Dict{GiacExpr, Int}())  # Returns: x + 1\n\n# Missing variable is ignored\nsubstitute(x + 1, Dict(y => 5))  # Returns: x + 1 (y not in expr)","category":"section"},{"location":"substitute/#Matrix-Substitution","page":"Variable Substitution","title":"Matrix Substitution","text":"The substitute function also works element-wise on GiacMatrix:","category":"section"},{"location":"substitute/#Single-Variable-in-Matrix","page":"Variable Substitution","title":"Single Variable in Matrix","text":"@giac_var x\n\nM = GiacMatrix([x x+1; 2*x x^2])\n\n# Substitute x = 3 in all elements\nresult = substitute(M, x => 3)\n# Returns: [[3, 4], [6, 9]]","category":"section"},{"location":"substitute/#Multiple-Variables-in-Matrix","page":"Variable Substitution","title":"Multiple Variables in Matrix","text":"@giac_var x y\n\nM = GiacMatrix([x+y x*y; x-y x/y])\n\n# Substitute x = 6, y = 2 in all elements\nresult = substitute(M, Dict(x => 6, y => 2))\n# Returns: [[8, 12], [4, 3]]","category":"section"},{"location":"substitute/#Partial-Substitution","page":"Variable Substitution","title":"Partial Substitution","text":"@giac_var x y\n\nM = GiacMatrix([x y; x+y x*y])\n\n# Only substitute x, leave y symbolic\nresult = substitute(M, Dict(x => 2))\n# Returns: [[2, y], [2+y, 2*y]]","category":"section"},{"location":"substitute/#Symbolic-Substitution-in-Matrix","page":"Variable Substitution","title":"Symbolic Substitution in Matrix","text":"@giac_var x y\n\nM = GiacMatrix([x^2 x; 1 x+1])\n\n# Replace x with y+1\nresult = substitute(M, Dict(x => y + 1))\n# Returns: [[(y+1)^2, y+1], [1, y+2]]","category":"section"},{"location":"substitute/#API-Reference","page":"Variable Substitution","title":"API Reference","text":"","category":"section"},{"location":"substitute/#Giac.substitute","page":"Variable Substitution","title":"Giac.substitute","text":"substitute(expr::GiacExpr, dict::AbstractDict{<:GiacExpr}) -> GiacExpr\n\nSubstitute variables in a symbolic expression according to a dictionary mapping.\n\nPerforms simultaneous substitution of all variables in dict. The original expression is not modified.\n\nArguments\n\nexpr::GiacExpr: The expression to transform\ndict::AbstractDict: Mapping from variables (GiacExpr) to replacement values\n\nReturns\n\nGiacExpr: New expression with substitutions applied\n\nExamples\n\n@giac_var x y\nexpr = x^2 + y\nsubstitute(expr, Dict(x => 2))        # Returns: 4 + y\nsubstitute(expr, Dict(x => 2, y => 3)) # Returns: 7\nsubstitute(expr, Dict(x => y, y => x)) # Swaps x and y: y^2 + x\n\nSee also\n\ninvoke_cmd: Lower-level command invocation\n@giac_var: Create symbolic variables\n\n\n\n\n\nsubstitute(expr::GiacExpr, pair::Pair{<:GiacExpr}) -> GiacExpr\n\nSubstitute a single variable using Pair syntax.\n\nConvenience method equivalent to substitute(expr, Dict(pair)).\n\nExamples\n\n@giac_var x\nsubstitute(x + 1, x => 5)  # Returns: 6\n\nSee also\n\nsubstitute(::GiacExpr, ::AbstractDict): Full Dict-based substitution\n\n\n\n\n\nsubstitute(m::GiacMatrix, dict::AbstractDict{<:GiacExpr}) -> GiacMatrix\n\nSubstitute variables in each element of a symbolic matrix.\n\nPerforms element-wise substitution, applying the same variable mappings to every element of the matrix. Returns a new matrix with the same dimensions.\n\nArguments\n\nm::GiacMatrix: The matrix to transform\ndict::AbstractDict: Mapping from variables (GiacExpr) to replacement values\n\nReturns\n\nGiacMatrix: New matrix with substitutions applied element-wise\n\nExamples\n\n@giac_var x y\nM = GiacMatrix([x+1 2*x; y x*y])\nsubstitute(M, Dict(x => 2))        # Returns matrix with x=2 substituted\nsubstitute(M, Dict(x => 2, y => 3)) # Returns fully numeric matrix\n\nSee also\n\nsubstitute(::GiacExpr, ::AbstractDict): Scalar expression substitution\n\n\n\n\n\nsubstitute(m::GiacMatrix, pair::Pair{<:GiacExpr}) -> GiacMatrix\n\nSubstitute a single variable in each element of a matrix using Pair syntax.\n\nConvenience method equivalent to substitute(m, Dict(pair)).\n\nExamples\n\n@giac_var x\nM = GiacMatrix([x 2*x; x+1 x^2])\nsubstitute(M, x => 3)  # Returns: [[3, 6], [4, 9]]\n\nSee also\n\nsubstitute(::GiacMatrix, ::AbstractDict): Full Dict-based matrix substitution\n\n\n\n\n\n","category":"function"},{"location":"developer/architecture/#Package-Architecture","page":"Package Architecture","title":"Package Architecture","text":"This page explains the internal structure of Giac.jl, helping developers understand how the package is organized and how components interact.","category":"section"},{"location":"developer/architecture/#Overview","page":"Package Architecture","title":"Overview","text":"Giac.jl wraps the GIAC computer algebra system (C++) for use in Julia. The package uses CxxWrap.jl for C++/Julia interoperability and provides a Julia-native API.\n\ngraph TB\n    subgraph Julia_User_Code[\"Julia User Code\"]\n        A[User Code]\n    end\n\n    subgraph Giac_jl_Package[\"Giac.jl Package\"]\n        B[\"api.jl (High-level API)\"]\n        C[\"command_utils.jl (giac_cmd)\"]\n        D[\"wrapper.jl (CxxWrap)\"]\n        E[\"types.jl (GiacExpr)\"]\n    end\n\n    subgraph External_Libraries[\"External Libraries\"]\n        F[\"libgiac-julia-wrapper\"]\n        G[\"libgiac (GIAC CAS)\"]\n    end\n\n    A --> B\n    A --> C\n    B --> D\n    C --> D\n    D --> F\n    F --> G\n    E -.-> D","category":"section"},{"location":"developer/architecture/#Source-File-Reference","page":"Package Architecture","title":"Source File Reference","text":"File Purpose Key Exports Dependencies\nGiac.jl Main module entry point Giac module All other files\ntypes.jl Type definitions GiacExpr, GiacContext, GiacMatrix, GiacError None\nwrapper.jl CxxWrap bindings, Tier 1/2 functions _giac_eval_string, _giac_*_tier1 types.jl\napi.jl High-level Julia API giac_eval, to_julia wrapper.jl, types.jl\ncommand_utils.jl Command invocation, Base extensions giac_cmd, Base.sin(::GiacExpr) wrapper.jl, types.jl\nCommands.jl Commands submodule invoke_cmd, ~2000 command functions command_utils.jl\ncommand_registry.jl Command discovery VALID_COMMANDS, suggest_commands None\nnamespace_commands.jl Namespace-specific commands Namespace command helpers command_registry.jl\noperators.jl Arithmetic operators +, -, *, /, ^ for GiacExpr types.jl\nmacros.jl User convenience macros @giac_var, @giac_several_vars api.jl\nutils.jl Helper utilities Internal utilities None\nTempApi.jl Temporary API submodule TempApi functions api.jl","category":"section"},{"location":"developer/architecture/#Module-Initialization","page":"Package Architecture","title":"Module Initialization","text":"When using Giac is executed, the following initialization sequence occurs:\n\nsequenceDiagram\n    participant User\n    participant Giac.jl\n    participant wrapper.jl\n    participant GiacCxxBindings\n    participant libgiac\n\n    User->>Giac.jl: using Giac\n    Giac.jl->>Giac.jl: include all source files\n    Giac.jl->>wrapper.jl: __init__()\n    wrapper.jl->>GiacCxxBindings: init_giac_library()\n    GiacCxxBindings->>libgiac: Load shared library (RTLD_GLOBAL)\n    libgiac-->>GiacCxxBindings: Library loaded\n    GiacCxxBindings-->>wrapper.jl: Ready\n    wrapper.jl->>Giac.jl: Create DEFAULT_CONTEXT\n    Giac.jl->>Giac.jl: _init_command_registry()\n    Giac.jl->>Commands.jl: Commands.__init__()\n    Commands.jl->>Commands.jl: Generate ~2000 command functions\n    Commands.jl-->>User: Ready to use","category":"section"},{"location":"developer/architecture/#What-Happens-in-__init__()","page":"Package Architecture","title":"What Happens in __init__()","text":"Library Loading: init_giac_library() loads the C++ wrapper library with RTLD_GLOBAL flag to ensure proper symbol resolution\nContext Creation: Creates DEFAULT_CONTEXT, the global evaluation context\nCommand Registry: Initializes the registry of valid GIAC commands\nCommands Module: Dynamically generates wrapper functions for all GIAC commands","category":"section"},{"location":"developer/architecture/#Type-System","page":"Package Architecture","title":"Type System","text":"Giac.jl defines four core types for working with GIAC:\n\nclassDiagram\n    class GiacExpr {\n        +Ptr~Cvoid~ ptr\n        +finalizer()\n        +show()\n        +getproperty()\n    }\n\n    class GiacContext {\n        +Ptr~Cvoid~ ptr\n        +ReentrantLock lock\n        +finalizer()\n    }\n\n    class GiacMatrix {\n        +Ptr~Cvoid~ ptr\n        +Int rows\n        +Int cols\n        +finalizer()\n        +getindex()\n    }\n\n    class GiacError {\n        +String message\n        +Symbol category\n    }\n\n    GiacExpr --> GiacContext : uses\n    GiacMatrix --> GiacExpr : contains","category":"section"},{"location":"developer/architecture/#GiacExpr","page":"Package Architecture","title":"GiacExpr","text":"The primary type representing a GIAC expression. Wraps a pointer to a C++ giac::gen object.\n\nmutable struct GiacExpr\n    ptr::Ptr{Cvoid}\nend\n\nAutomatic memory management: Uses Julia's finalizer to free C++ memory\nMethod-style syntax: Supports expr.factor() which translates to giac_cmd(:factor, expr)\nDisplay: Implements show for text and LaTeX output","category":"section"},{"location":"developer/architecture/#GiacContext","page":"Package Architecture","title":"GiacContext","text":"Evaluation context managing computation state.\n\nmutable struct GiacContext\n    ptr::Ptr{Cvoid}\n    lock::ReentrantLock\nend\n\nThread safety: Contains a ReentrantLock for concurrent access\nConfiguration: Holds computation settings (precision, assumptions, etc.)","category":"section"},{"location":"developer/architecture/#GiacMatrix","page":"Package Architecture","title":"GiacMatrix","text":"Symbolic matrix type with dimension tracking.\n\nmutable struct GiacMatrix\n    ptr::Ptr{Cvoid}\n    rows::Int\n    cols::Int\nend\n\nIndexing: Supports m[i,j] returning a GiacExpr\nConstruction: Can be created from Julia arrays or symbolically","category":"section"},{"location":"developer/architecture/#GiacError","page":"Package Architecture","title":"GiacError","text":"Exception type for GIAC-related errors.\n\nstruct GiacError <: Exception\n    message::String\n    category::Symbol  # :parse, :eval, :type, :memory\nend","category":"section"},{"location":"developer/architecture/#Data-Flow","page":"Package Architecture","title":"Data Flow","text":"A typical function call flows through the package like this:\n\nflowchart LR\n    A[\"User: sin(x)\"] --> B{GiacExpr?}\n    B -->|Yes| C[command_utils.jl]\n    B -->|No| D[Julia Base]\n    C --> E{Tier 1?}\n    E -->|Yes| F[\"wrapper.jl (_giac_sin_tier1)\"]\n    E -->|No| G[giac_cmd]\n    F --> H[C++ wrapper]\n    G --> I[String evaluation]\n    H --> J[libgiac]\n    I --> J\n    J --> K[\"Result: GiacExpr\"]","category":"section"},{"location":"developer/architecture/#File-Dependencies","page":"Package Architecture","title":"File Dependencies","text":"Understanding which files depend on which helps when making changes:\n\ngraph TD\n    A[types.jl] --> B[wrapper.jl]\n    A --> C[operators.jl]\n    B --> D[api.jl]\n    B --> E[command_utils.jl]\n    D --> F[macros.jl]\n    E --> G[Commands.jl]\n    H[command_registry.jl] --> E\n    H --> I[namespace_commands.jl]\n    D --> J[TempApi.jl]\n\n    K[Giac.jl] --> A\n    K --> B\n    K --> C\n    K --> D\n    K --> E\n    K --> F\n    K --> G\n    K --> H\n    K --> I\n    K --> J","category":"section"},{"location":"developer/architecture/#Where-to-Make-Changes","page":"Package Architecture","title":"Where to Make Changes","text":"Change Type Files to Modify\nAdd a new high-performance function wrapper.jl (Tier 1), command_utils.jl (Base extension)\nAdd a new type types.jl\nExtend an existing command command_utils.jl or Commands.jl\nAdd a new macro macros.jl\nModify operator behavior operators.jl\nChange initialization Giac.jl (__init__) or wrapper.jl\nAdd API documentation docstrings in relevant file","category":"section"},{"location":"developer/architecture/#See-Also","page":"Package Architecture","title":"See Also","text":"Performance Tiers - Deep dive into the tier system\nAdding Functions - Step-by-step contribution guide\nMemory Management - How memory is managed\n\n","category":"section"},{"location":"pluto/#Using-Giac.jl-with-Pluto-reactive-notebook","page":"Using with Pluto reactive notebooks","title":"Using Giac.jl with Pluto reactive notebook","text":"","category":"section"},{"location":"pluto/#LaTeX-Rendering-in-Pluto","page":"Using with Pluto reactive notebooks","title":"LaTeX Rendering in Pluto","text":"GiacExpr and GiacMatrix automatically render as LaTeX in Pluto notebooks! No extra conversion needed:\n\nusing Giac\n\nf = giac_eval(\"2/(1-x)\")  # Automatically displays as LaTeX fraction\ndf = invoke_cmd(:diff, f, giac_eval(\"x\"))  # Derivative also renders as LaTeX\n\nM = GiacMatrix([1 2; 3 4])  # Matrices render as LaTeX too\n\nThis works because Giac.jl implements Base.show(io, ::MIME\"text/latex\", expr) which calls GIAC's native latex command.\n\nA demo notebook is available at examples/latex_demo.jl:\n\nusing Pluto\nPluto.run(notebook=\"examples/latex_demo.jl\")\n\nSee screenshot:\n\n(Image: screencapture-pluto-notebook)\n\n","category":"section"},{"location":"linear_algebra/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"using Giac, LinearAlgebra\n\nA = GiacMatrix([1 2; 3 4])\ndet(A)        # -2\ntr(A)         # 5\ninv(A)        # inverse matrix\ntranspose(A)  # transposed matrix\n\n# Symbolic matrix\n@giac_var a b c d\nB = GiacMatrix([[a, b],\n                [c, d]])\ndet(B)  # a*d-b*c\n\n@giac_several_vars m 2 2\nM = GiacMatrix([[m11, m12],\n                [m21, m22]])\ndet(M)  # m11*m22-m12*m21\n\njulia> GiacMatrix(:m, 100, 100)\n100×100 GiacMatrix:\n  m_1_1    m_1_2    m_1_3    m_1_4    m_1_5  ⋯    m_1_99    m_1_100\n  m_2_1    m_2_2    m_2_3    m_2_4    m_2_5  ⋯    m_2_99    m_2_100\n  m_3_1    m_3_2    m_3_3    m_3_4    m_3_5  ⋯    m_3_99    m_3_100\n  m_4_1    m_4_2    m_4_3    m_4_4    m_4_5  ⋯    m_4_99    m_4_100\n  m_5_1    m_5_2    m_5_3    m_5_4    m_5_5  ⋯    m_5_99    m_5_100\n      ⋮        ⋮        ⋮        ⋮        ⋮  ⋱         ⋮          ⋮\n m_99_1   m_99_2   m_99_3   m_99_4   m_99_5  ⋯   m_99_99   m_99_100\nm_100_1  m_100_2  m_100_3  m_100_4  m_100_5  ⋯  m_100_99  m_100_100","category":"section"},{"location":"linear_algebra/#Table-of-functions","page":"Linear Algebra","title":"Table of functions","text":"Function Description\nGiacMatrix(array) Create symbolic matrix\ndet(M) Determinant\ninv(M) Inverse\ntr(M) Trace\ntranspose(M) Transpose\n\n","category":"section"},{"location":"variables/#Symbolic-variables","page":"Variable Declaration","title":"Symbolic variables","text":"","category":"section"},{"location":"variables/#Simple-Variable-Creation","page":"Variable Declaration","title":"Simple Variable Creation","text":"Create a symbolic variable with @giac_var:\n\nusing Giac\n\n@giac_var a\n@giac_var a\n\na + b\n\n# or simply\n\n@giac_var a b","category":"section"},{"location":"variables/#Batch-Variable-Creation","page":"Variable Declaration","title":"Batch Variable Creation","text":"Create multiple indexed symbolic variables with @giac_several_vars:\n\nusing Giac\n\n# 1D vector of variables\n@giac_several_vars a 3\n# Creates: a1, a2, a3\n# Returns: (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# 2D matrix of variables\n@giac_several_vars m 2 3\n# Creates: m11, m12, m13, m21, m22, m23 (row-major order)\n# Returns: (m11, m12, m13, m21, m22, m23)\n\n# N-dimensional tensors\n@giac_several_vars t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n\n# Large dimensions use underscore separators\n@giac_several_vars b 2 10\n# Creates: b_1_1, b_1_2, ..., b_2_10\n\n# Unicode base names supported\n@giac_several_vars α 2\n# Creates: α1, α2\n\n# Capture return tuple for iteration\nvars = @giac_several_vars c 4\nfor v in vars\n    println(v)\nend\n\n","category":"section"},{"location":"api/commands_submodule/#Commands-Submodule","page":"Commands submodule","title":"Commands Submodule","text":"The Giac.Commands submodule provides access to all exportable GIAC commands as Julia functions.","category":"section"},{"location":"api/commands_submodule/#Usage","page":"Commands submodule","title":"Usage","text":"","category":"section"},{"location":"api/commands_submodule/#Selective-Import-(Recommended)","page":"Commands submodule","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.Commands: factor, expand, diff\n\nexpr = giac_eval(\"x^2 - 1\")\nfactor(expr)  # (x-1)*(x+1)","category":"section"},{"location":"api/commands_submodule/#Full-Import","page":"Commands submodule","title":"Full Import","text":"using Giac\nusing Giac.Commands\n\n# All ~2000+ commands available\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))","category":"section"},{"location":"api/commands_submodule/#Qualified-Access","page":"Commands submodule","title":"Qualified Access","text":"using Giac\n\nGiac.Commands.factor(giac_eval(\"x^2-1\"))","category":"section"},{"location":"api/commands_submodule/#Core-Function","page":"Commands submodule","title":"Core Function","text":"","category":"section"},{"location":"api/commands_submodule/#Conflicting-Commands","page":"Commands submodule","title":"Conflicting Commands","text":"Commands that conflict with Julia keywords, builtins, or standard library functions are NOT exported from this module. Use invoke_cmd to call them:\n\n# These conflict with Julia and are NOT exported:\n# eval, sin, cos, det, inv, sum, prod, etc.\n\n# Use invoke_cmd instead:\ninvoke_cmd(:eval, expr)\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))\ninvoke_cmd(:det, matrix)\n\nSee JULIA_CONFLICTS for the complete list of conflicting commands.","category":"section"},{"location":"api/commands_submodule/#Available-Commands","page":"Commands submodule","title":"Available Commands","text":"Use exportable_commands() to get a list of all commands available in this module:\n\ncmds = exportable_commands()\nlength(cmds)  # ~2000+\n\n","category":"section"},{"location":"api/commands_submodule/#Giac.Commands","page":"Commands submodule","title":"Giac.Commands","text":"Giac.Commands\n\nA submodule containing all exportable GIAC commands as functions.\n\nThis module provides access to ~2000+ GIAC commands while keeping the main Giac namespace clean. Commands can be accessed through three patterns:\n\nAccess Patterns\n\nQualified access (cleanest namespace):\nusing Giac\nGiac.Commands.factor(expr)\nGiac.Commands.diff(expr, x)\nSelective import (recommended for most use cases):\nusing Giac\nusing Giac.Commands: factor, expand, diff\nfactor(expr)  # Works directly\nFull import (for interactive exploration):\nusing Giac\nusing Giac.Commands\nfactor(expr)   # All ~2000+ commands available\nifactor(expr)  # Works directly\n\nConflicting Commands\n\nCommands that conflict with Julia keywords, builtins, or standard library functions (like eval, sin, det) are NOT exported from this module. Use invoke_cmd to call them:\n\nusing Giac\ninvoke_cmd(:eval, expr)  # Works for any command\ninvoke_cmd(:sin, x)      # Including conflicting ones\n\nExports\n\ninvoke_cmd: Universal command invocation function\nAll ~2000+ non-conflicting GIAC commands (runtime-generated)\n\nSee also\n\ninvoke_cmd: Call any GIAC command by name\nGiac.JULIA_CONFLICTS: Commands that conflict with Julia\nGiac.exportable_commands: List of exportable commands\n\n\n\n\n\n","category":"module"},{"location":"api/commands_submodule/#Giac.Commands.invoke_cmd","page":"Commands submodule","title":"Giac.Commands.invoke_cmd","text":"invoke_cmd(cmd::Symbol, args...) -> GiacExpr\n\nInvoke any GIAC command by name and return the result as a GiacExpr.\n\nThis is the core function for dynamic command invocation, enabling access to all 2200+ GIAC commands through a uniform interface. It works for all commands, including those that conflict with Julia builtins.\n\nArguments\n\ncmd::Symbol: GIAC command name (e.g., :factor, :sin, :integrate)\nargs...: Command arguments (GiacExpr, String, Number, or Symbol)\n\nReturns\n\nGiacExpr: Result of command execution\n\nThrows\n\nGiacError(:eval): If command is unknown or execution fails\nArgumentError: If arguments cannot be converted to GIAC format\n\nExamples\n\nusing Giac\n\n# Single argument\nexpr = giac_eval(\"x^2 - 1\")\nresult = invoke_cmd(:factor, expr)  # Returns (x-1)*(x+1)\n\n# Multiple arguments\nx = giac_eval(\"x\")\nderivative = invoke_cmd(:diff, expr, x)  # Returns 2*x\n\n# Trigonometric functions (conflicts with Base)\nresult = invoke_cmd(:sin, giac_eval(\"pi/6\"))  # Returns 1/2\n\n# Evaluation (conflicts with Base.eval)\nresult = invoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\ngiac_eval: Direct string evaluation\nGiac.search_commands: Find available commands\ngiac_help: Get raw help for a command\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"using Giac\nusing Giac.Commands: factor, expand, diff, integrate, limit, simplify, solve\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())  # if library is installed correctly it should return false\n\n# Basic evaluation through GIAC\nresult = giac_eval(\"2 + 3\")        # 5\nfactored = giac_eval(\"factor(x^2 - 1)\")  # (x-1)*(x+1)\n\n# Create symbolic variables\n@giac_var x y\n\n# Arithmetic\nprintln(x + y)   # x+y\nprintln(x * y)   # x*y\nprintln(x ^ 2)   # x^2\n\n# Evaluate expressions\nexpr = x^2 + 2*x*y + y^2\n\n# Factor polynomials\nresult = factor(expr)  # Returns (x+y)^2\n\n# Differentiate\nderivative = diff(result, x)  # Returns 2*(x+y)\n\n# Integrate\nintegral = integrate(x^2, x)  # Returns x^3/3\n\n# Calculus using Giac.Commands\nf = giac_eval(\"x^3\")\n# or using simpler syntax\nf = x^3\ndf = diff(f, x)                    # 3*x^2\nF = integrate(f, x)                # x^4/4\nf = sin(x)/x  # or using more heavy syntax giac_eval(\"sin(x)/x\")\nlim = limit(f, x, 0)  # 1\n\n# Algebra using Giac.Commands\nfactor(x^2 - 1)           # (x-1)*(x+1)\nexpand((x+1)^3)           # x^3+3*x^2+3*x+1\nsimplify((x^2-1)/(x-1))   # x+1\nsolve(x^2 - 4, x)         # list[-2,2]\n\n# Equation syntax using ~ operator (Symbolics.jl convention)\neq = x^2 - 1 ~ 0                       # Creates equation: x^2-1=0\nsolve(eq, x)                           # Solves: [-1, 1]\n\n# ~ works with mixed types\neq1 = x ~ 5                            # x=5\neq2 = 0 ~ x^2 - 4                      # 0=x^2-4\n\n# Or use invoke_cmd for any command\ninvoke_cmd(:factor, giac_eval(\"x^2 - 1\"))  # (x-1)*(x+1)\n\n# Convert to Julia types\nto_julia(giac_eval(\"42\"))    # 42::Int64\nto_julia(giac_eval(\"3/4\"))   # 3//4::Rational{Int64}\n\n","category":"section"},{"location":"developer/contributing/#Adding-Functions-to-Giac.jl","page":"Adding Functions","title":"Adding Functions to Giac.jl","text":"This guide walks you through adding new mathematical functions to Giac.jl at each performance tier.","category":"section"},{"location":"developer/contributing/#Decision-Tree","page":"Adding Functions","title":"Decision Tree","text":"Use this flowchart to determine which tier to use for your new function:\n\nflowchart TD\n    A[New Function to Add] --> B{Is it frequently used?}\n    B -->|Yes| C{C++ wrapper exists?}\n    B -->|No| D[Use Tier 3: giac_cmd]\n\n    C -->|Yes| E[Add Tier 1 Wrapper]\n    C -->|No| F{Can add C++ wrapper?}\n\n    F -->|Yes| G[Add C++ wrapper, then Tier 1]\n    F -->|No| H{1-3 arguments?}\n\n    H -->|Yes| I[Tier 2 via apply_func]\n    H -->|No| D\n\n    E --> J[Add Base extension]\n    G --> J\n    I --> K[Use giac_cmd directly]\n    D --> L[Add to Commands submodule]\n\n    style E fill:#2ecc71\n    style G fill:#2ecc71\n    style I fill:#f1c40f\n    style D fill:#e74c3c\n    style L fill:#e74c3c","category":"section"},{"location":"developer/contributing/#Step-by-Step:-Adding-a-Tier-1-Function","page":"Adding Functions","title":"Step-by-Step: Adding a Tier 1 Function","text":"Adding a Tier 1 function requires modifications to two files and provides the best performance.","category":"section"},{"location":"developer/contributing/#Prerequisites","page":"Adding Functions","title":"Prerequisites","text":"Confirm the C++ function exists in libgiac-julia-wrapper\nKnow the function's arity (number of arguments)\nKnow the GIAC command name","category":"section"},{"location":"developer/contributing/#Step-1:-Add-the-Tier-1-Wrapper","page":"Adding Functions","title":"Step 1: Add the Tier 1 Wrapper","text":"In src/wrapper.jl, add the wrapper function after the existing Tier 1 functions (around line 1038):\n\n# For unary functions (1 argument)\n_giac_sinh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sinh, expr_ptr)\n\n# For binary functions (2 arguments)\n_giac_hypot_tier1(a_ptr::Ptr{Cvoid}, b_ptr::Ptr{Cvoid}) =\n    _tier1_binary(GiacCxxBindings.giac_hypot, a_ptr, b_ptr)\n\n# For ternary functions (3 arguments)\n_giac_horner_tier1(a::Ptr{Cvoid}, b::Ptr{Cvoid}, c::Ptr{Cvoid}) =\n    _tier1_ternary(GiacCxxBindings.giac_horner, a, b, c)","category":"section"},{"location":"developer/contributing/#Step-2:-Add-the-Base-Extension","page":"Adding Functions","title":"Step 2: Add the Base Extension","text":"In src/command_utils.jl, add the user-facing function (around line 330):\n\n# For unary functions\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)\n\n# For binary functions\nBase.hypot(a::GiacExpr, b::GiacExpr)::GiacExpr =\n    _tier1_or_fallback_binary(_giac_hypot_tier1, :hypot, a, b)","category":"section"},{"location":"developer/contributing/#Step-3:-Export-the-Function-(if-needed)","page":"Adding Functions","title":"Step 3: Export the Function (if needed)","text":"If extending a Base function, no export is needed. For new functions, add to exports in src/Giac.jl:\n\nexport my_new_function","category":"section"},{"location":"developer/contributing/#Step-4:-Add-Tests","page":"Adding Functions","title":"Step 4: Add Tests","text":"In test/test_commands.jl:\n\n@testset \"sinh function\" begin\n    x = giac_eval(\"x\")\n\n    # Test symbolic evaluation\n    result = sinh(x)\n    @test result isa GiacExpr\n    @test string(result) == \"sinh(x)\"\n\n    # Test numeric evaluation\n    result_num = sinh(giac_eval(\"0\"))\n    @test to_julia(result_num) == 0\nend","category":"section"},{"location":"developer/contributing/#Step-5:-Add-Documentation","page":"Adding Functions","title":"Step 5: Add Documentation","text":"Add a docstring to your function:\n\n\"\"\"\n    sinh(expr::GiacExpr) -> GiacExpr\n\nCompute the hyperbolic sine of a GIAC expression.\n\n# Examples\n\njldoctest julia> using Giac\n\njulia> x = giac_eval(\"x\") x\n\njulia> sinh(x) sinh(x)\n\n\"\"\"\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)","category":"section"},{"location":"developer/contributing/#Step-by-Step:-Adding-a-Tier-2/3-Function","page":"Adding Functions","title":"Step-by-Step: Adding a Tier 2/3 Function","text":"For functions that don't need maximum performance or don't have C++ wrappers.","category":"section"},{"location":"developer/contributing/#Option-A:-Using-giac_cmd-Directly","page":"Adding Functions","title":"Option A: Using giac_cmd Directly","text":"For occasional use, simply call giac_cmd:\n\n# In your code\nresult = giac_cmd(:my_function, arg1, arg2)","category":"section"},{"location":"developer/contributing/#Option-B:-Adding-to-Commands-Submodule","page":"Adding Functions","title":"Option B: Adding to Commands Submodule","text":"For functions you want accessible via Giac.Commands:\n\nIn src/Commands.jl, the functions are auto-generated from VALID_COMMANDS. To add a custom function:\n\n# In src/Commands.jl or command_utils.jl\n\"\"\"\n    my_special_function(expr) -> GiacExpr\n\nCompute something special.\n\"\"\"\nfunction my_special_function(expr::GiacExpr)::GiacExpr\n    return giac_cmd(:my_special_function, expr)\nend\n\nexport my_special_function","category":"section"},{"location":"developer/contributing/#Option-C:-Creating-a-Convenience-Wrapper","page":"Adding Functions","title":"Option C: Creating a Convenience Wrapper","text":"For better ergonomics, create a dedicated function:\n\n# In src/api.jl or a new file\n\"\"\"\n    partial_fractions(expr, var) -> GiacExpr\n\nCompute partial fraction decomposition of `expr` with respect to `var`.\n\"\"\"\nfunction partial_fractions(expr::GiacExpr, var::GiacExpr)::GiacExpr\n    return giac_cmd(:partfrac, expr, var)\nend\n\nexport partial_fractions","category":"section"},{"location":"developer/contributing/#Extending-Base-Functions","page":"Adding Functions","title":"Extending Base Functions","text":"When extending Julia's Base module functions, follow these guidelines:","category":"section"},{"location":"developer/contributing/#Pattern-for-GiacExpr","page":"Adding Functions","title":"Pattern for GiacExpr","text":"# Correct: Use _tier1_or_fallback when Tier 1 exists\nBase.sin(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sin_tier1, :sin, expr)\n\n# Correct: Use giac_cmd when no Tier 1\nBase.sinc(expr::GiacExpr)::GiacExpr =\n    giac_cmd(:sinc, expr)","category":"section"},{"location":"developer/contributing/#Avoiding-Type-Piracy","page":"Adding Functions","title":"Avoiding Type Piracy","text":"Only extend Base functions for types you own (GiacExpr, GiacMatrix):\n\n# Good: Extending for our type\nBase.sin(expr::GiacExpr) = ...\n\n# Bad: This would be type piracy\nBase.sin(x::Float64) = ...  # Don't do this!","category":"section"},{"location":"developer/contributing/#Method-Signatures","page":"Adding Functions","title":"Method Signatures","text":"Match Julia's expected signatures where possible:\n\n# Good: Matches Base.diff signature pattern\nBase.diff(f::GiacExpr, x::GiacExpr) = giac_diff(f, x)\n\n# For multiple dispatch\nBase.diff(f::GiacExpr, x::GiacExpr, n::Integer) = giac_diff(f, x, n)","category":"section"},{"location":"developer/contributing/#Complete-Example:-Adding-sinh","page":"Adding Functions","title":"Complete Example: Adding sinh","text":"Here's a complete example of adding the hyperbolic sine function.","category":"section"},{"location":"developer/contributing/#1.-Check-C-Availability","page":"Adding Functions","title":"1. Check C++ Availability","text":"First, verify giac_sinh exists in GiacCxxBindings:\n\n# In Julia REPL\nusing Giac\nhasmethod(Giac.GiacCxxBindings.giac_sinh, Tuple{Any})","category":"section"},{"location":"developer/contributing/#2.-Add-Tier-1-Wrapper-(wrapper.jl)","page":"Adding Functions","title":"2. Add Tier 1 Wrapper (wrapper.jl)","text":"# Add after line ~1037 in wrapper.jl\n\n# Hyperbolic trigonometry (Tier 1)\n_giac_sinh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sinh, expr_ptr)\n_giac_cosh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_cosh, expr_ptr)\n_giac_tanh_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_tanh, expr_ptr)","category":"section"},{"location":"developer/contributing/#3.-Add-Base-Extension-(command_utils.jl)","page":"Adding Functions","title":"3. Add Base Extension (command_utils.jl)","text":"# Add after line ~330 in command_utils.jl\n\n# Hyperbolic functions\n\"\"\"\n    sinh(expr::GiacExpr) -> GiacExpr\n\nCompute the hyperbolic sine of a GIAC expression.\n\n# Examples\n\njldoctest julia> using Giac\n\njulia> sinh(giac_eval(\"0\")) 0\n\n\"\"\"\nBase.sinh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sinh_tier1, :sinh, expr)\n\nBase.cosh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_cosh_tier1, :cosh, expr)\n\nBase.tanh(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_tanh_tier1, :tanh, expr)","category":"section"},{"location":"developer/contributing/#4.-Add-Tests-(test/test_commands.jl)","page":"Adding Functions","title":"4. Add Tests (test/test_commands.jl)","text":"@testset \"Hyperbolic functions\" begin\n    x = giac_eval(\"x\")\n\n    @testset \"sinh\" begin\n        @test sinh(x) isa GiacExpr\n        @test string(sinh(x)) == \"sinh(x)\"\n        @test to_julia(sinh(giac_eval(\"0\"))) == 0\n    end\n\n    @testset \"cosh\" begin\n        @test cosh(x) isa GiacExpr\n        @test to_julia(cosh(giac_eval(\"0\"))) == 1\n    end\n\n    @testset \"tanh\" begin\n        @test tanh(x) isa GiacExpr\n        @test to_julia(tanh(giac_eval(\"0\"))) == 0\n    end\nend","category":"section"},{"location":"developer/contributing/#5.-Run-Tests","page":"Adding Functions","title":"5. Run Tests","text":"julia --project -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"developer/contributing/#Checklist-for-Adding-Functions","page":"Adding Functions","title":"Checklist for Adding Functions","text":"[ ] Determine the appropriate tier (1, 2, or 3)\n[ ] If Tier 1: Add wrapper in wrapper.jl\n[ ] Add user-facing function in command_utils.jl or api.jl\n[ ] Add docstring with examples\n[ ] Add tests in test/\n[ ] Run test suite\n[ ] Update documentation if needed","category":"section"},{"location":"developer/contributing/#See-Also","page":"Adding Functions","title":"See Also","text":"Performance Tiers - Detailed tier system explanation\nPackage Architecture - Where files are located\nMemory Management - Important for wrapped types\n\n","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help","page":"Command discovery and help","title":"Command Discovery and Help","text":"","category":"section"},{"location":"command_discovery_help/#Command-Discovery","page":"Command discovery and help","title":"Command Discovery","text":"using Giac\n\n# Search for commands by prefix\nsearch_commands(\"sin\")        # [\"sin\", \"sinc\", \"sinh\", ...]\n\n# Search with regex\nsearch_commands(r\"^a.*n$\")    # Commands starting with 'a' and ending with 'n'\n\n# Search by description (find commands by what they do)\nsearch_commands_by_description(\"polynomial\")  # Commands related to polynomials\nsearch_commands_by_description(\"matrix\", n=5) # Limit to 5 results\n\n# Get command metadata\ninfo = command_info(:factor)\ninfo.name                     # \"factor\"\ninfo.category                 # :algebra\n\n# List available categories\nlist_categories()             # [:trigonometry, :calculus, :algebra, ...]\n\n# Get commands in a category\ncommands_in_category(:trigonometry)  # [\"sin\", \"cos\", \"tan\", \"asin\", ...]\ncommands_in_category(:calculus)      # [\"diff\", \"integrate\", \"limit\", ...]\ncommands_in_category(:algebra)       # [\"factor\", \"expand\", \"simplify\", ...]","category":"section"},{"location":"command_discovery_help/#Help-System","page":"Command discovery and help","title":"Help System","text":"Use Julia's native help system to get documentation for GIAC commands:\n\nusing Giac\nusing Giac.Commands: factor, sin\n\n# Use Julia's native help system (recommended)\n?factor\n#   factor(expr::GiacInput, args...)\n#\n#   GIAC command: `factor`\n#\n#   Factorizes a polynomial.\n#\n#   # Related Commands\n#   - `ifactor`\n#   - `partfrac`\n#   - `normal`\n#\n#   # Examples (GIAC syntax)\n#   factor(x^4-1)\n#   factor(x^4-4,sqrt(2))\n\n# Or use @doc macro\n@doc factor\n\n# For programmatic access to raw help text\nhelp_text = giac_help(:factor)\n\n# List all available commands\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))  # 2215\n\n# Get help count\nprintln(\"Help entries: \", help_count())  # 2215\n\nnote: Internal help() Function\nThe help(:cmd) function is no longer exported. Use ?cmd for interactive help or giac_help(:cmd) for programmatic access to raw help text.","category":"section"},{"location":"command_discovery_help/#Command-Suggestions","page":"Command discovery and help","title":"Command Suggestions","text":"When you mistype a command, Giac.jl automatically suggests similar commands:\n\nusing Giac\n\n# Get suggestions programmatically\nsuggest_commands(:factr)        # [\"factor\", \"cfactor\", \"ifactor\", ...]\nsuggest_commands(:integrat)     # [\"integrate\", \"integral\", ...]\n\n# Configure number of suggestions\nget_suggestion_count()          # 4 (default)\nset_suggestion_count(6)         # Show more suggestions\n\n# Get suggestions with edit distances\nGiac.suggest_commands_with_distances(:factr)\n# [(\"factor\", 1), (\"cfactor\", 2), (\"ifactor\", 2), ...]\n\nThe suggestion system uses Levenshtein edit distance with an adaptive threshold based on input length.","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help-2","page":"Command discovery and help","title":"Command Discovery & Help","text":"Function Description\n?cmd View help in REPL (after importing cmd from Giac.Commands)\ngiac_help(cmd) Get raw help text as a string\nlist_commands() List all available GIAC commands\nhelp_count() Number of commands in help database\nsearch_commands(pattern) Search commands by prefix or regex\ncommand_info(cmd) Get CommandInfo with name, category, aliases\nlist_categories() List all command categories\ncommands_in_category(cat) List commands in a category\nsuggest_commands(input) Suggest similar commands for mistyped input\nset_suggestion_count(n) Set number of suggestions (default: 4)\nget_suggestion_count() Get current suggestion count\nsearch_commands_by_description(query; n=20) Search commands by help text keywords","category":"section"},{"location":"command_discovery_help/#Command-Access","page":"Command discovery and help","title":"Command Access","text":"Function Description\navailable_commands() List all commands starting with ASCII letters\nexportable_commands() List commands safe to export (no Julia conflicts)\nis_valid_command(name) Check if a command name is valid\nconflict_reason(cmd) Get why a command conflicts (:keyword, :builtin, etc.)\nJULIA_CONFLICTS Set of commands that conflict with Julia\nreset_conflict_warnings!() Reset conflict warning tracker (for testing)","category":"section"},{"location":"command_discovery_help/#Types","page":"Command discovery and help","title":"Types","text":"Type Description\nGiacExpr Symbolic expression type\nGiacMatrix Symbolic matrix type\nGiacContext Evaluation context\nHelpResult Parsed help information with .command, .description, .related, .examples fields\nCommandInfo Command metadata with .name, .category, .aliases, .doc fields","category":"section"},{"location":"command_discovery_help/#Calculus","page":"Command discovery and help","title":"Calculus","text":"Use Giac.Commands or invoke_cmd:\n\nFunction Description\nGiac.Commands.diff(f, x) Derivative of f with respect to x\nGiac.Commands.integrate(f, x) Indefinite integral\ninvoke_cmd(:diff, f, x, n) nth derivative of f with respect to x\ninvoke_cmd(:integrate, f, x, a, b) Definite integral from a to b\ninvoke_cmd(:limit, f, x, point) Limit as x approaches point\ninvoke_cmd(:series, f, x, point, order) Taylor series expansion","category":"section"},{"location":"command_discovery_help/#Algebra","page":"Command discovery and help","title":"Algebra","text":"Use Giac.Commands or invoke_cmd:\n\nFunction Description\nGiac.Commands.factor(expr) Factor polynomial\nGiac.Commands.expand(expr) Expand expression\nGiac.Commands.simplify(expr) Simplify expression\nGiac.Commands.solve(expr, x) Solve equation for x\nGiac.Commands.gcd(a, b) Greatest common divisor\n\n","category":"section"},{"location":"developer/tier-system/#Performance-Tier-System","page":"Performance Tiers","title":"Performance Tier System","text":"Giac.jl uses a three-tier performance system to balance execution speed with flexibility. Understanding this system is essential for contributing efficiently.","category":"section"},{"location":"developer/tier-system/#Overview","page":"Performance Tiers","title":"Overview","text":"graph TB\n    subgraph Performance_Pyramid[\"Performance Pyramid\"]\n        A[\"Tier 1: Direct C++ (~1-10μs)\"]\n        B[\"Tier 2: Generic Dispatch (~10-100μs)\"]\n        C[\"Tier 3: String Eval (~100μs-1ms)\"]\n    end\n\n    A --> B\n    B --> C\n\n    style A fill:#2ecc71\n    style B fill:#f1c40f\n    style C fill:#e74c3c\n\nTier Mechanism Performance Use Case\nTier 1 Direct C++ function call Fastest (~1-10μs) Frequently-used mathematical functions\nTier 2 Generic apply_func dispatch Medium (~10-100μs) Functions with C++ wrappers, 1-3 args\nTier 3 String concatenation & eval Slowest (~100μs-1ms) All 2200+ GIAC commands (fallback)","category":"section"},{"location":"developer/tier-system/#Tier-1:-Direct-C-Wrappers","page":"Performance Tiers","title":"Tier 1: Direct C++ Wrappers","text":"Tier 1 provides the highest performance by calling C++ functions directly through CxxWrap bindings, with no name lookup or string processing.","category":"section"},{"location":"developer/tier-system/#How-It-Works","page":"Performance Tiers","title":"How It Works","text":"# In wrapper.jl\n_giac_sin_tier1(expr_ptr::Ptr{Cvoid}) =\n    _tier1_unary(GiacCxxBindings.giac_sin, expr_ptr)\n\nThe _tier1_unary helper:\n\nConverts the pointer to a GIAC gen object\nCalls the C++ function directly\nConverts the result back to a pointer","category":"section"},{"location":"developer/tier-system/#Helper-Functions","page":"Performance Tiers","title":"Helper Functions","text":"Located in wrapper.jl:\n\nHelper Arity Lines\n_tier1_unary(func, ptr) 1 argument 946-959\n_tier1_binary(func, a, b) 2 arguments 961-976\n_tier1_ternary(func, a, b, c) 3 arguments 978-995","category":"section"},{"location":"developer/tier-system/#Complete-Tier-1-Function-List","page":"Performance Tiers","title":"Complete Tier 1 Function List","text":"Trigonometric (6 functions):\n\n_giac_sin_tier1, _giac_cos_tier1, _giac_tan_tier1\n_giac_asin_tier1, _giac_acos_tier1, _giac_atan_tier1\n\nExponential/Logarithmic (4 functions):\n\n_giac_exp_tier1, _giac_ln_tier1, _giac_log10_tier1, _giac_sqrt_tier1\n\nArithmetic (4 functions):\n\n_giac_abs_tier1, _giac_sign_tier1, _giac_floor_tier1, _giac_ceil_tier1\n\nComplex Numbers (3 functions):\n\n_giac_re_tier1, _giac_im_tier1, _giac_conj_tier1\n\nAlgebraic (2 functions):\n\n_giac_normal_tier1, _giac_evalf_tier1\n\nCalculus (6 functions):\n\n_giac_diff_tier1 (binary), _giac_integrate_tier1 (binary)\n_giac_subst_tier1 (ternary), _giac_solve_tier1 (binary)\n_giac_limit_tier1 (ternary), _giac_series_tier1 (ternary)\n\nBinary Operations (3 functions):\n\n_giac_gcd_tier1, _giac_lcm_tier1, _giac_pow_tier1","category":"section"},{"location":"developer/tier-system/#Tier-2:-Generic-C-Dispatch","page":"Performance Tiers","title":"Tier 2: Generic C++ Dispatch","text":"Tier 2 uses C++ generic dispatch functions (apply_func, apply_func2, apply_func3) to call GIAC functions by name with moderate overhead.","category":"section"},{"location":"developer/tier-system/#How-It-Works-2","page":"Performance Tiers","title":"How It Works","text":"# In wrapper.jl (lines 905-938)\nfunction _apply_func_generic(name::String, args::Vector{String})::Ptr{Cvoid}\n    gen_args = [GiacCxxBindings.giac_eval(arg) for arg in args]\n\n    result_gen = if length(gen_args) == 1\n        GiacCxxBindings.apply_func(name, gen_args[1])\n    elseif length(gen_args) == 2\n        GiacCxxBindings.apply_func2(name, gen_args[1], gen_args[2])\n    elseif length(gen_args) == 3\n        GiacCxxBindings.apply_func3(name, gen_args[1], gen_args[2], gen_args[3])\n    else\n        # Fall back to Tier 3 for 0 or >3 args\n        return _giac_eval_string(cmd_string, C_NULL)\n    end\n\n    return _make_stub_ptr(GiacCxxBindings.to_string(result_gen))\nend","category":"section"},{"location":"developer/tier-system/#When-Tier-2-Is-Used","page":"Performance Tiers","title":"When Tier 2 Is Used","text":"Functions with 1-3 arguments that don't have Tier 1 wrappers\nAutomatic fallback when Tier 1 fails\nWhen giac_cmd is called for supported arities","category":"section"},{"location":"developer/tier-system/#Tier-3:-String-Evaluation","page":"Performance Tiers","title":"Tier 3: String Evaluation","text":"Tier 3 is the universal fallback that works for all 2200+ GIAC commands by building a command string and evaluating it.","category":"section"},{"location":"developer/tier-system/#How-It-Works-3","page":"Performance Tiers","title":"How It Works","text":"flowchart LR\n    A[\"giac_cmd(:factor, x)\"] --> B[\"_arg_to_giac_string(x)\"]\n    B --> C[\"_build_command_string\"]\n    C --> D[\"'factor(x)'\"]\n    D --> E[\"giac_eval(cmd_string)\"]\n    E --> F[\"GiacExpr result\"]","category":"section"},{"location":"developer/tier-system/#The-Command-Flow","page":"Performance Tiers","title":"The Command Flow","text":"Located in command_utils.jl (lines 109-143):\n\nfunction giac_cmd(cmd::Symbol, args...)::GiacExpr\n    cmd_str = string(cmd)\n\n    # 1. Validate command exists\n    if !isempty(VALID_COMMANDS) && cmd_str ∉ VALID_COMMANDS\n        throw(GiacError(\"Unknown command: $cmd_str\", :eval))\n    end\n\n    # 2. Convert arguments to strings\n    arg_strings = [_arg_to_giac_string(arg) for arg in args]\n\n    # 3. Build command string: \"factor(x^2-1)\"\n    cmd_string = _build_command_string(cmd_str, arg_strings)\n\n    # 4. Evaluate with thread safety\n    return with_giac_lock() do\n        giac_eval(cmd_string)\n    end\nend","category":"section"},{"location":"developer/tier-system/#Argument-Conversion","page":"Performance Tiers","title":"Argument Conversion","text":"The _arg_to_giac_string function (lines 20-43) handles various types:\n\nType Conversion\nGiacExpr string(expr)\nString Pass through\nNumber string(n)\nSymbol string(sym)\nAbstractVector \"[elem1,elem2,...]\"","category":"section"},{"location":"developer/tier-system/#The-_tier1_or_fallback-Pattern","page":"Performance Tiers","title":"The _tier1_or_fallback Pattern","text":"This pattern elegantly bridges Tier 1 and Tier 3, trying the fast path first and falling back if needed.","category":"section"},{"location":"developer/tier-system/#Implementation","page":"Performance Tiers","title":"Implementation","text":"Located in command_utils.jl (lines 152-180):\n\nfunction _tier1_or_fallback(tier1_func::Function, cmd::Symbol, expr::GiacExpr)::GiacExpr\n    result_ptr = tier1_func(expr.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)  # Tier 1 succeeded\n    end\n    return giac_cmd(cmd, expr)  # Fall back to Tier 3\nend\n\nfunction _tier1_or_fallback_binary(tier1_func, cmd, a::GiacExpr, b::GiacExpr)\n    result_ptr = tier1_func(a.ptr, b.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)\n    end\n    return giac_cmd(cmd, a, b)\nend\n\nfunction _tier1_or_fallback_ternary(tier1_func, cmd, a, b, c)\n    result_ptr = tier1_func(a.ptr, b.ptr, c.ptr)\n    if result_ptr != C_NULL\n        return GiacExpr(result_ptr)\n    end\n    return giac_cmd(cmd, a, b, c)\nend","category":"section"},{"location":"developer/tier-system/#Usage-in-Base-Extensions","page":"Performance Tiers","title":"Usage in Base Extensions","text":"# In command_utils.jl - extending Julia's Base functions\nBase.sin(expr::GiacExpr)::GiacExpr =\n    _tier1_or_fallback(_giac_sin_tier1, :sin, expr)\n\nBase.gcd(a::GiacExpr, b::GiacExpr)::GiacExpr =\n    _tier1_or_fallback_binary(_giac_gcd_tier1, :gcd, a, b)","category":"section"},{"location":"developer/tier-system/#Performance-Implications","page":"Performance Tiers","title":"Performance Implications","text":"","category":"section"},{"location":"developer/tier-system/#Choosing-the-Right-Tier","page":"Performance Tiers","title":"Choosing the Right Tier","text":"flowchart TD\n    A[New Function] --> B{Frequently used?}\n    B -->|Yes| C{C++ wrapper exists?}\n    B -->|No| D[Use Tier 3: giac_cmd]\n    C -->|Yes| E[Add Tier 1 wrapper]\n    C -->|No| F{1-3 arguments?}\n    F -->|Yes| G[Tier 2 automatic]\n    F -->|No| D","category":"section"},{"location":"developer/tier-system/#Performance-Comparison","page":"Performance Tiers","title":"Performance Comparison","text":"Operation Tier 1 Tier 2 Tier 3\nSimple unary (sin, cos) ~2μs ~20μs ~200μs\nBinary (gcd, pow) ~3μs ~25μs ~250μs\nComplex expression ~5μs ~50μs ~500μs\n\nNote: Actual performance varies by system and expression complexity","category":"section"},{"location":"developer/tier-system/#When-Tier-Fallback-Occurs","page":"Performance Tiers","title":"When Tier Fallback Occurs","text":"Tier 1 falls back to Tier 3 when:\n\nThe C++ function returns an error\nMemory allocation fails\nThe library is in stub mode (testing)\n\nTier 2 falls back to Tier 3 when:\n\nMore than 3 arguments\nGeneric dispatch fails","category":"section"},{"location":"developer/tier-system/#Determining-Which-Tier-Is-Used","page":"Performance Tiers","title":"Determining Which Tier Is Used","text":"To predict which tier handles a function call:\n\nCheck if it's a Base extension (sin, cos, sqrt, etc.):\nIf Tier 1 function exists → Tier 1 with fallback\nOtherwise → Tier 3\nUsing giac_cmd directly:\n1-3 args with C++ support → Tier 2\nOtherwise → Tier 3\nUsing Commands submodule (using Giac.Commands: factor):\nAlways Tier 3 (goes through invoke_cmd)","category":"section"},{"location":"developer/tier-system/#See-Also","page":"Performance Tiers","title":"See Also","text":"Adding Functions - How to add functions at each tier\nPackage Architecture - Overall package structure\n\n","category":"section"},{"location":"#Giac.jl","page":"Home","title":"Giac.jl","text":"A Julia wrapper for the GIAC computer algebra system.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Dynamic Command Invocation: Access all 2200+ GIAC commands via invoke_cmd(:cmd, args...)\nExpression Evaluation: Parse and evaluate mathematical expressions\nArithmetic Operations: +, -, *, /, ^, unary negation, equality\nCalculus: Differentiation, integration, limits, and series expansion\nAlgebra: Factorization, expansion, simplification, equation solving and GCD\nLinear Algebra: Symbolic matrices with determinant, inverse, trace, transpose operations\nCommand Discovery: Search commands, browse by category, built-in help via ?cmd\nCommands Submodule: All ~2000+ commands available via Giac.Commands for clean namespace\nTempApi Submodule: Simplified function names (diff, factor, etc.) via Giac.TempApi\nMethod Syntax: Call commands as methods: expr.factor(), expr.diff(x)\nBase Extensions: Use sin(expr), cos(expr), exp(expr) with GiacExpr\nType Conversion: Convert results to Julia native types (Int64, Float64, Rational)\nLaTeX Support: Automatic LaTeX rendering in Pluto notebooks\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl\nTables.jl Compatibility: Convert GiacMatrix and command help to DataFrames, CSV export\nVariable Substitution: Symbolics.jl-compatible substitute(expr, Dict(var => value)) interface","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Giac\")  # when registered to Julia General Registry\n\nFor full GIAC integration with C++ library, see the Installation Guide.","category":"section"},{"location":"#Command-Access","page":"Home","title":"Command Access","text":"GIAC commands are available through multiple access patterns:","category":"section"},{"location":"#1.-Selective-Import-from-Commands-Submodule-(Recommanded)","page":"Home","title":"1. Selective Import from Commands Submodule (Recommanded)","text":"using Giac\nusing Giac.Commands: factor, expand, ifactor\n\n@giac_var\nfactor(x^2 - 1)","category":"section"},{"location":"#2.-Full-Import-(Interactive-Use)","page":"Home","title":"2. Full Import (Interactive Use)","text":"using Giac\nusing Giac.Commands\n\n@giac_var x\nfactor(x^2 - 1)\nifactor(120)  # All ~2000+ commands available","category":"section"},{"location":"#3.-Universal-Command-Invocation","page":"Home","title":"3. Universal Command Invocation","text":"using Giac\n\n# Works for ALL commands, including those conflicting with Julia\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))","category":"section"},{"location":"#Modules","page":"Home","title":"Modules","text":"Core API: Types, evaluation, and main functions\nCommands: All GIAC commands as functions\nTempApi: Convenience functions with simple names","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"install.md\", \"api/core.md\", \"api/commands.md\", \"api/tempapi.md\"]","category":"section"},{"location":"#Related-Projects","page":"Home","title":"Related Projects","text":"GIAC - The underlying computer algebra system\nlibgiac-julia-wrapper - CxxWrap bindings for GIAC\nCxxWrap.jl - C++ wrapper generator for Julia\n\n","category":"section"},{"location":"tables/#Tables.jl-Compatibility","page":"Tables.jl Compatibility","title":"Tables.jl Compatibility","text":"Giac.jl provides full Tables.jl compatibility, enabling seamless integration with the Julia data ecosystem including DataFrames.jl and CSV.jl.","category":"section"},{"location":"tables/#GiacMatrix-to-DataFrame","page":"Tables.jl Compatibility","title":"GiacMatrix to DataFrame","text":"Convert symbolic matrices to DataFrames for analysis and export:\n\nusing Giac\nusing DataFrames\n\n# Create a numeric matrix\nm = GiacMatrix([1 2 3; 4 5 6])\n\n# Convert to DataFrame\ndf = DataFrame(m)\n# 2×3 DataFrame\n#  Row │ col1    col2    col3\n#      │ String  String  String\n# ─────┼────────────────────────\n#    1 │ 1       2       3\n#    2 │ 4       5       6","category":"section"},{"location":"tables/#Symbolic-Matrices","page":"Tables.jl Compatibility","title":"Symbolic Matrices","text":"Symbolic values are converted to strings:\n\n@giac_var x y\nm = GiacMatrix([x y; x+1 y+1])\n\ndf = DataFrame(m)\n# 2×2 DataFrame\n#  Row │ col1    col2\n#      │ String  String\n# ─────┼────────────────\n#    1 │ x       y\n#    2 │ x+1     y+1","category":"section"},{"location":"tables/#Row-and-Column-Access","page":"Tables.jl Compatibility","title":"Row and Column Access","text":"Access data using the Tables.jl interface:\n\n# Row iteration\nfor row in Tables.rows(m)\n    println(Tables.getcolumn(row, :col1))\nend\n\n# Column access\ncols = Tables.columns(m)\nfirst_col = Tables.getcolumn(cols, :col1)  # Vector of values","category":"section"},{"location":"tables/#CSV-Export","page":"Tables.jl Compatibility","title":"CSV Export","text":"Export matrices directly to CSV files:\n\nusing CSV\n\nm = GiacMatrix(giac_eval(\"[[1,2,3],[4,5,6]]\"))\nCSV.write(\"matrix.csv\", m)","category":"section"},{"location":"tables/#Command-Help-as-Tables","page":"Tables.jl Compatibility","title":"Command Help as Tables","text":"","category":"section"},{"location":"tables/#Single-Command-Help","page":"Tables.jl Compatibility","title":"Single Command Help","text":"Convert help information for a single command to a table:\n\nusing Giac\nusing DataFrames\n\nhr = Giac.help(:factor)  # Internal function for programmatic access\ndf = DataFrame(hr)\n# 1×5 DataFrame\n#  Row │ command  category  description  related           examples\n#      │ String   String    String       String            String\n# ─────┼──────────────────────────────────────────────────────────────\n#    1 │ factor   algebra   ...          ifactor, partfrac ...\n\ntip: Interactive Help\nFor interactive help, use Julia's native help system:using Giac.Commands: factor\n?factor  # Shows GIAC documentation in REPL","category":"section"},{"location":"tables/#All-Commands-Table","page":"Tables.jl Compatibility","title":"All Commands Table","text":"Get a table of all ~2000 GIAC commands with documentation:\n\nusing DataFrames\n\nct = commands_table()\ndf = DataFrame(ct)\n# ~2000×5 DataFrame with columns:\n# - command: Command name\n# - category: Category (algebra, calculus, etc.)\n# - description: Command description\n# - related: Related commands (comma-separated)\n# - examples: Usage examples (semicolon-separated)","category":"section"},{"location":"tables/#Filtering-Commands","page":"Tables.jl Compatibility","title":"Filtering Commands","text":"Use DataFrame operations to filter and search commands:\n\nusing DataFrames\n\ndf = DataFrame(commands_table())\n\n# Find all algebra commands\nalgebra_cmds = filter(row -> row.category == \"algebra\", df)\n\n# Search by description\nfactor_cmds = filter(row -> occursin(\"factor\", lowercase(row.description)), df)","category":"section"},{"location":"tables/#Caching","page":"Tables.jl Compatibility","title":"Caching","text":"The commands table is cached for performance. To refresh:\n\nclear_commands_cache!()\nct = commands_table()  # Fresh collection","category":"section"},{"location":"tables/#Table-of-Functions","page":"Tables.jl Compatibility","title":"Table of Functions","text":"Function Description\nTables.istable(GiacMatrix) Returns true\nTables.rows(m::GiacMatrix) Row iterator\nTables.columns(m::GiacMatrix) Column accessor\nTables.schema(m::GiacMatrix) Column names and types\nTables.istable(HelpResult) Returns true\nTables.rows(hr::HelpResult) Single-row iterator\ncommands_table() All commands as table\nclear_commands_cache!() Clear commands cache","category":"section"},{"location":"tables/#API-Reference","page":"Tables.jl Compatibility","title":"API Reference","text":"","category":"section"},{"location":"tables/#Giac.commands_table","page":"Tables.jl Compatibility","title":"Giac.commands_table","text":"commands_table() -> CommandsTable\n\nReturn a Tables.jl-compatible collection of all GIAC command help.\n\nResults are cached after the first call for performance. Use clear_commands_cache!() to invalidate the cache.\n\nExample\n\nusing DataFrames\n\n# Get all commands as DataFrame\ndf = DataFrame(commands_table())\n\n# Filter by category\nalgebra_cmds = filter(row -> row.category == \"algebra\", df)\n\n# Export to CSV\nusing CSV\nCSV.write(\"giac_commands.csv\", commands_table())\n\nSee also\n\nclear_commands_cache!: Invalidate the cache\ngiac_help: Get raw help for a single command\n\n\n\n\n\n","category":"function"},{"location":"tables/#Giac.clear_commands_cache!","page":"Tables.jl Compatibility","title":"Giac.clear_commands_cache!","text":"clear_commands_cache!()\n\nClear the cached CommandsTable, forcing re-collection on next commands_table() call.\n\nExample\n\nct1 = commands_table()  # Collects all commands\nclear_commands_cache!()\nct2 = commands_table()  # Re-collects all commands\n\nSee also\n\ncommands_table: Get the commands table\n\n\n\n\n\n","category":"function"},{"location":"tables/#Giac.CommandsTable","page":"Tables.jl Compatibility","title":"Giac.CommandsTable","text":"CommandsTable\n\nCached collection of all GIAC command help as Tables.jl source.\n\nCreated by commands_table(). Contains pre-collected help information for all available GIAC commands.\n\nExample\n\nusing DataFrames\n\nct = commands_table()\ndf = DataFrame(ct)\nfilter(row -> row.category == \"algebra\", df)\n\n\n\n\n\n","category":"type"}]
}
