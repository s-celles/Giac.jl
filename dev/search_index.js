var documenterSearchIndex = {"docs":
[{"location":"api/core/#Core-API","page":"Core API","title":"Core API","text":"The main Giac module provides core types and functions for symbolic computation.","category":"section"},{"location":"api/core/#Types","page":"Core API","title":"Types","text":"","category":"section"},{"location":"api/core/#Expression-Evaluation","page":"Core API","title":"Expression Evaluation","text":"","category":"section"},{"location":"api/core/#Symbolic-Variables","page":"Core API","title":"Symbolic Variables","text":"","category":"section"},{"location":"api/core/#Calculus-Operations","page":"Core API","title":"Calculus Operations","text":"","category":"section"},{"location":"api/core/#Algebraic-Operations","page":"Core API","title":"Algebraic Operations","text":"","category":"section"},{"location":"api/core/#Command-Discovery","page":"Core API","title":"Command Discovery","text":"","category":"section"},{"location":"api/core/#Command-Suggestions","page":"Core API","title":"Command Suggestions","text":"","category":"section"},{"location":"api/core/#Namespace-Management","page":"Core API","title":"Namespace Management","text":"","category":"section"},{"location":"api/core/#Conversion-Functions","page":"Core API","title":"Conversion Functions","text":"","category":"section"},{"location":"api/core/#Utility-Functions","page":"Core API","title":"Utility Functions","text":"","category":"section"},{"location":"api/core/#Giac","page":"Core API","title":"Giac","text":"Giac\n\nA Julia wrapper for the GIAC computer algebra system.\n\nProvides symbolic expression evaluation, calculus operations, polynomial manipulation, and linear algebra with a Julia-native API.\n\nCore Exports\n\nGiacExpr: Symbolic expression type\nGiacContext: Evaluation context\nGiacMatrix: Symbolic matrix type\nGiacError: Exception type for GIAC errors\ngiac_eval: Evaluate expression strings\n@giac_var: Create symbolic variables from Julia symbols\nto_julia: Convert GiacExpr to Julia types\ninvoke_cmd: Universal command invocation (works for ALL commands)\ngiac_diff, giac_integrate, giac_limit, giac_series: Calculus\ngiac_factor, giac_expand, giac_simplify, giac_solve, giac_gcd: Algebra\n\nCommand Access\n\nGIAC commands are available through the Giac.Commands submodule:\n\nusing Giac\n\n# Use invoke_cmd for any command (always available)\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))  # Works for conflicting commands too\n\n# Import commands selectively (recommended)\nusing Giac.Commands: factor, expand, diff\nfactor(giac_eval(\"x^2-1\"))\n\n# Or import all ~2000+ commands\nusing Giac.Commands\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))\n\nQuick Start\n\nusing Giac\n\n# Declare symbolic variables with @giac_var macro\n@giac_var x y\n\n# Build and manipulate expressions\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\nresult = giac_factor(expr)   # (x+y)^2\n\n# Or use string-based evaluation directly\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\nSee also\n\nGiac.Commands: Submodule with all exportable commands\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"module"},{"location":"api/core/#Giac.GiacExpr","page":"Core API","title":"Giac.GiacExpr","text":"GiacExpr\n\nRepresents a symbolic mathematical expression from GIAC.\n\nWraps a pointer to a C++ giac::gen object. Memory is managed automatically via Julia's garbage collector and finalizers.\n\nExample\n\nexpr = giac_eval(\"x^2 + 1\")\nprintln(expr)  # x^2+1\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacContext","page":"Core API","title":"Giac.GiacContext","text":"GiacContext\n\nRepresents a GIAC evaluation context.\n\nManages configuration settings, variable bindings, and computation state. Thread-safe via internal locking.\n\nExample\n\nctx = GiacContext()\nresult = giac_eval(\"x + 1\", ctx)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacMatrix","page":"Core API","title":"Giac.GiacMatrix","text":"GiacMatrix\n\nRepresents a symbolic matrix with GiacExpr elements.\n\nFields\n\nptr::Ptr{Cvoid}: Pointer to GIAC matrix object\nrows::Int: Number of rows\ncols::Int: Number of columns\n\nExample\n\nA = GiacMatrix([[a, b], [c, d]])\ndet(A)  # a*d - b*c\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacError","page":"Core API","title":"Giac.GiacError","text":"GiacError <: Exception\n\nException type for errors from the GIAC library.\n\nFields\n\nmsg::String: Error message\ncategory::Symbol: Error category (:parse, :eval, :type, :memory)\n\nExample\n\nthrow(GiacError(\"Failed to parse expression\", :parse))\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.HelpResult","page":"Core API","title":"Giac.HelpResult","text":"HelpResult\n\nA structured representation of parsed GIAC command help information.\n\nFields\n\ncommand::String: The command name being documented\ndescription::String: Description text from GIAC help\nrelated::Vector{String}: List of related command names\nexamples::Vector{String}: List of individual example expressions\n\nExample\n\nresult = help(:factor)\nresult.command      # \"factor\"\nresult.description  # \"Factorizes a polynomial.\"\nresult.related      # [\"ifactor\", \"partfrac\", \"normal\"]\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\nhelp: Get formatted help for a command\ngiac_help: Get raw help string\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacCommand","page":"Core API","title":"Giac.GiacCommand","text":"GiacCommand\n\nA callable wrapper for GIAC commands.\n\nThis type stores a command name and can be called with arguments to execute the underlying GIAC command. It provides a structured way to represent commands that can be passed around and invoked.\n\nFields\n\nname::Symbol: The GIAC command name (e.g., :factor, :diff)\n\nExample\n\n# Create a command and call it\nfactor_cmd = GiacCommand(:factor)\nexpr = giac_eval(\"x^2 - 1\")\nresult = factor_cmd(expr)  # Returns (x-1)*(x+1)\n\n# Equivalent to:\nresult = giac_cmd(:factor, expr)\n\nSee also\n\ninvoke_cmd: Direct command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.giac_eval","page":"Core API","title":"Giac.giac_eval","text":"giac_eval(expr::String, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nEvaluate a GIAC expression string and return a GiacExpr.\n\nArguments\n\nexpr::String: A string containing a valid GIAC expression\nctx::GiacContext: Optional evaluation context (uses DEFAULT_CONTEXT if not provided)\n\nReturns\n\nGiacExpr: The evaluated expression\n\nThrows\n\nGiacError(:parse): If the expression cannot be parsed\nGiacError(:eval): If evaluation fails\n\nExample\n\nresult = giac_eval(\"2 + 3\")\nprintln(result)  # 5\n\n# Symbolic computation\nexpr = giac_eval(\"diff(x^2, x)\")\nprintln(expr)  # 2*x\n\n\n\n\n\ngiac_eval(expr::GiacExpr, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nRe-evaluate an existing GiacExpr in a context (useful after variable assignments).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_julia","page":"Core API","title":"Giac.to_julia","text":"to_julia(expr::GiacExpr)\n\nConvert a GIAC expression to a Julia-native value if possible.\n\nReturns\n\nInt64 or BigInt for integer results\nFloat64 for floating-point results\nComplexF64 for complex results\nRational for rational results\nGiacExpr if the expression is symbolic (cannot be converted)\n\nExample\n\nresult = giac_eval(\"2 + 3\")\njulia_value = to_julia(result)  # Returns Int64(5)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.@giac_var","page":"Core API","title":"Giac.@giac_var","text":"@giac_var sym...\n\nCreate symbolic variables from Julia symbols.\n\nCreates GiacExpr variables in the calling scope by internally calling giac_eval with the stringified symbol name. This provides a cleaner syntax for variable declaration similar to @variables in Symbolics.jl.\n\nExamples\n\nSingle variable:\n\n@giac_var x           # Creates x as a GiacExpr\nstring(x)             # \"x\"\nx isa GiacExpr        # true\n\nMultiple variables:\n\n@giac_var x y z       # Creates x, y, z as GiacExpr variables\n\nUsage\n\nusing Giac\n\n@giac_var x y\nexpr = giac_eval(\"x^2 + y^2\")\nresult = giac_diff(expr, x)  # 2*x\n\nSee also\n\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.@giac_several_var","page":"Core API","title":"Giac.@giac_several_var","text":"@giac_several_var base dims...\n\nCreate multiple indexed symbolic variables for N-dimensional tensors.\n\nThis macro generates multiple GiacExpr variables in the calling scope with names formed from a base name and indices. It supports any number of dimensions and returns a tuple of all created variables.\n\nArguments\n\nbase: Symbol - The base name for variables (e.g., a, coeff, α)\ndims...: Integer literals - Dimensions of the tensor (1 or more)\n\nReturns\n\nTuple{GiacExpr...}: A tuple containing all created variables in lexicographic order\n\nNaming Convention\n\nIf all dimensions ≤ 9: indices are concatenated directly (e.g., a123)\nIf any dimension > 9: underscore separators are used (e.g., a_1_10_3)\n\nExamples\n\n1D vector:\n\n@giac_several_var a 3\n# Creates: a1, a2, a3 and returns (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# Capture return value\nvars = @giac_several_var c 4\nlength(vars)  # 4\n\n2D matrix:\n\nresult = @giac_several_var m 2 3\n# Creates: m11, m12, m13, m21, m22, m23\n# Returns: (m11, m12, m13, m21, m22, m23)\nlength(result)  # 6\n\n3D tensor:\n\n@giac_several_var t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n# Returns tuple of 8 variables\n\nLarge dimensions (separator used):\n\n@giac_several_var b 2 10 3\n# Creates: b_1_1_1, b_1_1_2, ..., b_2_10_3\n\nUnicode base names:\n\n@giac_several_var α 2\n# Creates: α1, α2\n\nEdge cases:\n\n@giac_several_var x 0     # Returns empty tuple ()\n@giac_several_var y 1     # Creates y1, returns (y1,)\n@giac_several_var z 2 0   # Returns empty tuple (0 in any dim)\n\nSee also\n\n@giac_var: For creating single symbolic variables\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.giac_diff","page":"Core API","title":"Giac.giac_diff","text":"giac_diff(expr::GiacExpr, var::GiacExpr, n::Int=1)\ngiac_diff(expr::String, var::String, n::Int=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nArguments\n\nexpr: The expression to differentiate\nvar: The variable to differentiate with respect to\nn: Order of differentiation (default: 1)\n\nExample\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndf = giac_diff(f, x)      # 3*x^2\nd2f = giac_diff(f, x, 2)  # 6*x\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_integrate","page":"Core API","title":"Giac.giac_integrate","text":"giac_integrate(expr::GiacExpr, var::GiacExpr)\ngiac_integrate(expr::GiacExpr, var::GiacExpr, a, b)\n\nCompute indefinite or definite integral.\n\nArguments\n\nexpr: The expression to integrate\nvar: The variable of integration\na, b: Optional bounds for definite integration\n\nExample\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nF = giac_integrate(f, x)           # x^3/3\narea = giac_integrate(f, x, 0, 1)  # 1/3\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_limit","page":"Core API","title":"Giac.giac_limit","text":"giac_limit(expr::GiacExpr, var::GiacExpr, point::GiacExpr; direction::Symbol=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nArguments\n\nexpr: The expression\nvar: The variable\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nExample\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlim = giac_limit(f, x, giac_eval(\"0\"))  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_series","page":"Core API","title":"Giac.giac_series","text":"giac_series(expr::GiacExpr, var::GiacExpr, point::GiacExpr, order::Int)\n\nCompute Taylor/Laurent series expansion.\n\nExample\n\nf = giac_eval(\"exp(x)\")\nx = giac_eval(\"x\")\ns = giac_series(f, x, giac_eval(\"0\"), 5)  # 1 + x + x^2/2 + x^3/6 + x^4/24 + ...\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_factor","page":"Core API","title":"Giac.giac_factor","text":"giac_factor(expr::GiacExpr)\n\nFactor a polynomial expression.\n\nExample\n\np = giac_eval(\"x^2 - 1\")\nf = giac_factor(p)  # (x-1)*(x+1)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_expand","page":"Core API","title":"Giac.giac_expand","text":"giac_expand(expr::GiacExpr)\n\nExpand a polynomial expression.\n\nExample\n\np = giac_eval(\"(x+1)^3\")\ne = giac_expand(p)  # x^3 + 3*x^2 + 3*x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_simplify","page":"Core API","title":"Giac.giac_simplify","text":"giac_simplify(expr::GiacExpr)\n\nSimplify an expression.\n\nExample\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\ns = giac_simplify(e)  # x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_solve","page":"Core API","title":"Giac.giac_solve","text":"giac_solve(expr::GiacExpr, var::GiacExpr)\n\nSolve an equation for a variable.\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsols = giac_solve(eq, x)  # [-2, 2]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_gcd","page":"Core API","title":"Giac.giac_gcd","text":"giac_gcd(a::GiacExpr, b::GiacExpr)\n\nCompute the greatest common divisor of two expressions.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_commands","page":"Core API","title":"Giac.list_commands","text":"list_commands()\n\nReturn a vector of all available GIAC command names.\n\nExample\n\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))\nprintln(\"First 10: \", cmds[1:10])\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help_count","page":"Core API","title":"Giac.help_count","text":"help_count()\n\nReturn the number of commands in the GIAC help database.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands","page":"Core API","title":"Giac.search_commands","text":"search_commands(pattern::String) -> Vector{String}\n\nSearch for commands matching a string prefix.\n\nArguments\n\npattern::String: Prefix to match\n\nReturns\n\nVector{String}: List of matching command names, sorted alphabetically\n\nExample\n\nsearch_commands(\"sin\")  # Returns [\"sin\", \"sinc\", \"sincos\", \"sinh\", ...]\n\n\n\n\n\nsearch_commands(pattern::Regex) -> Vector{String}\n\nSearch for commands matching a regular expression.\n\nArguments\n\npattern::Regex: Regular expression to match\n\nReturns\n\nVector{String}: List of matching command names, sorted alphabetically\n\nExample\n\nsearch_commands(r\"^a.*n$\")  # Returns commands starting with 'a' and ending with 'n'\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.commands_in_category","page":"Core API","title":"Giac.commands_in_category","text":"commands_in_category(category::Symbol) -> Vector{String}\n\nGet all commands in a specific category.\n\nArguments\n\ncategory::Symbol: Category name (e.g., :trigonometry, :algebra)\n\nReturns\n\nVector{String}: List of command names in the category, sorted alphabetically\n\nThrows\n\nArgumentError: If the category does not exist\n\nExample\n\ntrig = commands_in_category(:trigonometry)\n# [\"acos\", \"asin\", \"atan\", \"cos\", \"sin\", \"tan\", ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.command_info","page":"Core API","title":"Giac.command_info","text":"command_info(cmd::Symbol) -> Union{CommandInfo, Nothing}\n\nGet metadata about a specific command.\n\nArguments\n\ncmd::Symbol: Command name\n\nReturns\n\nCommandInfo: Metadata about the command\nnothing: If the command is not found\n\nExample\n\ninfo = command_info(:factor)\nif info !== nothing\n    println(info.name)      # \"factor\"\n    println(info.category)  # :algebra\nend\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_categories","page":"Core API","title":"Giac.list_categories","text":"list_categories() -> Vector{Symbol}\n\nList all available command categories.\n\nReturns\n\nVector{Symbol}: Category names, sorted alphabetically\n\nExample\n\ncats = list_categories()\n# [:algebra, :calculus, :combinatorics, :geometry, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help","page":"Core API","title":"Giac.help","text":"help(cmd::Union{Symbol, String}) -> HelpResult\n\nGet formatted help for a GIAC command.\n\nReturns a HelpResult struct containing parsed help information. The result auto-displays formatted output in the REPL, and provides programmatic access to individual fields.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nHelpResult: Structured help information with fields:\ncommand: Command name\ndescription: Description text\nrelated: Vector of related command names\nexamples: Vector of example expressions\n\nExample\n\nusing Giac\n\n# View formatted help (auto-displays)\nhelp(:factor)\n# factor\n# ══════\n#\n# Description:\n#   Factorizes a polynomial.\n#\n# Related:\n#   ifactor, partfrac, normal\n#\n# Examples:\n#   • factor(x^4-1)\n#   • factor(x^4-4,sqrt(2))\n\n# Access help data programmatically\nresult = help(:factor)\nresult.description  # \"Factorizes a polynomial.\"\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\ngiac_help: Returns raw help string\nHelpResult: The return type\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_help","page":"Core API","title":"Giac.giac_help","text":"giac_help(cmd::Union{Symbol, String}) -> String\n\nGet GIAC help text for a command.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nString: Help text from GIAC, or empty string if not found\n\nExample\n\nhelp = giac_help(:factor)\nprintln(help)  # \"factor(Expr) - Factor a polynomial...\"\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.suggest_commands","page":"Core API","title":"Giac.suggest_commands","text":"suggest_commands(input::Union{Symbol, String}; n::Int=get_suggestion_count()) -> Vector{String}\n\nFind commands similar to the given input using edit distance.\n\nThis function helps users recover from typos by suggesting valid GIAC commands that are similar to the input.\n\nArguments\n\ninput: The mistyped command name (Symbol or String)\nn: Maximum number of suggestions to return (default: get_suggestion_count())\n\nReturns\n\nVector{String}: Similar command names, sorted by edit distance (ascending), then alphabetically. Returns empty vector if no similar commands found.\n\nExample\n\nsuggest_commands(:factr)\n# [\"factor\", \"cfactor\", \"ifactor\", ...]\n\nsuggest_commands(\"integrat\", n=2)\n# [\"integrate\", ...]\n\nsuggest_commands(:factor)  # Exact match\n# []  (empty, no suggestions needed)\n\nSee also\n\nsuggest_commands_with_distances: Also returns edit distances (internal function)\nset_suggestion_count: Configure default suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.set_suggestion_count","page":"Core API","title":"Giac.set_suggestion_count","text":"set_suggestion_count(n::Int) -> Nothing\n\nSet the default number of command suggestions.\n\nArguments\n\nn: Number of suggestions (must be > 0, otherwise resets to default 4)\n\nExample\n\nset_suggestion_count(6)\nget_suggestion_count()  # 6\n\nset_suggestion_count(-1)  # Invalid, resets to default\nget_suggestion_count()  # 4\n\nSee also\n\nget_suggestion_count: Get the current count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.get_suggestion_count","page":"Core API","title":"Giac.get_suggestion_count","text":"get_suggestion_count() -> Int\n\nGet the current default number of command suggestions.\n\nReturns\n\nInt: Current suggestion count (default: 4)\n\nExample\n\nget_suggestion_count()  # 4 (default)\n\nSee also\n\nset_suggestion_count: Set the suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands_by_description","page":"Core API","title":"Giac.search_commands_by_description","text":"search_commands_by_description(query; n=20) -> Vector{String}\n\nSearch for GIAC commands whose help text contains the given keyword.\n\nUnlike search_commands which matches command names, this function searches the description and example text of each command's help documentation.\n\nArguments\n\nquery::Union{String, Symbol}: Search term to find in help text\nn::Int=20: Maximum number of results to return\n\nReturns\n\nVector{String}: Matching command names, sorted by relevance\n\nExample\n\n# Find commands related to factorization\nsearch_commands_by_description(\"factor\")\n# Returns: [\"factor\", \"ifactor\", \"cfactor\", ...]\n\n# Search for matrix operations\nsearch_commands_by_description(\"matrix\", n=10)\n\nSee also\n\nsearch_commands: Search by command name pattern\nhelp: Get detailed help for a specific command\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.JULIA_CONFLICTS","page":"Core API","title":"Giac.JULIA_CONFLICTS","text":"JULIA_CONFLICTS\n\nSet of GIAC command names that conflict with Julia keywords, builtins, or standard library functions. These commands cannot be safely exported as top-level functions but remain accessible via giac_cmd(:name, args...).\n\nConflict Categories\n\nJulia keywords: if, for, while, end, in, or, and, etc.\nBase builtins: eval, float, sum, prod, div, mod, abs, etc.\nBase math functions: sin, cos, tan, exp, log, sqrt, etc.\nLinearAlgebra: det, inv, trace, rank, transpose, etc.\n\nExample\n\n\"eval\" in JULIA_CONFLICTS  # true\n\"factor\" in JULIA_CONFLICTS  # false\n\n# Conflicting commands still work via giac_cmd\ngiac_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\nexportable_commands: Commands safe to export\nconflict_reason: Get the conflict category for a command\n\n\n\n\n\n","category":"constant"},{"location":"api/core/#Giac.exportable_commands","page":"Core API","title":"Giac.exportable_commands","text":"exportable_commands() -> Vector{String}\n\nGet a list of GIAC commands that can be safely exported without conflicting with Julia keywords, builtins, or standard library functions.\n\nThis function filters the complete command list to include only commands that:\n\nStart with an ASCII letter (a-z, A-Z)\nDo not conflict with Julia (not in JULIA_CONFLICTS)\n\nReturns\n\nVector{String}: Sorted list of exportable command names\n\nExample\n\ncmds = exportable_commands()\nlength(cmds)        # ~2000+\n\"factor\" in cmds    # true\n\"eval\" in cmds      # false (conflicts with Julia)\n\"sin\" in cmds       # false (conflicts with Base.sin)\nissorted(cmds)      # true\n\nSee also\n\navailable_commands: All commands starting with ASCII letters\nJULIA_CONFLICTS: Commands that conflict with Julia\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_valid_command","page":"Core API","title":"Giac.is_valid_command","text":"is_valid_command(name::Union{Symbol, String}) -> Bool\n\nCheck if a command name is a valid GIAC command.\n\nArguments\n\nname: Command name as Symbol or String\n\nReturns\n\ntrue if the command exists in GIAC's command list\nfalse otherwise\n\nExample\n\nis_valid_command(:factor)      # true\nis_valid_command(\"integrate\")  # true\nis_valid_command(:notacommand) # false\n\nSee also\n\nlist_commands: Get all command names\nsuggest_commands: Get suggestions for misspelled commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.conflict_reason","page":"Core API","title":"Giac.conflict_reason","text":"conflict_reason(cmd::Union{Symbol, String}) -> Union{Symbol, Nothing}\n\nGet the reason why a GIAC command conflicts with Julia.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\n:keyword - Conflicts with Julia keyword (if, for, while, etc.)\n:builtin - Conflicts with Julia builtin function (eval, float, etc.)\n:base_math - Conflicts with Base math function (sin, cos, exp, etc.)\n:linear_algebra - Conflicts with LinearAlgebra (det, inv, trace, etc.)\n:statistics - Conflicts with Statistics (mean, median, var, etc.)\nnothing - No conflict\n\nExample\n\nconflict_reason(:eval)    # :builtin\nconflict_reason(:sin)     # :base_math\nconflict_reason(:det)     # :linear_algebra\nconflict_reason(:for)     # :keyword\nconflict_reason(:factor)  # nothing\n\nSee also\n\nJULIA_CONFLICTS: Set of all conflicting commands\nexportable_commands: Commands safe to export\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.available_commands","page":"Core API","title":"Giac.available_commands","text":"available_commands()\n\nReturn a sorted vector of all available GIAC command names that start with an ASCII letter (a-z, A-Z).\n\nThis function provides programmatic discovery of available commands. It filters out operators, keywords, and commands starting with non-ASCII characters.\n\nReturns\n\nVector{String}: Sorted list of command names starting with ASCII letters\n\nExample\n\n# List all available commands\ncmds = available_commands()\nprintln(\"Found $(length(cmds)) commands\")  # ~2100+\n\n# Check if a command exists\n\"factor\" in cmds  # true\n\"+\" in cmds       # false (operator)\n\n# Compare with exportable commands\nexportable = exportable_commands()\nlength(exportable)  # ~2000+ (excludes Julia conflicts)\n\nAccessing Commands\n\ninvoke_cmd (all commands): Universal access, always available\ninvoke_cmd(:eval, expr)  # Works for conflicting commands too\ninvoke_cmd(:factor, expr)\nSelective import: Import specific commands from Giac.Commands\nusing Giac.Commands: factor, expand\nfactor(expr)  # Works directly\nFull import: Import all ~2000+ commands\nusing Giac.Commands\nfactor(expr)   # Works directly\nifactor(expr)  # All commands available\n\nSee also\n\nexportable_commands: Commands safe to export (no Julia conflicts)\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all exportable commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.reset_conflict_warnings!","page":"Core API","title":"Giac.reset_conflict_warnings!","text":"reset_conflict_warnings!()\n\nReset the conflict warning tracker, allowing warnings to be shown again.\n\nThis is primarily useful for testing.\n\nExample\n\ngiac_cmd(:eval, expr)  # Shows warning\ngiac_cmd(:eval, expr)  # No warning (already shown)\nreset_conflict_warnings!()\ngiac_cmd(:eval, expr)  # Shows warning again\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_giac","page":"Core API","title":"Giac.to_giac","text":"to_giac(expr)\n\nConvert an expression to GiacExpr. Extended by GiacSymbolicsExt for Symbolics.Num types.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_symbolics","page":"Core API","title":"Giac.to_symbolics","text":"to_symbolics(expr::GiacExpr)\n\nConvert a GiacExpr to a Symbolics.jl expression. Extended by GiacSymbolicsExt.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_stub_mode","page":"Core API","title":"Giac.is_stub_mode","text":"is_stub_mode()\n\nCheck if the wrapper is running in stub mode (without the actual library).\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#TempApi-Submodule","page":"TempApi","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for common symbolic computation operations.","category":"section"},{"location":"api/tempapi/#Usage","page":"TempApi","title":"Usage","text":"","category":"section"},{"location":"api/tempapi/#Selective-Import-(Recommended)","page":"TempApi","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.TempApi: diff, factor, integrate\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)     # 2*x\nfactor(expr)      # (x-1)*(x+1)","category":"section"},{"location":"api/tempapi/#Full-Import","page":"TempApi","title":"Full Import","text":"using Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\ndiff(giac_eval(\"x^3\"), x)  # 3*x^2","category":"section"},{"location":"api/tempapi/#Calculus-Functions","page":"TempApi","title":"Calculus Functions","text":"","category":"section"},{"location":"api/tempapi/#Algebra-Functions","page":"TempApi","title":"Algebra Functions","text":"","category":"section"},{"location":"api/tempapi/#Giac.TempApi","page":"TempApi","title":"Giac.TempApi","text":"Giac.TempApi\n\nA submodule providing convenience functions with simplified names for common symbolic computation operations. These functions delegate to the corresponding giac_* functions from the main Giac module.\n\nAccess Patterns\n\nFull import (for interactive use):\nusing Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nSelective import (recommended):\nusing Giac\nusing Giac.TempApi: diff, factor\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)    # Works\nfactor(expr)     # Works\nQualified access:\nusing Giac\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)\n\nExports\n\ndiff: Differentiate an expression (delegates to giac_diff)\nintegrate: Integrate an expression (delegates to giac_integrate)\nlimit: Compute limit (delegates to giac_limit)\nfactor: Factor a polynomial (delegates to giac_factor)\nexpand: Expand an expression (delegates to giac_expand)\nsimplify: Simplify an expression (delegates to giac_simplify)\nsolve: Solve an equation (delegates to giac_solve)\n\nSee also\n\ngiac_diff, giac_integrate, etc.: Original functions in main module\nGiac.Commands: Submodule with all GIAC commands\n\n\n\n\n\n","category":"module"},{"location":"api/tempapi/#Giac.TempApi.diff","page":"TempApi","title":"Giac.TempApi.diff","text":"diff(expr, var, n=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nDelegates to giac_diff.\n\nArguments\n\nexpr: Expression to differentiate (GiacExpr or String)\nvar: Variable to differentiate with respect to (GiacExpr or String)\nn: Order of differentiation (default: 1)\n\nReturns\n\nGiacExpr: The derivative\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndiff(f, x)      # 3*x^2\ndiff(f, x, 2)   # 6*x\n\nSee also\n\ngiac_diff: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.integrate","page":"TempApi","title":"Giac.TempApi.integrate","text":"integrate(expr, var)\nintegrate(expr, var, a, b)\n\nCompute indefinite or definite integral.\n\nDelegates to giac_integrate.\n\nArguments\n\nexpr: Expression to integrate (GiacExpr or String)\nvar: Variable of integration (GiacExpr or String)\na, b: Optional bounds for definite integration\n\nReturns\n\nGiacExpr: The integral\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nintegrate(f, x)           # x^3/3\nintegrate(f, x, 0, 1)     # 1/3\n\nSee also\n\ngiac_integrate: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.limit","page":"TempApi","title":"Giac.TempApi.limit","text":"limit(expr, var, point; direction=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nDelegates to giac_limit.\n\nArguments\n\nexpr: The expression (GiacExpr or String)\nvar: The variable (GiacExpr or String)\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nReturns\n\nGiacExpr: The limit\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlimit(f, x, giac_eval(\"0\"))  # 1\n\nSee also\n\ngiac_limit: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.factor","page":"TempApi","title":"Giac.TempApi.factor","text":"factor(expr)\n\nFactor a polynomial expression.\n\nDelegates to giac_factor.\n\nArguments\n\nexpr: Expression to factor (GiacExpr or String)\n\nReturns\n\nGiacExpr: The factored expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"x^2 - 1\")\nfactor(p)  # (x-1)*(x+1)\n\nSee also\n\ngiac_factor: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.expand","page":"TempApi","title":"Giac.TempApi.expand","text":"expand(expr)\n\nExpand a polynomial expression.\n\nDelegates to giac_expand.\n\nArguments\n\nexpr: Expression to expand (GiacExpr or String)\n\nReturns\n\nGiacExpr: The expanded expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"(x+1)^3\")\nexpand(p)  # x^3 + 3*x^2 + 3*x + 1\n\nSee also\n\ngiac_expand: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.simplify","page":"TempApi","title":"Giac.TempApi.simplify","text":"simplify(expr)\n\nSimplify an expression.\n\nDelegates to giac_simplify.\n\nArguments\n\nexpr: Expression to simplify (GiacExpr or String)\n\nReturns\n\nGiacExpr: The simplified expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\nsimplify(e)  # x + 1\n\nSee also\n\ngiac_simplify: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.solve","page":"TempApi","title":"Giac.TempApi.solve","text":"solve(expr, var)\n\nSolve an equation for a variable.\n\nDelegates to giac_solve.\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsolve(eq, x)  # [-2, 2]\n\nSee also\n\ngiac_solve: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Option-1:-Stub-Mode-(No-C-Dependencies)","page":"Installation","title":"Option 1: Stub Mode (No C++ Dependencies)","text":"For development or testing without the full GIAC library:\n\nusing Pkg\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")\n\nIn stub mode, basic operations work but return placeholder values.","category":"section"},{"location":"install/#Option-2:-Full-Integration-(With-GIAC-2.0.0)","page":"Installation","title":"Option 2: Full Integration (With GIAC 2.0.0)","text":"","category":"section"},{"location":"install/#Prerequisites","page":"Installation","title":"Prerequisites","text":"Julia 1.10+ (LTS recommended)\nC++ compiler with C++17 support\nCMake 3.15+\nGIAC 2.0.0 source","category":"section"},{"location":"install/#Step-1:-Build-GIAC-2.0.0","page":"Installation","title":"Step 1: Build GIAC 2.0.0","text":"# Download GIAC\nwget https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/giac_stable.tgz\ntar xzf giac_stable.tgz\ncd giac-2.0.0\n\n# Configure and build\n./configure --enable-shared --disable-gui --disable-pari\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-2:-Build-libgiac-julia-wrapper","page":"Installation","title":"Step 2: Build libgiac-julia-wrapper","text":"git clone https://github.com/s-celles/libgiac-julia-wrapper\ncd libgiac-julia-wrapper\nmkdir build && cd build\ncmake .. -DGIAC_ROOT=/path/to/giac-2.0.0\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-3:-Set-Environment","page":"Installation","title":"Step 3: Set Environment","text":"export GIAC_WRAPPER_LIB=/path/to/libgiac-julia-wrapper/build/src/libgiac_wrapper.so\nexport LD_LIBRARY_PATH=/path/to/giac-2.0.0/src/.libs:$LD_LIBRARY_PATH","category":"section"},{"location":"install/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"using Giac\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())\n\n# If stub mode is false, full GIAC integration is working\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)","category":"section"},{"location":"api/commands/#Commands-Submodule","page":"Commands","title":"Commands Submodule","text":"The Giac.Commands submodule provides access to all exportable GIAC commands as Julia functions.","category":"section"},{"location":"api/commands/#Usage","page":"Commands","title":"Usage","text":"","category":"section"},{"location":"api/commands/#Selective-Import-(Recommended)","page":"Commands","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.Commands: factor, expand, diff\n\nexpr = giac_eval(\"x^2 - 1\")\nfactor(expr)  # (x-1)*(x+1)","category":"section"},{"location":"api/commands/#Full-Import","page":"Commands","title":"Full Import","text":"using Giac\nusing Giac.Commands\n\n# All ~2000+ commands available\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))","category":"section"},{"location":"api/commands/#Qualified-Access","page":"Commands","title":"Qualified Access","text":"using Giac\n\nGiac.Commands.factor(giac_eval(\"x^2-1\"))","category":"section"},{"location":"api/commands/#Core-Function","page":"Commands","title":"Core Function","text":"","category":"section"},{"location":"api/commands/#Conflicting-Commands","page":"Commands","title":"Conflicting Commands","text":"Commands that conflict with Julia keywords, builtins, or standard library functions are NOT exported from this module. Use invoke_cmd to call them:\n\n# These conflict with Julia and are NOT exported:\n# eval, sin, cos, det, inv, sum, prod, etc.\n\n# Use invoke_cmd instead:\ninvoke_cmd(:eval, expr)\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))\ninvoke_cmd(:det, matrix)\n\nSee JULIA_CONFLICTS for the complete list of conflicting commands.","category":"section"},{"location":"api/commands/#Available-Commands","page":"Commands","title":"Available Commands","text":"Use exportable_commands() to get a list of all commands available in this module:\n\ncmds = exportable_commands()\nlength(cmds)  # ~2000+","category":"section"},{"location":"api/commands/#Giac.Commands","page":"Commands","title":"Giac.Commands","text":"Giac.Commands\n\nA submodule containing all exportable GIAC commands as functions.\n\nThis module provides access to ~2000+ GIAC commands while keeping the main Giac namespace clean. Commands can be accessed through three patterns:\n\nAccess Patterns\n\nQualified access (cleanest namespace):\nusing Giac\nGiac.Commands.factor(expr)\nGiac.Commands.diff(expr, x)\nSelective import (recommended for most use cases):\nusing Giac\nusing Giac.Commands: factor, expand, diff\nfactor(expr)  # Works directly\nFull import (for interactive exploration):\nusing Giac\nusing Giac.Commands\nfactor(expr)   # All ~2000+ commands available\nifactor(expr)  # Works directly\n\nConflicting Commands\n\nCommands that conflict with Julia keywords, builtins, or standard library functions (like eval, sin, det) are NOT exported from this module. Use invoke_cmd to call them:\n\nusing Giac\ninvoke_cmd(:eval, expr)  # Works for any command\ninvoke_cmd(:sin, x)      # Including conflicting ones\n\nExports\n\ninvoke_cmd: Universal command invocation function\nAll ~2000+ non-conflicting GIAC commands (runtime-generated)\n\nSee also\n\ninvoke_cmd: Call any GIAC command by name\nGiac.JULIA_CONFLICTS: Commands that conflict with Julia\nGiac.exportable_commands: List of exportable commands\n\n\n\n\n\n","category":"module"},{"location":"api/commands/#Giac.Commands.invoke_cmd","page":"Commands","title":"Giac.Commands.invoke_cmd","text":"invoke_cmd(cmd::Symbol, args...) -> GiacExpr\n\nInvoke any GIAC command by name and return the result as a GiacExpr.\n\nThis is the core function for dynamic command invocation, enabling access to all 2200+ GIAC commands through a uniform interface. It works for all commands, including those that conflict with Julia builtins.\n\nArguments\n\ncmd::Symbol: GIAC command name (e.g., :factor, :sin, :integrate)\nargs...: Command arguments (GiacExpr, String, Number, or Symbol)\n\nReturns\n\nGiacExpr: Result of command execution\n\nThrows\n\nGiacError(:eval): If command is unknown or execution fails\nArgumentError: If arguments cannot be converted to GIAC format\n\nExamples\n\nusing Giac\n\n# Single argument\nexpr = giac_eval(\"x^2 - 1\")\nresult = invoke_cmd(:factor, expr)  # Returns (x-1)*(x+1)\n\n# Multiple arguments\nx = giac_eval(\"x\")\nderivative = invoke_cmd(:diff, expr, x)  # Returns 2*x\n\n# Trigonometric functions (conflicts with Base)\nresult = invoke_cmd(:sin, giac_eval(\"pi/6\"))  # Returns 1/2\n\n# Evaluation (conflicts with Base.eval)\nresult = invoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\ngiac_eval: Direct string evaluation\nGiac.search_commands: Find available commands\nGiac.help: Get help for a command\n\n\n\n\n\n","category":"function"},{"location":"#Giac.jl","page":"Home","title":"Giac.jl","text":"A Julia wrapper for the GIAC computer algebra system.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Symbolic Computation: Full access to GIAC's powerful symbolic computation engine\nCalculus: Differentiation, integration, limits, and series expansion\nAlgebra: Factorization, expansion, simplification, and equation solving\nLinear Algebra: Symbolic matrices with determinant, inverse, trace operations\n2200+ Commands: Access to all GIAC commands through a unified API\nLaTeX Support: Automatic LaTeX rendering in Pluto notebooks","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Giac\")\n\nFor full GIAC integration with C++ library, see the Installation Guide.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Giac\n\n# Create symbolic variables\n@giac_var x y\n\n# Evaluate expressions\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\n\n# Factor polynomials\nresult = giac_factor(expr)  # Returns (x+y)^2\n\n# Differentiate\nderivative = giac_diff(result, x)  # Returns 2*(x+y)\n\n# Integrate\nintegral = giac_integrate(giac_eval(\"x^2\"), x)  # Returns x^3/3","category":"section"},{"location":"#Command-Access","page":"Home","title":"Command Access","text":"GIAC commands are available through multiple access patterns:","category":"section"},{"location":"#1.-Universal-Command-Invocation-(Recommended)","page":"Home","title":"1. Universal Command Invocation (Recommended)","text":"using Giac\n\n# Works for ALL commands, including those conflicting with Julia\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))","category":"section"},{"location":"#2.-Selective-Import-from-Commands-Submodule","page":"Home","title":"2. Selective Import from Commands Submodule","text":"using Giac\nusing Giac.Commands: factor, expand, ifactor\n\nfactor(giac_eval(\"x^2-1\"))  # Works directly","category":"section"},{"location":"#3.-Full-Import-(Interactive-Use)","page":"Home","title":"3. Full Import (Interactive Use)","text":"using Giac\nusing Giac.Commands\n\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))  # All ~2000+ commands available","category":"section"},{"location":"#Modules","page":"Home","title":"Modules","text":"Core API: Types, evaluation, and main functions\nCommands: All GIAC commands as functions\nTempApi: Convenience functions with simple names","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"install.md\", \"api/core.md\", \"api/commands.md\", \"api/tempapi.md\"]","category":"section"}]
}
