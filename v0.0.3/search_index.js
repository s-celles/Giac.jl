var documenterSearchIndex = {"docs":
[{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#User-mode-installation-(not-yet-available)","page":"Installation","title":"User mode installation (not yet available)","text":"This command will install Giac.jl (when both GIAC_jll and libgiac-julia-wrapper will be published)\n\nusing Pkg\nPkg.add(\"Giac\")  # when registered in Julia General Registry\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")  # until unregistered","category":"section"},{"location":"install/#Developer-mode-installation","page":"Installation","title":"Developer mode installation","text":"","category":"section"},{"location":"install/#Option-1:-Stub-Mode-(No-C-Dependencies)","page":"Installation","title":"Option 1: Stub Mode (No C++ Dependencies)","text":"For development or testing without the full GIAC library:\n\nusing Pkg\nPkg.add(url=\"https://github.com/s-celles/Giac.jl\")\n\nIn stub mode, basic operations work but return placeholder values.","category":"section"},{"location":"install/#Option-2:-Full-Integration-(With-GIAC-2.0.0)","page":"Installation","title":"Option 2: Full Integration (With GIAC 2.0.0)","text":"","category":"section"},{"location":"install/#Prerequisites","page":"Installation","title":"Prerequisites","text":"Julia 1.10+ (LTS recommended)\nC++ compiler with C++17 support\nCMake 3.15+\nGIAC 2.0.0 source","category":"section"},{"location":"install/#Step-1:-Build-GIAC-2.0.0","page":"Installation","title":"Step 1: Build GIAC 2.0.0","text":"# Download GIAC\nwget https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/giac_stable.tgz\ntar xzf giac_stable.tgz\ncd giac-2.0.0\n\n# Configure and build\n./configure --enable-shared --disable-gui --disable-pari\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-2:-Build-libgiac-julia-wrapper","page":"Installation","title":"Step 2: Build libgiac-julia-wrapper","text":"git clone https://github.com/s-celles/libgiac-julia-wrapper\ncd libgiac-julia-wrapper\nmkdir build && cd build\ncmake .. -DGIAC_ROOT=/path/to/giac-2.0.0\nmake -j$(nproc)","category":"section"},{"location":"install/#Step-3:-Set-Environment","page":"Installation","title":"Step 3: Set Environment","text":"export GIAC_WRAPPER_LIB=/path/to/libgiac-julia-wrapper/build/src/libgiac_wrapper.so\nexport LD_LIBRARY_PATH=/path/to/giac-2.0.0/src/.libs:$LD_LIBRARY_PATH","category":"section"},{"location":"install/#Verifying-Installation","page":"Installation","title":"Verifying Installation","text":"using Giac\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())\n\n# If stub mode is false, full GIAC integration is working\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)","category":"section"},{"location":"extensions/symbolics/#Symbolics.jl-Integration","page":"Symbolics.jl","title":"Symbolics.jl Integration","text":"using Giac, Symbolics\n\n@variables x y\ngiac_expr = to_giac(x^2 + 2*x + 1)\nfactored = giac_factor(giac_expr)  # (x+1)^2\nsym_result = to_symbolics(factored)  # Num: (1+x)^2","category":"section"},{"location":"api/giac_commands/#GIAC-commands","page":"GIAC Commands","title":"GIAC commands","text":"","category":"section"},{"location":"api/giac_commands/#Dynamic-Command-Invocation","page":"GIAC Commands","title":"Dynamic Command Invocation","text":"Call any of GIAC's 2200+ commands dynamically:\n\nusing Giac\n\n@giac_var x\nexpr = giac_eval(\"x^2 - 1\")\n\n# Function syntax with invoke_cmd (works for ALL commands)\nresult = invoke_cmd(:factor, expr)           # (x-1)*(x+1)\nderiv = invoke_cmd(:diff, expr, x)           # 2*x\nintegral = invoke_cmd(:integrate, expr, x)   # x^3/3-x\n\n# Method syntax on GiacExpr (equivalent to invoke_cmd)\nresult = expr.factor()                     # (x-1)*(x+1)\nderiv = expr.diff(x)                       # 2*x\n\n# Chaining methods\nresult = giac_eval(\"(x+1)^3\").expand().simplify()\n\n# Natural Julia syntax with Base extensions\n@giac_var y\nsin(y)         # sin(y)\ncos(y)         # cos(y)\nexp(y)         # exp(y)\nlog(y)         # ln(y)\nsqrt(y)        # sqrt(y)\nsin(y) + cos(y)  # sin(y)+cos(y)","category":"section"},{"location":"api/giac_commands/#Commands-Submodule","page":"GIAC Commands","title":"Commands Submodule","text":"Giac.jl provides three ways to access GIAC's 2200+ commands via the Giac.Commands submodule:","category":"section"},{"location":"api/giac_commands/#1.-Qualified-Access-(Cleanest-Namespace-ToDo-not-yet-implemented)","page":"GIAC Commands","title":"1. Qualified Access (Cleanest Namespace - ToDo - not yet implemented)","text":"Access commands via Giac.Commands.commandname:\n\nusing Giac\n\n@giac_var x\nexpr = giac_eval(\"x^2 - 1\")\n\n# Access commands via Giac.Commands\nGiac.Commands.factor(expr)          # (x-1)*(x+1)\nGiac.Commands.expand(giac_eval(\"(x+1)^2\"))  # x^2+2*x+1\nGiac.Commands.diff(expr, x)         # 2*x\nGiac.Commands.integrate(expr, x)    # x^3/3-x\nGiac.Commands.ifactor(giac_eval(\"120\"))  # 2^3*3*5","category":"section"},{"location":"api/giac_commands/#2.-Selective-Import-(Recommended-ToDo-not-yet-implemented)","page":"GIAC Commands","title":"2. Selective Import (Recommended - ToDo - not yet implemented)","text":"Import specific commands you need:\n\nusing Giac\nusing Giac.Commands: factor, expand, diff, integrate\n\n@giac_var x\nexpr = giac_eval(\"x^2 - 1\")\n\n# Direct function syntax (no prefix needed)\nfactor(expr)              # (x-1)*(x+1)\nexpand(giac_eval(\"(x+1)^2\"))  # x^2+2*x+1\ndiff(expr, x)             # 2*x\nintegrate(expr, x)        # x^3/3-x","category":"section"},{"location":"api/giac_commands/#3.-Full-Import-(Interactive-Use)","page":"GIAC Commands","title":"3. Full Import (Interactive Use)","text":"Import all ~2000+ commands for interactive exploration:\n\nusing Giac\nusing Giac.Commands  # Imports ALL exportable commands\n\n@giac_var x\nfactor(giac_eval(\"x^2 - 1\"))    # (x-1)*(x+1)\nifactor(giac_eval(\"120\"))       # 2^3*3*5\nnextprime(giac_eval(\"100\"))     # 101\nairy_ai(giac_eval(\"0\"))         # Airy function\n\n# Discover available commands\nexportable_commands()            # ~2000+ command names","category":"section"},{"location":"api/giac_commands/#invoke_cmd-for-ALL-Commands","page":"GIAC Commands","title":"invoke_cmd for ALL Commands","text":"For commands that conflict with Julia (like sin, cos, eval, det), use invoke_cmd:\n\nusing Giac\n\n@giac_var k n\n\n# Conflicting commands must use invoke_cmd\ninvoke_cmd(:eval, giac_eval(\"2+3\"))      # 5\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))      # 1/2\ninvoke_cmd(:det, giac_eval(\"[[1,2],[3,4]]\"))  # -2\ninvoke_cmd(:det, giac_eval(\"[[a,b],[c,d]]\"))  # a*d-b*c\ninvoke_cmd(:sum, k, k, giac_eval(\"1\"), n)  # 1/2*n^2+1/2*n\ninvoke_cmd(:product, k, k, giac_eval(\"1\"), n)  # n!\n\n# invoke_cmd works for ANY command\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))  # (x-1)*(x+1)","category":"section"},{"location":"api/giac_commands/#TempApi-Submodule","page":"GIAC Commands","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for some common symbolic computation operations. These are wrappers around the giac_* functions.\n\nusing Giac.TempApi: diff, expand, factor, integrate, limit, simplify, solve\n#Overlapping with Julia: eval, include, \n@giac_var x a b\ndiff(x^2, x)  # 2*x\nexpand((a+b)^2)  # a^2+b^2+2*a*b\nfactor(x^2-1)  # (x-1)*(x+1)\nintegrate(x^2, x)  # x^3/3\nintegrate(x^2, x, 0, 1)  # returns\n    // ∫ ~= 0.333333333333\n    GiacExpr: 1/3\nlimit(sin(x)/x, x, giac_eval(\"0\"))  # 1\nsimplify(a + b - a)  # b\nsolve(x^2 - 1)\nsolve(x^2 - 1, x)  # list[-1,1]","category":"section"},{"location":"api/giac_commands/#Available-Functions","page":"GIAC Commands","title":"Available Functions","text":"TempApi Function Delegates To Description\ndiff(expr, var, n=1) giac_diff Differentiate expression\nintegrate(expr, var) giac_integrate Indefinite integral\nintegrate(expr, var, a, b) giac_integrate Definite integral\nlimit(expr, var, point) giac_limit Compute limit\nfactor(expr) giac_factor Factor polynomial\nexpand(expr) giac_expand Expand expression\nsimplify(expr) giac_simplify Simplify expression\nsolve(expr, var) giac_solve Solve equation","category":"section"},{"location":"api/giac_commands/#Usage-Patterns","page":"GIAC Commands","title":"Usage Patterns","text":"using Giac\n\n# 1. Selective import (recommended)\nusing Giac.TempApi: diff, factor, integrate, limit\n\n@giac_var x\nexpr = giac_eval(\"x^2 - 1\")\n\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nintegrate(expr, x)      # x^3/3-x\nlimit(giac_eval(\"sin(x)/x\"), x, giac_eval(\"0\"))  # 1\n\n# 2. Qualified access\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)","category":"section"},{"location":"api/giac_commands/#Comparison:-TempApi-vs-giac_*-vs-Commands","page":"GIAC Commands","title":"Comparison: TempApi vs giac_* vs Commands","text":"Pattern Import Usage Best For\nTempApi using Giac.TempApi diff(expr, x) Clean, simple names for common operations\ngiac_* using Giac giac_diff(expr, x) Main module, explicit prefixes\nCommands using Giac.Commands diff(expr, x) Access to ALL 2200+ GIAC commands\n\nNote: Both TempApi and Commands export diff, factor, etc. Use selective imports to avoid conflicts, or choose one submodule based on your needs.","category":"section"},{"location":"api/giac_commands/#Commands-That-Conflict-with-Julia","page":"GIAC Commands","title":"Commands That Conflict with Julia","text":"Some GIAC commands have the same name as Julia built-ins. These are not exported from Giac.Commands to avoid shadowing Julia's functions:\n\nCategory Conflicting Commands\nKeywords if, for, while, end, in, or, and, not\nBuiltins eval, float, sum, prod, collect, abs, sign\nMath sin, cos, tan, exp, log, sqrt, gcd, lcm\nLinearAlgebra det, inv, trace, rank, transpose, norm\nStatistics mean, median, var, std\n\nUse invoke_cmd(:name, args...) for these commands. A warning is shown on first use to remind you:\n\ninvoke_cmd(:eval, giac_eval(\"2+3\"))\n# ┌ Warning: GIAC command 'eval' conflicts with Julia (builtin).\n# │ Use invoke_cmd(:eval, args...) to call it.","category":"section"},{"location":"api/core/#Core-API","page":"Core API","title":"Core API","text":"The main Giac module provides core types and functions for symbolic computation.","category":"section"},{"location":"api/core/#Types","page":"Core API","title":"Types","text":"","category":"section"},{"location":"api/core/#Expression-Evaluation","page":"Core API","title":"Expression Evaluation","text":"","category":"section"},{"location":"api/core/#Symbolic-Variables","page":"Core API","title":"Symbolic Variables","text":"","category":"section"},{"location":"api/core/#Calculus-Operations","page":"Core API","title":"Calculus Operations","text":"","category":"section"},{"location":"api/core/#Algebraic-Operations","page":"Core API","title":"Algebraic Operations","text":"","category":"section"},{"location":"api/core/#Command-Discovery","page":"Core API","title":"Command Discovery","text":"","category":"section"},{"location":"api/core/#Command-Suggestions","page":"Core API","title":"Command Suggestions","text":"","category":"section"},{"location":"api/core/#Namespace-Management","page":"Core API","title":"Namespace Management","text":"","category":"section"},{"location":"api/core/#Conversion-Functions","page":"Core API","title":"Conversion Functions","text":"","category":"section"},{"location":"api/core/#Utility-Functions","page":"Core API","title":"Utility Functions","text":"","category":"section"},{"location":"api/core/#Core-Functions","page":"Core API","title":"Core Functions","text":"Function Description\ngiac_eval(expr) Evaluate a GIAC expression string\ninvoke_cmd(cmd, args...) Invoke any GIAC command dynamically\nis_stub_mode() Check if running without GIAC library\nto_julia(expr) Convert GiacExpr to Julia type","category":"section"},{"location":"api/core/#Giac","page":"Core API","title":"Giac","text":"Giac\n\nA Julia wrapper for the GIAC computer algebra system.\n\nProvides symbolic expression evaluation, calculus operations, polynomial manipulation, and linear algebra with a Julia-native API.\n\nCore Exports\n\nGiacExpr: Symbolic expression type\nGiacContext: Evaluation context\nGiacMatrix: Symbolic matrix type\nGiacError: Exception type for GIAC errors\ngiac_eval: Evaluate expression strings\n@giac_var: Create symbolic variables from Julia symbols\nto_julia: Convert GiacExpr to Julia types\ninvoke_cmd: Universal command invocation (works for ALL commands)\ngiac_diff, giac_integrate, giac_limit, giac_series: Calculus\ngiac_factor, giac_expand, giac_simplify, giac_solve, giac_gcd: Algebra\n\nCommand Access\n\nGIAC commands are available through the Giac.Commands submodule:\n\nusing Giac\n\n# Use invoke_cmd for any command (always available)\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))  # Works for conflicting commands too\n\n# Import commands selectively (recommended)\nusing Giac.Commands: factor, expand, diff\nfactor(giac_eval(\"x^2-1\"))\n\n# Or import all ~2000+ commands\nusing Giac.Commands\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))\n\nQuick Start\n\nusing Giac\n\n# Declare symbolic variables with @giac_var macro\n@giac_var x y\n\n# Build and manipulate expressions\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\nresult = giac_factor(expr)   # (x+y)^2\n\n# Or use string-based evaluation directly\nresult = giac_eval(\"factor(x^2 - 1)\")\nprintln(result)  # (x-1)*(x+1)\n\nSee also\n\nGiac.Commands: Submodule with all exportable commands\ninvoke_cmd: Universal command invocation\n\n\n\n\n\n","category":"module"},{"location":"api/core/#Giac.GiacExpr","page":"Core API","title":"Giac.GiacExpr","text":"GiacExpr\n\nRepresents a symbolic mathematical expression from GIAC.\n\nWraps a pointer to a C++ giac::gen object. Memory is managed automatically via Julia's garbage collector and finalizers.\n\nExample\n\nexpr = giac_eval(\"x^2 + 1\")\nprintln(expr)  # x^2+1\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacContext","page":"Core API","title":"Giac.GiacContext","text":"GiacContext\n\nRepresents a GIAC evaluation context.\n\nManages configuration settings, variable bindings, and computation state. Thread-safe via internal locking.\n\nExample\n\nctx = GiacContext()\nresult = giac_eval(\"x + 1\", ctx)\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacMatrix","page":"Core API","title":"Giac.GiacMatrix","text":"GiacMatrix\n\nRepresents a symbolic matrix with GiacExpr elements.\n\nFields\n\nptr::Ptr{Cvoid}: Pointer to GIAC matrix object\nrows::Int: Number of rows\ncols::Int: Number of columns\n\nExample\n\nA = GiacMatrix([[a, b], [c, d]])\ndet(A)  # a*d - b*c\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacError","page":"Core API","title":"Giac.GiacError","text":"GiacError <: Exception\n\nException type for errors from the GIAC library.\n\nFields\n\nmsg::String: Error message\ncategory::Symbol: Error category (:parse, :eval, :type, :memory)\n\nExample\n\nthrow(GiacError(\"Failed to parse expression\", :parse))\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.HelpResult","page":"Core API","title":"Giac.HelpResult","text":"HelpResult\n\nA structured representation of parsed GIAC command help information.\n\nFields\n\ncommand::String: The command name being documented\ndescription::String: Description text from GIAC help\nrelated::Vector{String}: List of related command names\nexamples::Vector{String}: List of individual example expressions\n\nExample\n\nresult = help(:factor)\nresult.command      # \"factor\"\nresult.description  # \"Factorizes a polynomial.\"\nresult.related      # [\"ifactor\", \"partfrac\", \"normal\"]\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\nhelp: Get formatted help for a command\ngiac_help: Get raw help string\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.GiacCommand","page":"Core API","title":"Giac.GiacCommand","text":"GiacCommand\n\nA callable wrapper for GIAC commands.\n\nThis type stores a command name and can be called with arguments to execute the underlying GIAC command. It provides a structured way to represent commands that can be passed around and invoked.\n\nFields\n\nname::Symbol: The GIAC command name (e.g., :factor, :diff)\n\nExample\n\n# Create a command and call it\nfactor_cmd = GiacCommand(:factor)\nexpr = giac_eval(\"x^2 - 1\")\nresult = factor_cmd(expr)  # Returns (x-1)*(x+1)\n\n# Equivalent to:\nresult = giac_cmd(:factor, expr)\n\nSee also\n\ninvoke_cmd: Direct command invocation\n\n\n\n\n\n","category":"type"},{"location":"api/core/#Giac.giac_eval","page":"Core API","title":"Giac.giac_eval","text":"giac_eval(expr::String, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nEvaluate a GIAC expression string and return a GiacExpr.\n\nArguments\n\nexpr::String: A string containing a valid GIAC expression\nctx::GiacContext: Optional evaluation context (uses DEFAULT_CONTEXT if not provided)\n\nReturns\n\nGiacExpr: The evaluated expression\n\nThrows\n\nGiacError(:parse): If the expression cannot be parsed\nGiacError(:eval): If evaluation fails\n\nExample\n\nresult = giac_eval(\"2 + 3\")\nprintln(result)  # 5\n\n# Symbolic computation\nexpr = giac_eval(\"diff(x^2, x)\")\nprintln(expr)  # 2*x\n\n\n\n\n\ngiac_eval(expr::GiacExpr, ctx::GiacContext=DEFAULT_CONTEXT[])\n\nRe-evaluate an existing GiacExpr in a context (useful after variable assignments).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_julia","page":"Core API","title":"Giac.to_julia","text":"to_julia(expr::GiacExpr)\n\nConvert a GIAC expression to a Julia-native value if possible.\n\nReturns\n\nInt64 or BigInt for integer results\nFloat64 for floating-point results\nComplexF64 for complex results\nRational for rational results\nGiacExpr if the expression is symbolic (cannot be converted)\n\nExample\n\nresult = giac_eval(\"2 + 3\")\njulia_value = to_julia(result)  # Returns Int64(5)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.@giac_var","page":"Core API","title":"Giac.@giac_var","text":"@giac_var sym...\n\nCreate symbolic variables from Julia symbols.\n\nCreates GiacExpr variables in the calling scope by internally calling giac_eval with the stringified symbol name. This provides a cleaner syntax for variable declaration similar to @variables in Symbolics.jl.\n\nExamples\n\nSingle variable:\n\n@giac_var x           # Creates x as a GiacExpr\nstring(x)             # \"x\"\nx isa GiacExpr        # true\n\nMultiple variables:\n\n@giac_var x y z       # Creates x, y, z as GiacExpr variables\n\nUsage\n\nusing Giac\n\n@giac_var x y\nexpr = giac_eval(\"x^2 + y^2\")\nresult = giac_diff(expr, x)  # 2*x\n\nSee also\n\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.@giac_several_var","page":"Core API","title":"Giac.@giac_several_var","text":"@giac_several_var base dims...\n\nCreate multiple indexed symbolic variables for N-dimensional tensors.\n\nThis macro generates multiple GiacExpr variables in the calling scope with names formed from a base name and indices. It supports any number of dimensions and returns a tuple of all created variables.\n\nArguments\n\nbase: Symbol - The base name for variables (e.g., a, coeff, α)\ndims...: Integer literals - Dimensions of the tensor (1 or more)\n\nReturns\n\nTuple{GiacExpr...}: A tuple containing all created variables in lexicographic order\n\nNaming Convention\n\nIf all dimensions ≤ 9: indices are concatenated directly (e.g., a123)\nIf any dimension > 9: underscore separators are used (e.g., a_1_10_3)\n\nExamples\n\n1D vector:\n\n@giac_several_var a 3\n# Creates: a1, a2, a3 and returns (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# Capture return value\nvars = @giac_several_var c 4\nlength(vars)  # 4\n\n2D matrix:\n\nresult = @giac_several_var m 2 3\n# Creates: m11, m12, m13, m21, m22, m23\n# Returns: (m11, m12, m13, m21, m22, m23)\nlength(result)  # 6\n\n3D tensor:\n\n@giac_several_var t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n# Returns tuple of 8 variables\n\nLarge dimensions (separator used):\n\n@giac_several_var b 2 10 3\n# Creates: b_1_1_1, b_1_1_2, ..., b_2_10_3\n\nUnicode base names:\n\n@giac_several_var α 2\n# Creates: α1, α2\n\nEdge cases:\n\n@giac_several_var x 0     # Returns empty tuple ()\n@giac_several_var y 1     # Creates y1, returns (y1,)\n@giac_several_var z 2 0   # Returns empty tuple (0 in any dim)\n\nSee also\n\n@giac_var: For creating single symbolic variables\ngiac_eval: For evaluating string expressions\n\n\n\n\n\n","category":"macro"},{"location":"api/core/#Giac.giac_diff","page":"Core API","title":"Giac.giac_diff","text":"giac_diff(expr::GiacExpr, var::GiacExpr, n::Int=1)\ngiac_diff(expr::String, var::String, n::Int=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nArguments\n\nexpr: The expression to differentiate\nvar: The variable to differentiate with respect to\nn: Order of differentiation (default: 1)\n\nExample\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndf = giac_diff(f, x)      # 3*x^2\nd2f = giac_diff(f, x, 2)  # 6*x\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_integrate","page":"Core API","title":"Giac.giac_integrate","text":"giac_integrate(expr::GiacExpr, var::GiacExpr)\ngiac_integrate(expr::GiacExpr, var::GiacExpr, a, b)\n\nCompute indefinite or definite integral.\n\nArguments\n\nexpr: The expression to integrate\nvar: The variable of integration\na, b: Optional bounds for definite integration\n\nExample\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nF = giac_integrate(f, x)           # x^3/3\narea = giac_integrate(f, x, 0, 1)  # 1/3\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_limit","page":"Core API","title":"Giac.giac_limit","text":"giac_limit(expr::GiacExpr, var::GiacExpr, point::GiacExpr; direction::Symbol=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nArguments\n\nexpr: The expression\nvar: The variable\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nExample\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlim = giac_limit(f, x, giac_eval(\"0\"))  # 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_series","page":"Core API","title":"Giac.giac_series","text":"giac_series(expr::GiacExpr, var::GiacExpr, point::GiacExpr, order::Int)\n\nCompute Taylor/Laurent series expansion.\n\nExample\n\nf = giac_eval(\"exp(x)\")\nx = giac_eval(\"x\")\ns = giac_series(f, x, giac_eval(\"0\"), 5)  # 1 + x + x^2/2 + x^3/6 + x^4/24 + ...\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_factor","page":"Core API","title":"Giac.giac_factor","text":"giac_factor(expr::GiacExpr)\n\nFactor a polynomial expression.\n\nExample\n\np = giac_eval(\"x^2 - 1\")\nf = giac_factor(p)  # (x-1)*(x+1)\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_expand","page":"Core API","title":"Giac.giac_expand","text":"giac_expand(expr::GiacExpr)\n\nExpand a polynomial expression.\n\nExample\n\np = giac_eval(\"(x+1)^3\")\ne = giac_expand(p)  # x^3 + 3*x^2 + 3*x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_simplify","page":"Core API","title":"Giac.giac_simplify","text":"giac_simplify(expr::GiacExpr)\n\nSimplify an expression.\n\nExample\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\ns = giac_simplify(e)  # x + 1\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_solve","page":"Core API","title":"Giac.giac_solve","text":"giac_solve(expr::GiacExpr, var::GiacExpr)\n\nSolve an equation for a variable.\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsols = giac_solve(eq, x)  # [-2, 2]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_gcd","page":"Core API","title":"Giac.giac_gcd","text":"giac_gcd(a::GiacExpr, b::GiacExpr)\n\nCompute the greatest common divisor of two expressions.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_commands","page":"Core API","title":"Giac.list_commands","text":"list_commands()\n\nReturn a vector of all available GIAC command names.\n\nExample\n\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))\nprintln(\"First 10: \", cmds[1:10])\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help_count","page":"Core API","title":"Giac.help_count","text":"help_count()\n\nReturn the number of commands in the GIAC help database.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands","page":"Core API","title":"Giac.search_commands","text":"search_commands(pattern::String) -> Vector{String}\n\nSearch for commands matching a string prefix.\n\nArguments\n\npattern::String: Prefix to match\n\nReturns\n\nVector{String}: List of matching command names, sorted alphabetically\n\nExample\n\nsearch_commands(\"sin\")  # Returns [\"sin\", \"sinc\", \"sincos\", \"sinh\", ...]\n\n\n\n\n\nsearch_commands(pattern::Regex) -> Vector{String}\n\nSearch for commands matching a regular expression.\n\nArguments\n\npattern::Regex: Regular expression to match\n\nReturns\n\nVector{String}: List of matching command names, sorted alphabetically\n\nExample\n\nsearch_commands(r\"^a.*n$\")  # Returns commands starting with 'a' and ending with 'n'\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.commands_in_category","page":"Core API","title":"Giac.commands_in_category","text":"commands_in_category(category::Symbol) -> Vector{String}\n\nGet all commands in a specific category.\n\nArguments\n\ncategory::Symbol: Category name (e.g., :trigonometry, :algebra)\n\nReturns\n\nVector{String}: List of command names in the category, sorted alphabetically\n\nThrows\n\nArgumentError: If the category does not exist\n\nExample\n\ntrig = commands_in_category(:trigonometry)\n# [\"acos\", \"asin\", \"atan\", \"cos\", \"sin\", \"tan\", ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.command_info","page":"Core API","title":"Giac.command_info","text":"command_info(cmd::Symbol) -> Union{CommandInfo, Nothing}\n\nGet metadata about a specific command.\n\nArguments\n\ncmd::Symbol: Command name\n\nReturns\n\nCommandInfo: Metadata about the command\nnothing: If the command is not found\n\nExample\n\ninfo = command_info(:factor)\nif info !== nothing\n    println(info.name)      # \"factor\"\n    println(info.category)  # :algebra\nend\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.list_categories","page":"Core API","title":"Giac.list_categories","text":"list_categories() -> Vector{Symbol}\n\nList all available command categories.\n\nReturns\n\nVector{Symbol}: Category names, sorted alphabetically\n\nExample\n\ncats = list_categories()\n# [:algebra, :calculus, :combinatorics, :geometry, ...]\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.help","page":"Core API","title":"Giac.help","text":"help(cmd::Union{Symbol, String}) -> HelpResult\n\nGet formatted help for a GIAC command.\n\nReturns a HelpResult struct containing parsed help information. The result auto-displays formatted output in the REPL, and provides programmatic access to individual fields.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nHelpResult: Structured help information with fields:\ncommand: Command name\ndescription: Description text\nrelated: Vector of related command names\nexamples: Vector of example expressions\n\nExample\n\nusing Giac\n\n# View formatted help (auto-displays)\nhelp(:factor)\n# factor\n# ══════\n#\n# Description:\n#   Factorizes a polynomial.\n#\n# Related:\n#   ifactor, partfrac, normal\n#\n# Examples:\n#   • factor(x^4-1)\n#   • factor(x^4-4,sqrt(2))\n\n# Access help data programmatically\nresult = help(:factor)\nresult.description  # \"Factorizes a polynomial.\"\nresult.examples     # [\"factor(x^4-1)\", \"factor(x^4-4,sqrt(2))\", ...]\n\nSee also\n\ngiac_help: Returns raw help string\nHelpResult: The return type\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.giac_help","page":"Core API","title":"Giac.giac_help","text":"giac_help(cmd::Union{Symbol, String}) -> String\n\nGet GIAC help text for a command.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\nString: Help text from GIAC, or empty string if not found\n\nExample\n\nhelp = giac_help(:factor)\nprintln(help)  # \"factor(Expr) - Factor a polynomial...\"\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.suggest_commands","page":"Core API","title":"Giac.suggest_commands","text":"suggest_commands(input::Union{Symbol, String}; n::Int=get_suggestion_count()) -> Vector{String}\n\nFind commands similar to the given input using edit distance.\n\nThis function helps users recover from typos by suggesting valid GIAC commands that are similar to the input.\n\nArguments\n\ninput: The mistyped command name (Symbol or String)\nn: Maximum number of suggestions to return (default: get_suggestion_count())\n\nReturns\n\nVector{String}: Similar command names, sorted by edit distance (ascending), then alphabetically. Returns empty vector if no similar commands found.\n\nExample\n\nsuggest_commands(:factr)\n# [\"factor\", \"cfactor\", \"ifactor\", ...]\n\nsuggest_commands(\"integrat\", n=2)\n# [\"integrate\", ...]\n\nsuggest_commands(:factor)  # Exact match\n# []  (empty, no suggestions needed)\n\nSee also\n\nsuggest_commands_with_distances: Also returns edit distances (internal function)\nset_suggestion_count: Configure default suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.set_suggestion_count","page":"Core API","title":"Giac.set_suggestion_count","text":"set_suggestion_count(n::Int) -> Nothing\n\nSet the default number of command suggestions.\n\nArguments\n\nn: Number of suggestions (must be > 0, otherwise resets to default 4)\n\nExample\n\nset_suggestion_count(6)\nget_suggestion_count()  # 6\n\nset_suggestion_count(-1)  # Invalid, resets to default\nget_suggestion_count()  # 4\n\nSee also\n\nget_suggestion_count: Get the current count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.get_suggestion_count","page":"Core API","title":"Giac.get_suggestion_count","text":"get_suggestion_count() -> Int\n\nGet the current default number of command suggestions.\n\nReturns\n\nInt: Current suggestion count (default: 4)\n\nExample\n\nget_suggestion_count()  # 4 (default)\n\nSee also\n\nset_suggestion_count: Set the suggestion count\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.search_commands_by_description","page":"Core API","title":"Giac.search_commands_by_description","text":"search_commands_by_description(query; n=20) -> Vector{String}\n\nSearch for GIAC commands whose help text contains the given keyword.\n\nUnlike search_commands which matches command names, this function searches the description and example text of each command's help documentation.\n\nArguments\n\nquery::Union{String, Symbol}: Search term to find in help text\nn::Int=20: Maximum number of results to return\n\nReturns\n\nVector{String}: Matching command names, sorted by relevance\n\nExample\n\n# Find commands related to factorization\nsearch_commands_by_description(\"factor\")\n# Returns: [\"factor\", \"ifactor\", \"cfactor\", ...]\n\n# Search for matrix operations\nsearch_commands_by_description(\"matrix\", n=10)\n\nSee also\n\nsearch_commands: Search by command name pattern\nhelp: Get detailed help for a specific command\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.JULIA_CONFLICTS","page":"Core API","title":"Giac.JULIA_CONFLICTS","text":"JULIA_CONFLICTS\n\nSet of GIAC command names that conflict with Julia keywords, builtins, or standard library functions. These commands cannot be safely exported as top-level functions but remain accessible via giac_cmd(:name, args...).\n\nConflict Categories\n\nJulia keywords: if, for, while, end, in, or, and, etc.\nBase builtins: eval, float, sum, prod, div, mod, abs, etc.\nBase math functions: sin, cos, tan, exp, log, sqrt, etc.\nLinearAlgebra: det, inv, trace, rank, transpose, etc.\n\nExample\n\n\"eval\" in JULIA_CONFLICTS  # true\n\"factor\" in JULIA_CONFLICTS  # false\n\n# Conflicting commands still work via giac_cmd\ngiac_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\nexportable_commands: Commands safe to export\nconflict_reason: Get the conflict category for a command\n\n\n\n\n\n","category":"constant"},{"location":"api/core/#Giac.exportable_commands","page":"Core API","title":"Giac.exportable_commands","text":"exportable_commands() -> Vector{String}\n\nGet a list of GIAC commands that can be safely exported without conflicting with Julia keywords, builtins, or standard library functions.\n\nThis function filters the complete command list to include only commands that:\n\nStart with an ASCII letter (a-z, A-Z)\nDo not conflict with Julia (not in JULIA_CONFLICTS)\n\nReturns\n\nVector{String}: Sorted list of exportable command names\n\nExample\n\ncmds = exportable_commands()\nlength(cmds)        # ~2000+\n\"factor\" in cmds    # true\n\"eval\" in cmds      # false (conflicts with Julia)\n\"sin\" in cmds       # false (conflicts with Base.sin)\nissorted(cmds)      # true\n\nSee also\n\navailable_commands: All commands starting with ASCII letters\nJULIA_CONFLICTS: Commands that conflict with Julia\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_valid_command","page":"Core API","title":"Giac.is_valid_command","text":"is_valid_command(name::Union{Symbol, String}) -> Bool\n\nCheck if a command name is a valid GIAC command.\n\nArguments\n\nname: Command name as Symbol or String\n\nReturns\n\ntrue if the command exists in GIAC's command list\nfalse otherwise\n\nExample\n\nis_valid_command(:factor)      # true\nis_valid_command(\"integrate\")  # true\nis_valid_command(:notacommand) # false\n\nSee also\n\nlist_commands: Get all command names\nsuggest_commands: Get suggestions for misspelled commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.conflict_reason","page":"Core API","title":"Giac.conflict_reason","text":"conflict_reason(cmd::Union{Symbol, String}) -> Union{Symbol, Nothing}\n\nGet the reason why a GIAC command conflicts with Julia.\n\nArguments\n\ncmd: Command name as Symbol or String\n\nReturns\n\n:keyword - Conflicts with Julia keyword (if, for, while, etc.)\n:builtin - Conflicts with Julia builtin function (eval, float, etc.)\n:base_math - Conflicts with Base math function (sin, cos, exp, etc.)\n:linear_algebra - Conflicts with LinearAlgebra (det, inv, trace, etc.)\n:statistics - Conflicts with Statistics (mean, median, var, etc.)\nnothing - No conflict\n\nExample\n\nconflict_reason(:eval)    # :builtin\nconflict_reason(:sin)     # :base_math\nconflict_reason(:det)     # :linear_algebra\nconflict_reason(:for)     # :keyword\nconflict_reason(:factor)  # nothing\n\nSee also\n\nJULIA_CONFLICTS: Set of all conflicting commands\nexportable_commands: Commands safe to export\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.available_commands","page":"Core API","title":"Giac.available_commands","text":"available_commands()\n\nReturn a sorted vector of all available GIAC command names that start with an ASCII letter (a-z, A-Z).\n\nThis function provides programmatic discovery of available commands. It filters out operators, keywords, and commands starting with non-ASCII characters.\n\nReturns\n\nVector{String}: Sorted list of command names starting with ASCII letters\n\nExample\n\n# List all available commands\ncmds = available_commands()\nprintln(\"Found $(length(cmds)) commands\")  # ~2100+\n\n# Check if a command exists\n\"factor\" in cmds  # true\n\"+\" in cmds       # false (operator)\n\n# Compare with exportable commands\nexportable = exportable_commands()\nlength(exportable)  # ~2000+ (excludes Julia conflicts)\n\nAccessing Commands\n\ninvoke_cmd (all commands): Universal access, always available\ninvoke_cmd(:eval, expr)  # Works for conflicting commands too\ninvoke_cmd(:factor, expr)\nSelective import: Import specific commands from Giac.Commands\nusing Giac.Commands: factor, expand\nfactor(expr)  # Works directly\nFull import: Import all ~2000+ commands\nusing Giac.Commands\nfactor(expr)   # Works directly\nifactor(expr)  # All commands available\n\nSee also\n\nexportable_commands: Commands safe to export (no Julia conflicts)\ninvoke_cmd: Universal command invocation\nGiac.Commands: Submodule with all exportable commands\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.reset_conflict_warnings!","page":"Core API","title":"Giac.reset_conflict_warnings!","text":"reset_conflict_warnings!()\n\nReset the conflict warning tracker, allowing warnings to be shown again.\n\nThis is primarily useful for testing.\n\nExample\n\ngiac_cmd(:eval, expr)  # Shows warning\ngiac_cmd(:eval, expr)  # No warning (already shown)\nreset_conflict_warnings!()\ngiac_cmd(:eval, expr)  # Shows warning again\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_giac","page":"Core API","title":"Giac.to_giac","text":"to_giac(expr)\n\nConvert an expression to GiacExpr. Extended by GiacSymbolicsExt for Symbolics.Num types.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.to_symbolics","page":"Core API","title":"Giac.to_symbolics","text":"to_symbolics(expr::GiacExpr)\n\nConvert a GiacExpr to a Symbolics.jl expression. Extended by GiacSymbolicsExt.\n\n\n\n\n\n","category":"function"},{"location":"api/core/#Giac.is_stub_mode","page":"Core API","title":"Giac.is_stub_mode","text":"is_stub_mode()\n\nCheck if the wrapper is running in stub mode (without the actual library).\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#TempApi-Submodule","page":"TempApi","title":"TempApi Submodule","text":"The Giac.TempApi submodule provides convenience functions with simplified names for common symbolic computation operations.","category":"section"},{"location":"api/tempapi/#Usage","page":"TempApi","title":"Usage","text":"","category":"section"},{"location":"api/tempapi/#Selective-Import-(Recommended)","page":"TempApi","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.TempApi: diff, factor, integrate\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)     # 2*x\nfactor(expr)      # (x-1)*(x+1)","category":"section"},{"location":"api/tempapi/#Full-Import","page":"TempApi","title":"Full Import","text":"using Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\ndiff(giac_eval(\"x^3\"), x)  # 3*x^2","category":"section"},{"location":"api/tempapi/#Calculus-Functions","page":"TempApi","title":"Calculus Functions","text":"","category":"section"},{"location":"api/tempapi/#Algebra-Functions","page":"TempApi","title":"Algebra Functions","text":"","category":"section"},{"location":"api/tempapi/#Giac.TempApi","page":"TempApi","title":"Giac.TempApi","text":"Giac.TempApi\n\nA submodule providing convenience functions with simplified names for common symbolic computation operations. These functions delegate to the corresponding giac_* functions from the main Giac module.\n\nAccess Patterns\n\nFull import (for interactive use):\nusing Giac\nusing Giac.TempApi\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)           # 2*x\nfactor(expr)            # (x-1)*(x+1)\nSelective import (recommended):\nusing Giac\nusing Giac.TempApi: diff, factor\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\ndiff(expr, x)    # Works\nfactor(expr)     # Works\nQualified access:\nusing Giac\n\nx = giac_eval(\"x\")\nexpr = giac_eval(\"x^2 - 1\")\nGiac.TempApi.diff(expr, x)\nGiac.TempApi.factor(expr)\n\nExports\n\ndiff: Differentiate an expression (delegates to giac_diff)\nintegrate: Integrate an expression (delegates to giac_integrate)\nlimit: Compute limit (delegates to giac_limit)\nfactor: Factor a polynomial (delegates to giac_factor)\nexpand: Expand an expression (delegates to giac_expand)\nsimplify: Simplify an expression (delegates to giac_simplify)\nsolve: Solve an equation (delegates to giac_solve)\n\nSee also\n\ngiac_diff, giac_integrate, etc.: Original functions in main module\nGiac.Commands: Submodule with all GIAC commands\n\n\n\n\n\n","category":"module"},{"location":"api/tempapi/#Giac.TempApi.diff","page":"TempApi","title":"Giac.TempApi.diff","text":"diff(expr, var, n=1)\n\nCompute the nth derivative of an expression with respect to a variable.\n\nDelegates to giac_diff.\n\nArguments\n\nexpr: Expression to differentiate (GiacExpr or String)\nvar: Variable to differentiate with respect to (GiacExpr or String)\nn: Order of differentiation (default: 1)\n\nReturns\n\nGiacExpr: The derivative\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^3\")\nx = giac_eval(\"x\")\ndiff(f, x)      # 3*x^2\ndiff(f, x, 2)   # 6*x\n\nSee also\n\ngiac_diff: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.integrate","page":"TempApi","title":"Giac.TempApi.integrate","text":"integrate(expr, var)\nintegrate(expr, var, a, b)\n\nCompute indefinite or definite integral.\n\nDelegates to giac_integrate.\n\nArguments\n\nexpr: Expression to integrate (GiacExpr or String)\nvar: Variable of integration (GiacExpr or String)\na, b: Optional bounds for definite integration\n\nReturns\n\nGiacExpr: The integral\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"x^2\")\nx = giac_eval(\"x\")\nintegrate(f, x)           # x^3/3\nintegrate(f, x, 0, 1)     # 1/3\n\nSee also\n\ngiac_integrate: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.limit","page":"TempApi","title":"Giac.TempApi.limit","text":"limit(expr, var, point; direction=:both)\n\nCompute the limit of an expression as a variable approaches a point.\n\nDelegates to giac_limit.\n\nArguments\n\nexpr: The expression (GiacExpr or String)\nvar: The variable (GiacExpr or String)\npoint: The point to approach\ndirection: :left, :right, or :both (default)\n\nReturns\n\nGiacExpr: The limit\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\nf = giac_eval(\"sin(x)/x\")\nx = giac_eval(\"x\")\nlimit(f, x, giac_eval(\"0\"))  # 1\n\nSee also\n\ngiac_limit: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.factor","page":"TempApi","title":"Giac.TempApi.factor","text":"factor(expr)\n\nFactor a polynomial expression.\n\nDelegates to giac_factor.\n\nArguments\n\nexpr: Expression to factor (GiacExpr or String)\n\nReturns\n\nGiacExpr: The factored expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"x^2 - 1\")\nfactor(p)  # (x-1)*(x+1)\n\nSee also\n\ngiac_factor: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.expand","page":"TempApi","title":"Giac.TempApi.expand","text":"expand(expr)\n\nExpand a polynomial expression.\n\nDelegates to giac_expand.\n\nArguments\n\nexpr: Expression to expand (GiacExpr or String)\n\nReturns\n\nGiacExpr: The expanded expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\np = giac_eval(\"(x+1)^3\")\nexpand(p)  # x^3 + 3*x^2 + 3*x + 1\n\nSee also\n\ngiac_expand: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.simplify","page":"TempApi","title":"Giac.TempApi.simplify","text":"simplify(expr)\n\nSimplify an expression.\n\nDelegates to giac_simplify.\n\nArguments\n\nexpr: Expression to simplify (GiacExpr or String)\n\nReturns\n\nGiacExpr: The simplified expression\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\ne = giac_eval(\"(x^2 - 1)/(x - 1)\")\nsimplify(e)  # x + 1\n\nSee also\n\ngiac_simplify: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"api/tempapi/#Giac.TempApi.solve","page":"TempApi","title":"Giac.TempApi.solve","text":"solve(expr, var)\n\nSolve an equation for a variable.\n\nDelegates to giac_solve.\n\nArguments\n\nexpr: The equation (assumed equal to 0) or an equation with =\nvar: The variable to solve for\n\nReturns\n\nGiacExpr: Solution set\n\nExample\n\nusing Giac\nusing Giac.TempApi\n\neq = giac_eval(\"x^2 - 4\")\nx = giac_eval(\"x\")\nsolve(eq, x)  # [-2, 2]\n\nSee also\n\ngiac_solve: Original function in main Giac module\n\n\n\n\n\n","category":"function"},{"location":"pluto/#Using-Giac.jl-with-Pluto-reactive-notebook","page":"Using with Pluto reactive notebooks","title":"Using Giac.jl with Pluto reactive notebook","text":"","category":"section"},{"location":"pluto/#LaTeX-Rendering-in-Pluto","page":"Using with Pluto reactive notebooks","title":"LaTeX Rendering in Pluto","text":"GiacExpr and GiacMatrix automatically render as LaTeX in Pluto notebooks! No extra conversion needed:\n\nusing Giac\n\nf = giac_eval(\"2/(1-x)\")  # Automatically displays as LaTeX fraction\ndf = giac_diff(f, giac_eval(\"x\"))  # Derivative also renders as LaTeX\n\nM = GiacMatrix([1 2; 3 4])  # Matrices render as LaTeX too\n\nThis works because Giac.jl implements Base.show(io, ::MIME\"text/latex\", expr) which calls GIAC's native latex command.\n\nA demo notebook is available at examples/latex_demo.jl:\n\nusing Pluto\nPluto.run(notebook=\"examples/latex_demo.jl\")\n\nSee screenshot:\n\n(Image: screencapture-pluto-notebook)","category":"section"},{"location":"linear_algebra/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"using Giac, LinearAlgebra\n\nA = GiacMatrix([1 2; 3 4])\ndet(A)        # -2\ntr(A)         # 5\ninv(A)        # inverse matrix\ntranspose(A)  # transposed matrix\n\n# Symbolic matrix\n@giac_var a b c d\nB = GiacMatrix([[a, b],\n                [c, d]])\ndet(B)  # a*d-b*c\n\n@giac_several_var m 2 2\nM = GiacMatrix([[m11, m12],\n                [m21, m22]])\ndet(M)  # m11*m22-m12*m21\n\njulia> GiacMatrix(:m, 100, 100)\n100×100 GiacMatrix:\n  m_1_1    m_1_2    m_1_3    m_1_4    m_1_5  ⋯    m_1_99    m_1_100\n  m_2_1    m_2_2    m_2_3    m_2_4    m_2_5  ⋯    m_2_99    m_2_100\n  m_3_1    m_3_2    m_3_3    m_3_4    m_3_5  ⋯    m_3_99    m_3_100\n  m_4_1    m_4_2    m_4_3    m_4_4    m_4_5  ⋯    m_4_99    m_4_100\n  m_5_1    m_5_2    m_5_3    m_5_4    m_5_5  ⋯    m_5_99    m_5_100\n      ⋮        ⋮        ⋮        ⋮        ⋮  ⋱         ⋮          ⋮\n m_99_1   m_99_2   m_99_3   m_99_4   m_99_5  ⋯   m_99_99   m_99_100\nm_100_1  m_100_2  m_100_3  m_100_4  m_100_5  ⋯  m_100_99  m_100_100","category":"section"},{"location":"linear_algebra/#Table-of-functions","page":"Linear Algebra","title":"Table of functions","text":"Function Description\nGiacMatrix(array) Create symbolic matrix\ndet(M) Determinant\ninv(M) Inverse\ntr(M) Trace\ntranspose(M) Transpose","category":"section"},{"location":"variables/#Symbolic-variables","page":"Variable Declaration","title":"Symbolic variables","text":"","category":"section"},{"location":"variables/#Simple-Variable-Creation","page":"Variable Declaration","title":"Simple Variable Creation","text":"Create a symbolic variable with @giac_var:\n\nusing Giac\n\n@giac_var a\n@giac_var a\n\na + b\n\n# or simply\n\n@giac_var a b","category":"section"},{"location":"variables/#Batch-Variable-Creation","page":"Variable Declaration","title":"Batch Variable Creation","text":"Create multiple indexed symbolic variables with @giac_several_var:\n\nusing Giac\n\n# 1D vector of variables\n@giac_several_var a 3\n# Creates: a1, a2, a3\n# Returns: (a1, a2, a3)\na1 + a2 + a3  # Symbolic sum\n\n# 2D matrix of variables\n@giac_several_var m 2 3\n# Creates: m11, m12, m13, m21, m22, m23 (row-major order)\n# Returns: (m11, m12, m13, m21, m22, m23)\n\n# N-dimensional tensors\n@giac_several_var t 2 2 2\n# Creates: t111, t112, t121, t122, t211, t212, t221, t222\n\n# Large dimensions use underscore separators\n@giac_several_var b 2 10\n# Creates: b_1_1, b_1_2, ..., b_2_10\n\n# Unicode base names supported\n@giac_several_var α 2\n# Creates: α1, α2\n\n# Capture return tuple for iteration\nvars = @giac_several_var c 4\nfor v in vars\n    println(v)\nend","category":"section"},{"location":"api/commands_submodule/#Commands-Submodule","page":"Commands submodule","title":"Commands Submodule","text":"The Giac.Commands submodule provides access to all exportable GIAC commands as Julia functions.","category":"section"},{"location":"api/commands_submodule/#Usage","page":"Commands submodule","title":"Usage","text":"","category":"section"},{"location":"api/commands_submodule/#Selective-Import-(Recommended)","page":"Commands submodule","title":"Selective Import (Recommended)","text":"using Giac\nusing Giac.Commands: factor, expand, diff\n\nexpr = giac_eval(\"x^2 - 1\")\nfactor(expr)  # (x-1)*(x+1)","category":"section"},{"location":"api/commands_submodule/#Full-Import","page":"Commands submodule","title":"Full Import","text":"using Giac\nusing Giac.Commands\n\n# All ~2000+ commands available\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))","category":"section"},{"location":"api/commands_submodule/#Qualified-Access","page":"Commands submodule","title":"Qualified Access","text":"using Giac\n\nGiac.Commands.factor(giac_eval(\"x^2-1\"))","category":"section"},{"location":"api/commands_submodule/#Core-Function","page":"Commands submodule","title":"Core Function","text":"","category":"section"},{"location":"api/commands_submodule/#Conflicting-Commands","page":"Commands submodule","title":"Conflicting Commands","text":"Commands that conflict with Julia keywords, builtins, or standard library functions are NOT exported from this module. Use invoke_cmd to call them:\n\n# These conflict with Julia and are NOT exported:\n# eval, sin, cos, det, inv, sum, prod, etc.\n\n# Use invoke_cmd instead:\ninvoke_cmd(:eval, expr)\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))\ninvoke_cmd(:det, matrix)\n\nSee JULIA_CONFLICTS for the complete list of conflicting commands.","category":"section"},{"location":"api/commands_submodule/#Available-Commands","page":"Commands submodule","title":"Available Commands","text":"Use exportable_commands() to get a list of all commands available in this module:\n\ncmds = exportable_commands()\nlength(cmds)  # ~2000+","category":"section"},{"location":"api/commands_submodule/#Giac.Commands","page":"Commands submodule","title":"Giac.Commands","text":"Giac.Commands\n\nA submodule containing all exportable GIAC commands as functions.\n\nThis module provides access to ~2000+ GIAC commands while keeping the main Giac namespace clean. Commands can be accessed through three patterns:\n\nAccess Patterns\n\nQualified access (cleanest namespace):\nusing Giac\nGiac.Commands.factor(expr)\nGiac.Commands.diff(expr, x)\nSelective import (recommended for most use cases):\nusing Giac\nusing Giac.Commands: factor, expand, diff\nfactor(expr)  # Works directly\nFull import (for interactive exploration):\nusing Giac\nusing Giac.Commands\nfactor(expr)   # All ~2000+ commands available\nifactor(expr)  # Works directly\n\nConflicting Commands\n\nCommands that conflict with Julia keywords, builtins, or standard library functions (like eval, sin, det) are NOT exported from this module. Use invoke_cmd to call them:\n\nusing Giac\ninvoke_cmd(:eval, expr)  # Works for any command\ninvoke_cmd(:sin, x)      # Including conflicting ones\n\nExports\n\ninvoke_cmd: Universal command invocation function\nAll ~2000+ non-conflicting GIAC commands (runtime-generated)\n\nSee also\n\ninvoke_cmd: Call any GIAC command by name\nGiac.JULIA_CONFLICTS: Commands that conflict with Julia\nGiac.exportable_commands: List of exportable commands\n\n\n\n\n\n","category":"module"},{"location":"api/commands_submodule/#Giac.Commands.invoke_cmd","page":"Commands submodule","title":"Giac.Commands.invoke_cmd","text":"invoke_cmd(cmd::Symbol, args...) -> GiacExpr\n\nInvoke any GIAC command by name and return the result as a GiacExpr.\n\nThis is the core function for dynamic command invocation, enabling access to all 2200+ GIAC commands through a uniform interface. It works for all commands, including those that conflict with Julia builtins.\n\nArguments\n\ncmd::Symbol: GIAC command name (e.g., :factor, :sin, :integrate)\nargs...: Command arguments (GiacExpr, String, Number, or Symbol)\n\nReturns\n\nGiacExpr: Result of command execution\n\nThrows\n\nGiacError(:eval): If command is unknown or execution fails\nArgumentError: If arguments cannot be converted to GIAC format\n\nExamples\n\nusing Giac\n\n# Single argument\nexpr = giac_eval(\"x^2 - 1\")\nresult = invoke_cmd(:factor, expr)  # Returns (x-1)*(x+1)\n\n# Multiple arguments\nx = giac_eval(\"x\")\nderivative = invoke_cmd(:diff, expr, x)  # Returns 2*x\n\n# Trigonometric functions (conflicts with Base)\nresult = invoke_cmd(:sin, giac_eval(\"pi/6\"))  # Returns 1/2\n\n# Evaluation (conflicts with Base.eval)\nresult = invoke_cmd(:eval, giac_eval(\"2+3\"))  # Returns 5\n\nSee also\n\ngiac_eval: Direct string evaluation\nGiac.search_commands: Find available commands\nGiac.help: Get help for a command\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"using Giac\n\n# Check mode\nprintln(\"Stub mode: \", is_stub_mode())\n\n# Basic evaluation\nresult = giac_eval(\"2 + 3\")        # 5\nfactored = giac_eval(\"factor(x^2 - 1)\")  # (x-1)*(x+1)\n\n# Arithmetic\n@giac_var x\n@giac_var y\nprintln(x + y)   # x+y\nprintln(x * y)   # x*y\nprintln(x ^ 2)   # x^2\n\n# Calculus\nf = giac_eval(\"x^3\")\ndf = giac_diff(f, x)               # 3*x^2\nF = giac_integrate(f, x)           # x^4/4\nf = giac_eval(\"sin(x)/x\")\nlim = giac_limit(f, x, giac_eval(\"0\"))  # 1\n\n# Algebra\ngiac_factor(giac_eval(\"x^2 - 1\"))      # (x-1)*(x+1)\ngiac_expand(giac_eval(\"(x+1)^3\"))      # x^3+3*x^2+3*x+1\ngiac_simplify(giac_eval(\"(x^2-1)/(x-1)\"))  # x+1\ngiac_solve(giac_eval(\"x^2 - 4\"), x)    # list[-2,2]\n\n# Convert to Julia types\nto_julia(giac_eval(\"42\"))    # 42::Int64\nto_julia(giac_eval(\"3/4\"))   # 3//4::Rational{Int64}","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help","page":"Command discovery and help","title":"Command Discovery and Help","text":"","category":"section"},{"location":"command_discovery_help/#Command-Discovery","page":"Command discovery and help","title":"Command Discovery","text":"using Giac\n\n# Search for commands by prefix\nsearch_commands(\"sin\")        # [\"sin\", \"sinc\", \"sinh\", ...]\n\n# Search with regex\nsearch_commands(r\"^a.*n$\")    # Commands starting with 'a' and ending with 'n'\n\n# Search by description (find commands by what they do)\nsearch_commands_by_description(\"polynomial\")  # Commands related to polynomials\nsearch_commands_by_description(\"matrix\", n=5) # Limit to 5 results\n\n# Get command metadata\ninfo = command_info(:factor)\ninfo.name                     # \"factor\"\ninfo.category                 # :algebra\n\n# List available categories\nlist_categories()             # [:trigonometry, :calculus, :algebra, ...]\n\n# Get commands in a category\ncommands_in_category(:trigonometry)  # [\"sin\", \"cos\", \"tan\", \"asin\", ...]\ncommands_in_category(:calculus)      # [\"diff\", \"integrate\", \"limit\", ...]\ncommands_in_category(:algebra)       # [\"factor\", \"expand\", \"simplify\", ...]","category":"section"},{"location":"command_discovery_help/#Help-System","page":"Command discovery and help","title":"Help System","text":"using Giac\n\n# Display Julia help for a function\n?help(factor)\n# search: factor ifactor cfactor factorial Vector giac_factor function taylor acot acos filter macro for floor acoth acotd\n# \n#   factor(args...)::GiacExpr\n# \n#   Call the GIAC factor command with the given arguments.\n# \n#   This is a convenience function exported for direct use. Equivalent to:\n# \n#     •  giac_cmd(:factor, args...)\n# \n#   See GIAC documentation for detailed usage of this command. This is available using helper functions like help(:factor) or giac_help(:factor).\n\n# Display formatted help for a Giac command\nhelp(:factor)\n# factor\n# ══════\n#\n# Description:\n#   Factorizes a polynomial.\n#\n# Related:\n#   ifactor, partfrac, normal\n#\n# Examples:\n#   • factor(x^4-1)\n#   • factor(x^4-4,sqrt(2))\n#   • factor(x^4+12*x^3+54*x^2+108*x+81)\n\n# Access help data programmatically\nresult = help(:sin)\nresult.command      # \"sin\"\nresult.description  # \"Sine or Option of the convert or convertir command (id trigsin).\"\nresult.related      # [\"asin\", \"convert\", \"trigsin\"]\nresult.examples     # [\"sin(0)\", \"convert(cos(x)^4+sin(x)^2,sin)\"]\n\n# Get raw help as a string (for backward compatibility)\nhelp_text = giac_help(:factor)\n\n# List all available commands\ncmds = list_commands()\nprintln(\"Number of commands: \", length(cmds))  # 2215\n\n# Get help count\nprintln(\"Help entries: \", help_count())  # 2215","category":"section"},{"location":"command_discovery_help/#Command-Suggestions","page":"Command discovery and help","title":"Command Suggestions","text":"When you mistype a command, Giac.jl automatically suggests similar commands:\n\nusing Giac\n\n# Typo in \"factor\" shows suggestions\nhelp(:factr)\n# factr\n# ═════\n#\n# Description:\n#   [No help found for: factr. Did you mean: factor, ifactor, cfactor, fractr?]\n\n# Get suggestions programmatically\nsuggest_commands(:factr)        # [\"factor\", \"cfactor\", \"ifactor\", ...]\nsuggest_commands(:integrat)     # [\"integrate\", \"integral\", ...]\n\n# Configure number of suggestions\nget_suggestion_count()          # 4 (default)\nset_suggestion_count(6)         # Show more suggestions\n\n# Get suggestions with edit distances\nGiac.suggest_commands_with_distances(:factr)\n# [(\"factor\", 1), (\"cfactor\", 2), (\"ifactor\", 2), ...]\n\nThe suggestion system uses Levenshtein edit distance with an adaptive threshold based on input length.","category":"section"},{"location":"command_discovery_help/#Command-Discovery-and-Help-2","page":"Command discovery and help","title":"Command Discovery & Help","text":"Function Description\nhelp(cmd) Get formatted help for a command (returns HelpResult)\ngiac_help(cmd) Get raw help text as a string\nlist_commands() List all available GIAC commands\nhelp_count() Number of commands in help database\nsearch_commands(pattern) Search commands by prefix or regex\ncommand_info(cmd) Get CommandInfo with name, category, aliases\nlist_categories() List all command categories\ncommands_in_category(cat) List commands in a category\nsuggest_commands(input) Suggest similar commands for mistyped input\nset_suggestion_count(n) Set number of suggestions (default: 4)\nget_suggestion_count() Get current suggestion count\nsearch_commands_by_description(query; n=20) Search commands by help text keywords","category":"section"},{"location":"command_discovery_help/#Command-Access-(008)","page":"Command discovery and help","title":"Command Access (008)","text":"Function Description\navailable_commands() List all commands starting with ASCII letters\nexportable_commands() List commands safe to export (no Julia conflicts)\nis_valid_command(name) Check if a command name is valid\nconflict_reason(cmd) Get why a command conflicts (:keyword, :builtin, etc.)\nJULIA_CONFLICTS Set of commands that conflict with Julia\nreset_conflict_warnings!() Reset conflict warning tracker (for testing)","category":"section"},{"location":"command_discovery_help/#Types","page":"Command discovery and help","title":"Types","text":"Type Description\nGiacExpr Symbolic expression type\nGiacMatrix Symbolic matrix type\nGiacContext Evaluation context\nHelpResult Parsed help information with .command, .description, .related, .examples fields\nCommandInfo Command metadata with .name, .category, .aliases, .doc fields","category":"section"},{"location":"command_discovery_help/#Calculus","page":"Command discovery and help","title":"Calculus","text":"Function Description\ngiac_diff(f, x, n=1) nth derivative of f with respect to x\ngiac_integrate(f, x) Indefinite integral\ngiac_integrate(f, x, a, b) Definite integral from a to b\ngiac_limit(f, x, point) Limit as x approaches point\ngiac_series(f, x, point, order) Taylor series expansion","category":"section"},{"location":"command_discovery_help/#Algebra","page":"Command discovery and help","title":"Algebra","text":"Function Description\ngiac_factor(expr) Factor polynomial\ngiac_expand(expr) Expand expression\ngiac_simplify(expr) Simplify expression\ngiac_solve(expr, x) Solve equation for x\ngiac_gcd(a, b) Greatest common divisor","category":"section"},{"location":"#Giac.jl","page":"Home","title":"Giac.jl","text":"A Julia wrapper for the GIAC computer algebra system.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Dynamic Command Invocation: Access all 2200+ GIAC commands via invoke_cmd(:cmd, args...)\nExpression Evaluation: Parse and evaluate mathematical expressions\nArithmetic Operations: +, -, *, /, ^, unary negation, equality\nCalculus: Differentiation, integration, limits, and series expansion\nAlgebra: Factorization, expansion, simplification, equation solving and GCD\nLinear Algebra: Symbolic matrices with determinant, inverse, trace, transpose operations\nCommand Discovery: Search commands, browse by category, built-in help(:cmd)\nCommands Submodule: All ~2000+ commands available via Giac.Commands for clean namespace\nTempApi Submodule: Simplified function names (diff, factor, etc.) via Giac.TempApi\nMethod Syntax: Call commands as methods: expr.factor(), expr.diff(x)\nBase Extensions: Use sin(expr), cos(expr), exp(expr) with GiacExpr\nType Conversion: Convert results to Julia native types (Int64, Float64, Rational)\nLaTeX Support: Automatic LaTeX rendering in Pluto notebooks\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Giac\")  # when registered to Julia General Registry\n\nFor full GIAC integration with C++ library, see the Installation Guide.","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Giac\n\n# Create symbolic variables\n@giac_var x y\n\n# Evaluate expressions\nexpr = giac_eval(\"x^2 + 2*x*y + y^2\")\n\n# Factor polynomials\nresult = giac_factor(expr)  # Returns (x+y)^2\n\n# Differentiate\nderivative = giac_diff(result, x)  # Returns 2*(x+y)\n\n# Integrate\nintegral = giac_integrate(giac_eval(\"x^2\"), x)  # Returns x^3/3","category":"section"},{"location":"#Command-Access","page":"Home","title":"Command Access","text":"GIAC commands are available through multiple access patterns:","category":"section"},{"location":"#1.-Universal-Command-Invocation-(Recommended)","page":"Home","title":"1. Universal Command Invocation (Recommended)","text":"using Giac\n\n# Works for ALL commands, including those conflicting with Julia\ninvoke_cmd(:factor, giac_eval(\"x^2-1\"))\ninvoke_cmd(:sin, giac_eval(\"pi/6\"))","category":"section"},{"location":"#2.-Selective-Import-from-Commands-Submodule","page":"Home","title":"2. Selective Import from Commands Submodule","text":"using Giac\nusing Giac.Commands: factor, expand, ifactor\n\nfactor(giac_eval(\"x^2-1\"))  # Works directly","category":"section"},{"location":"#3.-Full-Import-(Interactive-Use)","page":"Home","title":"3. Full Import (Interactive Use)","text":"using Giac\nusing Giac.Commands\n\nfactor(giac_eval(\"x^2-1\"))\nifactor(giac_eval(\"120\"))  # All ~2000+ commands available","category":"section"},{"location":"#Modules","page":"Home","title":"Modules","text":"Core API: Types, evaluation, and main functions\nCommands: All GIAC commands as functions\nTempApi: Convenience functions with simple names","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"install.md\", \"api/core.md\", \"api/commands.md\", \"api/tempapi.md\"]","category":"section"},{"location":"#Related-Projects","page":"Home","title":"Related Projects","text":"GIAC - The underlying computer algebra system\nlibgiac-julia-wrapper - CxxWrap bindings for GIAC\nCxxWrap.jl - C++ wrapper generator for Julia","category":"section"}]
}
